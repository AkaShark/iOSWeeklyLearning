# 2021 年摸鱼周报分类整理汇总

## 学习资料汇总

### [iOS面试资料总结](http://note.youdao.com/s/SvA1l4Gy)

地址：https://github.com/pengwj/iOSInterview

推荐来源：[pengwj](https://github.com/pengwj)

来自`岁寒啊`的整理，基本涵盖iOS各个方面的知识点，熟练掌握在这内容，再也不怕iOS”八股文“了。

![](https://cdn.zhangferry.com/Images/20201220131223.png)

每个章节都会有展开内容，多为直接整理，少部分为链接内容。

![](https://cdn.zhangferry.com/Images/20201220131326.png)

### [SwiftUI官方教程](https://developer.apple.com/tutorials/app-dev-training)

![](https://cdn.zhangferry.com/Images/20201219201033.png)

地址：https://developer.apple.com/tutorials/app-dev-training

苹果官方制作的SwiftUI教程，使用最新的SwiftUI2.0语法，更新了用例，也带来了更多典型功能介绍。教程共分为8个章节，包括语法介绍、页面跳转、数据传递、状态管理、图形绘制等核心知识点。如果你想学习SwiftUI，这绝对是最有用的教程。

### [Bash脚本教程](https://wangdoc.com/bash/)

地址：https://wangdoc.com/bash/

![](https://cdn.zhangferry.com/Images/20201219202410.png)

阮一峰老师制作的Bash脚本教程，主要介绍Linux命令行Bash的基本用法和脚本编程。Bash脚本应该是少有的一个横跨前端、后端及移动端，很多场景都有使用的语言工具。在移动端即使你没有编写Bash脚本的需求，也免不了会需要分析一些脚本的功能。

之前有段时间想系统学习Bash脚本，翻阅很多网站都没有找到满意的文档资料，直到看到这份教程，快快学起来吧。

***

### [提问的智慧](https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way "提问的智慧")

开发过程中遇到问题是非常常见的，解决问题的过程免不了要向别人或者社区论坛提问，而提问方式的好坏通常决定了你能否获得想要的答案。有这么一个github仓库：[How-To-Ask-Questions-The-Smart-Way](https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way) star数高达13.7k，专门讲述如何更有效的提问，很多论坛也将这个作为提问准则，用于提醒大家有效提问的重要性。

![](https://cdn.zhangferry.com/Images/20210103203707.png)

一个好的提问，即表达了自己对问题答案的渴望，也表达了对解答者的尊重。

### [LeetCode Cookbook](https://books.halfrost.com/leetcode/ "leetcode cookbook")

[halfrost ](https://github.com/halfrost)总结的leetcode算法题解，使用go语言完成，书中各个题目代码都已经beats 100% 了。

![](https://cdn.zhangferry.com/Images/20210103211318.png)

***

### 《Flutter技术解析与实战》

咸鱼团队对Flutter技术的探索与实战分析，听说他们已经在准备写第二本Flutter书了。可以关注公众号：**咸鱼技术获取**，后台免费获取，另有实体书可以淘宝搜索购买。

![](https://cdn.zhangferry.com/Images/20210110171712.png)

### 《Flutter开发实站详解》

掘金作者 [恋猫的小郭](https://juejin.cn/user/817692379985752) 写的Flutter实战详解，可以在京东、当当搜索购买实体或者电子版图书阅读。另外作者本人还有一个介绍 Flutter 技术的文章合辑，其与实体书不同，但内容还是很详实的，对Flutter 感兴趣，想学习的话，可以点开阅读。

地址：[GSY Flutter](https://guoshuyu.cn/home/wx/ "GSY Flutter ")

![](https://cdn.zhangferry.com/Images/20210110172952.png)

***

### [Refactoring.Guru](https://refactoringguru.cn/ "Refactoring.Guru")

一个非常有趣的讲解设计模式、SOLID原则、重构原则的网站。支持八种语言，有很多丰富的配图帮助我们理解这些重要的编程概念。

![](https://cdn.zhangferry.com/Images/20210124190413.png)

***

### [30-Days-Of-Python](https://github.com/Asabeneh/30-Days-Of-Python "30-Days-Of-Python")

简介：英文仓库、Star数5k

教程按照天数分为30天，每天都会介绍一些Python概念，伴有示例和练习。正如该仓库的介绍说的那样，真要30天完成这些内容的学习对很多人来说都是一个挑战，我们可以根据自己的节奏去学习，即使100天才学完他们都是可以的。

![](https://cdn.zhangferry.com/Images/20210228174503.png)

### [Python-100-Days](https://github.com/jackfrued/Python-100-Days "Python-100-Days")

简介：中文仓库、Star数99.9k

这个是国人写的教程，应该是Python类教程里Star数最高的了。更符合国人的学习习惯，伴有教程介绍和示例代码，而且内容更详尽，不单是Python内容，还会扩展一些前端、后端、深度学习等跟Python相关的知识。

### 斯坦福iOS开发教程

推荐来源：[tzqiang](https://github.com/tzqiang)

地址：https://cs193p.sites.stanford.edu/

这个斯坦福的iOS开发系列教程每年都会更新，最早之前还是OC语言，还是再讲MVC。现在已经更新到Swift和MVVM了，并使用SwiftUI 进行视图搭建。除视频需要到Youtube观看外，其他内容可以在国内网络环境访问。

![](https://cdn.zhangferry.com/Images/20210227190060.png)

***

### iOS开发者资源大全

![](https://cdn.zhangferry.com/Images/20210313212015.png)

**推荐来源**：[cat13954](https://github.com/cat13954)

本文档针对市面上几乎所有和 iOS 开发相关的资源文档进行重新整理、融合和补充，更适合国内开发者。

文档内容包含了数十套教程、数千个框架、不计其数的工具、网站、资料等等，目前总计 4600+，涵盖了和 iOS 学习、日常工作中相关的方方面面，不管是 iOS 新手、还是老手，都是值得收藏的一个资源文档。

对于初学者来说，可以先款速浏览一下该文档，先对 iOS 整个生态提前有个完整的印象，打开眼界，对于今后的学习、工作能节省很多时间，少走一些弯路。

对于老手，本文对内容排版也做了优化，便于查找，对于 github 开源项目，也将 Star 标注出来，以便于筛选，对于支持 Swift 项目也做了相应标记。

***

### Can Balkaya

Can Balkaya是WWDC20的学生挑战赛冠军，当前在Medium开了[专栏](https://canbalkaya.blog/ "Can Balkaya")，经常发布一些介绍Swift特性相关的文章，质量都很高。我在别的地方看到有人翻译过里面部分文章，说明它还是有一定关注度的，如果英文稍微好些的可以直接订阅这个专栏来看。

![](https://cdn.zhangferry.com/Images/20210411102014.png)

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

1、[CS-Notes](http://www.cyc2018.xyz/ "CS-Notes")

该「Notes」包含技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++等内容，知识结构简练，内容扎实。该仓库的内容皆为作者及 Contributors 的原创，目前在 Github 上获 126k Stars。

2、[Learn Git Branching](https://oschina.gitee.io/learn-git-branching/ "Learn Git Branching")

入门级的 Git 使用教程，用图形化的方式来介绍 Git 的各个命令，每一关都有一个小测试来巩固知识点。编者自己过了一遍了，体验很不错，同时填补了我自己一些 Git 知识上的漏洞和误区。

![](https://cdn.zhangferry.com/Images/20210420215429.png)

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### [LearnOpenGL CN](https://learnopengl-cn.github.io/)

欢迎来到 OpenGL 的世界。这个工程只是我([Joey de Vries](http://joeydevries.com/))的一次小小的尝试，希望能够建立起一个完善的 OpenGL 教学平台。无论你学习 OpenGL 是为了学业，找工作，或仅仅是因为兴趣，这个网站都将能够教会你现代(Core-profile)  OpenGL 从基础，中级，到高级的知识。LearnOpenGL 的目标是使用易于理解的形式，使用清晰的例子，展现现代 OpenGL 的所有知识点，并与此同时为你以后的学习提供有用的参考。

> 该教程是[原教程](https://learnopengl.com/)的中文翻译教程

### [VisuAlgo](https://visualgo.net/en)

由新加坡国立大学的教授和学生发起、制作并完善的「数据结构和算法动态可视化」网站，在该网站你可以看到许多经典、非经典的，常见的、非常见的算法的可视化，清晰明了的图形化表现和实时的代码解读可以帮助读者更好地理解各种算法及数据结构。同时该网站支持自动问题生成器和验证器（在线测验系统）。

![VisuAlgo](https://cdn.zhangferry.com/Images/20210430185031.png)

### [Announcing our Deprecated Books Repo!](https://www.raywenderlich.com/21965623-announcing-our-deprecated-books-repo)

[raywenderlich](https://www.raywenderlich.com) 是一个学习编程的网站，他们有很大一部分课程和 `iOS` / `Swift` 有关。最近他们开源了一批将要被废弃的书籍，主要是相对「过时」，没有更新必要的书籍。笔者看过其中的 `2D Games`、`3D Games`、`ARKit` 等书籍，其中介绍了 `SpriteKit` 和 `SceneKit` 的相关知识，书本会带着读者循序渐进，了解这些框架的原理以及如何应用。这次名单中还包含了 `Unity AR & VR`、`Realm` 和 `Server Side` 相关的书籍，这些书对于想要学习这些特定领域内容的读者来说是很好的选择。

可以在这里下载：[deprecated-books](https://github.com/raywenderlich/deprecated-books "deprecated-books")

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### [Five Stars Blog](https://www.fivestars.blog/)

该网站由 [Federico Zanetello](https://twitter.com/zntfdr) 一手经营，其全部内容对所有人免费开放，每周都有新的文章发布。网站内较多文章在探寻 `iOS` 和 `Swift` 的具体工作原理，其关于 `SwiftUI` 的文章也比较多，文章的质量不错，值得关注一下。

### [iOS Core Animation: Advanced Techniques 中文译本](https://zsisme.gitbooks.io/ios-/content/index.html)

iOS Core Animation: Advanced Techniques 的中文译本 GitBook 版，翻译自 [iOS Core Animation: Advanced Techniques](http://www.amazon.com/iOS-Core-Animation-Advanced-Techniques-ebook/dp/B00EHJCORC/ref=sr_1_1?ie=UTF8&qid=1423192842&sr=8-1&keywords=Core+Animation+Advanced+Techniques)，很老但是价值很高的书，感谢译者的工作。该书详细介绍了 Core Animation(Layer Kit) 的方方面面：CALayer，图层树，专属图层，隐式动画，离屏渲染，性能优化等等，虽然该书年代久远了一些，但是笔者每次看依然能悟到新知识🤖！如果想复习一下这方面知识，该译本将会是绝佳选择。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### Swift by Sundell

地址：https://www.swiftbysundell.com/

[John Sundell](https://twitter.com/johnsundell) 的博客网站（同时他也是 [Publish](https://github.com/JohnSundell/Publish) 的作者），网站主要的内容是关于 `Swift` 开发的文章、播客和新闻。其文章清晰易懂，难度范围也比较广，各个水平的开发者应该都能找到适合自己水平的文章。其网站上部分关于 `SwiftUI` 的文章中，还能实时预览 `SwiftUI` 代码所对应的运行效果，贼舒服😈。

### 100 Days of SwiftUI from Paul Hudson

地址：https://www.hackingwithswift.com/100/swiftui

[Paul Hudson](https://twitter.com/twostraws) 是一个免费的 `SwiftUI` 课程，比较基础，是一个绝佳的新手教程。他会简单教一下 `Swift` 语言，然后用 `SwiftUI` 开始构建 iOS App。课程对应的网站 [Hacking with Swift](https://www.hackingwithswift.com/) 上也有很多 `iOS` 开发中比较基础的教程和解答，总的来说比较适合刚接触 `iOS` 开发的人群🤠。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### 喵神预告：新书，开工！

[喵神](https://weibo.com/onevcat)关于 `async-swift` 的书开工了。是关于Swift5.5的新特性**协程**，待书籍完工的第一时间我们会通过周报再通知到大家。

![New Book! Go!](https://cdn.zhangferry.com/Images/11661621992188_.pic.jpg)

### 30 seconds of code

地址：https://www.30secondsofcode.org/

该网站的口号是：「能找到满足你所有开发需求的代码片段！」，他有许多语言的常用代码片段（Code Snippets），例如排序算法、hex 转 rgb、时间转换等等，能让你轻松地找到各个语言的这些常用代码，让你的开发效率大大提升！（可惜目前还没有 `Swift` 的板块🥲

![](https://cdn.zhangferry.com/Images/20210529183606.png)

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### WWDC NOTES

地址：https://www.wwdcnotes.com/

这是国外一个记录 WWDC 笔记的社区，致力于收集所有苹果的 WWDC 视频的笔记和文章。每年 WWDC 的新内容数量惊人，观看所有 WWDC 视频需要数百个小时。但有时观看这些视频也是了解某些新技术如何运作、如何使用的唯一途径。WWDC NOTES 网站可以作为对所展示内容的快速回顾、作为参考、甚至单纯是作为一种节省时间的方法。欢迎每个人对 WWDC NOTES 做出贡献👏！

### Newbie Security List

地址：https://github.com/findneo/Newbie-Security-List

一个关于网络安全学习资料的 github 仓库。其中包含网络安全相关的博客、工具、电子书籍资料、在线知识库、在线漏洞库、本地搭建教学、相关文档以及相关练习平台，目前已经获 430 🌟了。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### SwiftLee

链接：https://www.avanderlee.com/

![](https://cdn.zhangferry.com/Images/20210613155259.png)

一个分享关于 Swift、iOS 和 Xcode 技巧和窍门的每周博客，博客的文章写得清晰易懂，排版、配图和动画质量也很高。值得关注一下。同时网站作者也是 [《Swift for Good》](https://www.swiftforgood.com/ "Swift for Good") 的联合作者之一。《Swift for Good》是由20位顶级作家和演讲者撰写的新书，其所有收入将100%捐给慈善机构，有兴趣也可以看一下😺。

### WWDC21 内参

链接：https://xiaozhuanlan.com/wwdc21

一年一度的 WWDC 又来啦！由**老司机周报**牵头开展的WWDC 21内参活动，目前已经有100多名开发者报名参与其中，也包括多名摸鱼周报的编辑。我们会根据必要性和实际情况选择合适的内容进行深度解读，让大家快速了解 WWDC21 中那些值得关注的 Session。

现在也开放了今年 《WWDC21 内参》的[购买](https://xiaozhuanlan.com/wwdc21)，限时售价 9.9 元，之后会提高为 29.9 元，明年的WWDC 前夕会改为免费领取。所有的《WWDC 内参》的收入，都会归参与的作者所有。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### RSSHub

地址：https://docs.rsshub.app/

RSSHub 是一个开源、简单易用、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。RSSHub 借助于开源社区的力量快速发展中，目前已适配数百家网站的上千项内容，且可以配合浏览器扩展和移动端的 App 一起使用，同时也欢迎编写你感兴趣的订阅源。

### 中文技术文档的写作规范

地址：https://github.com/ruanyf/document-style-guide

来自阮一峰的中文技术文档的写作规范。编者在各大博客平台看技术文章的时候，经常会为文章的格式所苦恼，严重的情况下甚至导致编者直接关闭该篇文章。实际上中文文案的写作规范不是那么复杂，学十几分钟、练习几篇文章，就能写出得体的文案格式。良好的写作规范既能节约沟通成本，也能提升文章气质，学到就是赚到，是一辈子的财富。另也强力推荐这篇 [中文文案排版指北](https://github.com/sparanoid/chinese-copywriting-guidelines#%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88%E6%8C%87%E5%8C%97 "中文文案排版指北") 做参考。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### Swift Algorithm Club

地址：https://github.com/raywenderlich/swift-algorithm-club

由 [raywenderlich](https://www.raywenderlich.com/whats-new) 创立的 Swift 算法俱乐部，在这里会用 Swift 来解释和实现大部分常见的数据结构和算法，例如栈、队列、快速排序、BFS、KMP 等等，如果按照他的学习路线来学习的话，难度由浅入深，循序渐进，很适合入门选手。另外你也可以自己选择感兴趣的内容来查看，适合想要温习算法和数据结构或者温习 Swift 语法的朋友👍。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### 从 0 到 1 设计一台计算机

地址：https://www.bilibili.com/video/BV1wi4y157D3

来自 [Ele实验室](https://space.bilibili.com/481434238) 的计算机组成原理课程，该系列视频主要目的是让大家对「计算机是如何工作的」有个较直观的认识，做为深入学习计算机科学的一个启蒙。观看该系列视频最好有一些数字电路和模拟电路的基础知识，Ele 实验室同时也有关于 [数电](https://www.bilibili.com/video/BV1Hi4y1t7zY "Ele实验室 数电") 和 [模电](https://www.bilibili.com/video/BV1774114798 "Ele实验室 模电") 的基础知识介绍供大家参考。

### Git Cheat Sheet 中文版

地址：https://github.com/flyhigher139/Git-Cheat-Sheet

Git Cheat Sheet 让你不用再去记所有的 git 命令！对新手友好，可以用于查阅简单的 git 命令。

### 正则表达式 30 分钟入门教程

地址：https://deerchao.cn/tutorials/regex/regex.htm

30 分钟内让你明白正则表达式是什么，并对它有一些基本的了解。别被那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想象中的那么困难。除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### Combine Operators

地址：https://apps.apple.com/app/combine-operators/id1507756027

一个用来学习 Combine 的 App，他将一些 Combine 中的各种操作符用可视化的手段表达了出来，还附加了蠢萌蠢萌的动画效果，很适合刚接触 Combine 的朋友尝试一下。

![](https://cdn.zhangferry.com/Images/co.png)

### Stanford CS193P 2021 SwiftUI 2.0 双语字幕

地址：https://www.bilibili.com/video/BV1q64y1d7x5

Stanford CS193P 2021 SwiftUI 2.0 课程，该课程的老师是 Paul Hegarty，在 Stanford 执教 10 年左右了。该课程创办了很多年，每当 Apple 推出了新技术，例如 Storyboard、SwiftUI，这个白胡子老爷爷就会迅速跟上，更新他的课程，实乃一 it 潮人。你可以去油管 Stanford 官方账号查看该课程，也可以看看 up 主转载的该课程，还上传了中文字幕、英文字幕、繁体字幕的双语版本。理论上来说，你只需要有面向对象编程及 Swift 语言的相关基础和了解，你就可以看懂该课程，适合想要学习 SwiftUI 入门的朋友。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### Better Explaine

地址：https://betterexplained.com/

Better Explaine 是一个帮助你真正理解数学概念、使数学概念变得有趣的网站，在这个网站你可以看到很多复杂的概念被分解成图形、公式和通俗易懂的解释。网站的指导思想是爱因斯坦的这句话：“如果你不能简单地解释它，你就没有充分地理解它”，这里没有装腔作势，没有古板老师，只是一个兴奋的朋友在分享究竟是什么让一个想法变成了现实！

### 程序员可能必读书单推荐

地址：https://draveness.me//books-1

来自 [Draveness](https://draveness.me/) 的程序员书单，这是书单的系列一，应该还会有后续的推荐。这次的推荐中推荐了三本「大部头」：SICP、CTMCP 和 DDIA。即使你和小编一样感觉这些书晦涩难懂（苦笑），并不准备阅读，也可以从 Draveness 的这篇书单推荐中窥探一眼别人的编程世界是什么样的😉。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### Open Source Society University

地址：https://github.com/ossu/computer-science

这是在 Github 有 92.7k Stars 的计算机科学自学教程。它是根据计算机科学专业本科生的学位要求设计的。这些课程本身是世界上最好的课程之一，通常来自哈佛、普林斯顿、麻省理工学院等。该课程不仅仅是为了职业培训或专业发展，它是为那些希望在所有计算机学科的基本概念方面有一个适当的、全面的基础的人而设的，也是为那些有纪律、意志和（最重要的是！）良好习惯的人而设的，可以使他们通过这种方式靠自己来获得这些知识。

### Swift Programming for macOS

地址：https://gavinw.me/swift-macos/

尽管 iPhone 和 iPad 的 App 都需要 Mac 来进行代码开发，但关于实际创建原生 Mac App 的相关资料在网上很少见到。这个网站囊括了最新版本使用 Swift 和 SwiftUI 来开发 Mac App 的一些简单例子，给想要学习 Mac 开发的开发者提供一个小型的资源库。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### Seeing Theory

地址；https://seeing-theory.brown.edu/cn.html

由布朗大学的学生制作的「看见统计」课程，致力于用数据可视化的手段让数理统计概念更容易理解。其中的内容与国内本科的概率论与数理统计内容也大致相仿，且对于中文的本地化支持的非常好。

![](https://cdn.zhangferry.com/Images/%E6%88%AA%E5%B1%8F2021-08-06%20%E4%B8%8B%E5%8D%885.41.41.png)

### Hacker Laws

地址：https://github.com/dwmkerr/hacker-laws

我们常常会说「xx法则」、「xx定律」，如「摩尔定律」等。在 Hacker Laws 这个仓库中，我们可以找到在开发者群体比较有名或者是比较常见的法则和定律。但要注意：这个资源库包含了对一些法则、原则和模式的解释，**但并不提倡任何一种**。它们是否应该被应用在很大程度上取决于你正在做的事情，要根据情况来判断使用与否。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### Machine Learning Crash Course from Google

地址：https://developers.google.com/machine-learning/crash-course

来自 Google 的机器学习教程资料，以 TensorFlow APIs 为基础，进行包括视频教学、真实的案例探究和动手实践练习。由于是谷歌支持的项目，你也可以在通过学习之后，去 Kaggle 竞赛获得真实竞赛经验，或者访问 [Learn with Google AI](https://ai.google/education)，探索更完整的培训资源库。

### ML-For-Beginners from Microsoft

地址：https://github.com/microsoft/ML-For-Beginners

来自 Microsoft 的机器学习教程资料。提供了一个为期 12 周、有 24 个课时的关于机器学习的课程。在这个课程中，你将学习经典的机器学习，主要使用 Scikit-learn 作为一个库来接触机器学习。这在我们即将推出的「AI初学者」课程中有所涉及。这些课程也可以与我们即将推出的「数据科学初学者」课程搭配使用。我们将这些经典技术应用于世界上许多地区的一些数据，请与我们一起到世界各地旅行，来边学习边旅行！在 Microsoft 的仓库中你也可以找到其他所有课程。

### turicreate from Apple

地址：https://apple.github.io/turicreate/docs/userguide/

来自 Apple 的 [turicreate](https://github.com/apple/turicreate) 样例模型以及简化模型程序，他并不是学习机器学习的教程，而是给你提供解决任务的方案。你可以使用 turicreate 来训练推荐算法、对象检测、图像分类、图像相似性或活动分类等简单的机器学习模型。通过产生的 `.mlmodel` 模型，可以直接放到工程中使用 Core ML 来轻松使用。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### 中国程序员容易发音错误的单词

地址：https://github.com/shimohq/chinese-programmer-wrong-pronunciation

在担心和同事讨论代码的时候念的单词同事听不懂？开会 review 代码的时候突然遇到不会读的单词？如果你遇到过这些问题，那来看看这个 github 仓库吧。它是一个收录了在编程领域容易发音错误单词的仓库，目前已经有 14.4k stars 了，他标注出了易错的读音和正确的读音，且支持在线听读音。

### IoT for Beginners

地址：https://github.com/microsoft/IoT-For-Beginners

这是来自微软 Azure 的物联网课程，是一个为期 12 周的 24 课时的课程，其中有所有关于物联网的基础知识，每节课都包括课前和课后测验、完成课程的书面说明、解决方案、作业等。其中每个项目都是适合学生或业余爱好者的、在真实世界可用的硬件，且每个项目都会提供相关的背景知识来研究具体的项目领域。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### Adobe Color Wheel

地址：https://color.adobe.com/zh/create/color-wheel

来自 Adobe 的调色盘网站，可以选择不同的色彩规则，例如：类比、分割辅色、三元色等等方案来生成配色，也可以通过导入照片来提取颜色，并且可以通过辅助工具例如对比度检查器来确认文字和图案在底色上的预览情况。另外，你也可以通过 Adobe 的「探索」和「趋势」社区来学习如何搭配颜色，或者是寻找配色灵感。

### Awesome-tips

地址：https://awesome-tips.gitbook.io/ios/

来自知识小集整理的 iOS 开发 tips，已经整合成了 gitbook。虽然时间稍稍有点久了，但其中的文章都比较优质，在遇到的问题的时候可以翻阅一下，讲不定会有新的收获。

***

整理编辑：[zhangferry](https://zhangferry.com)

### RxSwift 学习教程

地址：http://t.swift.gg/t/rxswift-course

结合本期优秀博客的内容再推荐一个 RxSwift 学习教程。大家如果仔细看 AltConf 那篇译文的话会注意到里面的译者注：

> 国内最好的 RxSwift 教程推荐[靛青DKQing](https://medium.com/@DianQK/)所撰写的 *RxSwift 教程系列*，有兴趣的同学可以前往阅读。

由此可见靛青是当时公认的 RxSwift 代表人物，他是国内较早一批接触并深入理解 RxSwift 的人之一，对 RxSwift 在国内的推广起到了很大的帮助。

课程系列的顺序大致是这样：基本的使用 -> 基本的概念 -> 进阶的使用 -> 源码解读。

该课程写于2016年，至今有一段时间了，部分语法可能有变，但不影响我们对概念的理解，仍有一定的参考学习价值。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### 阮一峰的《C 语言入门教程》

地址：https://wangdoc.com/clang

阮一峰最近新写的《C 语言入门教程》，他对该教程做了一些介绍可以看 [这里](https://mp.weixin.qq.com/s/BLNX0MtktumBvwV5tj2ZUQ)，这对想重拾 C 语言这一门手艺的读者来说一定是一个巨大的帮助。同时各位读者若发现错误和遗漏，欢迎大家到仓库提交补丁。

### Github 漫游指南

地址：http://github.phodal.com/

如果你是一名 Github 新手的话，这本《Github 漫游指南》将会带你漫游 Github 的世界，带你了解 Github 到底是什么，他有什么用，该怎么去使用它。如果你是一名老手了，它也可以带你深入平时可能不会注意的细节，帮助你更加了解这个我们每天都在使用的工具。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### a-picture-is-worth-a-1000-words

地址：https://github.com/girliemac/a-picture-is-worth-a-1000-words

把复杂知识放进简单涂鸦！该仓库中用可爱的涂鸦绘制了包涵数据结构、算法、机器学习入门、web 基础开发的一些知识，画风可爱，简单易懂。但要下载的时候要注意一下，涂鸦图片很大。

### raywenderlich/swift-style-guide

地址：https://github.com/raywenderlich/swift-style-guide

来自 raywenderlich 的 Swift 代码风格指南，其风格的重点在于印刷和网页版的可读性，这个风格指南是为了保持他们的书籍、教程和入门套件中的代码的优雅和一致性。可以供大家有特别需要时参考和借鉴。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### gitmoji

地址：https://gitmoji.js.org/

gitmoji 是一个 GitHub 提交信息的 emoji 指南😎，致力于成为一个标准化的 emoji 备忘单📋，当你在提交信息时，使用 emoji 来描述成了一种简单的方式来识别提交的目的和意图🍰，因为维护者只需要看一眼所使用的 emoji 就能明白🧐。由于有很多的 emoji，所以这里创建了一份指南来让使用 emoji 变得轻松、易懂、一致🥳。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### Xcode Build Settings

地址：https://xcodebuildsettings.com/

顾名思义，这个网站的作用是展示 Xcode 所有的 Build Settings。你可以在这里按分类查看所有的设置项，搜索你想要的设置项，或查询某个设置项的值类型及其默认值。对于常常要和 Build Settings 打交道的开发者来说，这个网站很实用。

### Data-Science-For-Beginners

地址：https://github.com/microsoft/Data-Science-For-Beginners

来自 Microsoft 的 Data Science 基础课程，为期 10 周，有 20 节课。这是一个基于项目的课程，配套 40 多个小测试，通过该课程你可以学习到关于数据科学的基础知识。每节课程还有精美的插画配图，有兴趣学习 Data Science 的朋友可以尝试一下。

![](https://cdn.zhangferry.com/Images/Data-Science-For-Beginners.png)

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### Flutter Apprentice from raywenderlich

地址：https://www.raywenderlich.com/books/flutter-apprentice

raywenderlich 新出的 Flutter 教程，该网站的教程一直以简单易懂、清晰明了为特点，如果是想入门 Flutter 的话，这本书将会是不错的选择。另外该网站的 Swift Apprentice 也出了新的版本，有兴趣重温一下的小伙伴也可以阅读一下。

### 认知偏差知识手册

地址：https://s75w5y7vut.feishu.cn/docs/doccn3BatnScBJe7wD7K3S5poFf

一份心理学知识词条的普及手册，无关乎代码，但是对互联网工作者来说，阅读之后也许可以让你更加了解产品与用户之间的关系，能够提升产品的细节，用户的体验等等。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### OKR.com

地址：https://www.okr.com/

来自字节跳动的 OKR 学习网站。你可能或多或少听说过 OKR 这个概念，但没有深入了解过。OKR 是一套协助组织进行目标管理的工具和方法，它能帮助团队明确目标、聚焦重点。该网站会从 OKR 是什么开始，带你了解 OKR 理论的优缺点，价值在哪，或者适不适合你的个人或你的公司规划，你还能在网站上面找到许多关于 OKR 的资源。

### Fucking SwiftUI

地址：https://fuckingswiftui.com/

Fucking SwiftUI 是一个关于 SwiftUI 的 Cheat Sheet。这上面有许多许多（关于技术的和无关技术的都有）关于 SwiftUI 的问答，类似 "我该学 SwiftUI 么"、"SwiftUI 中 List 如何使用？"、"SwiftUI 会取代 UIKit 么？" 等等问题，也有几乎所有 SwiftUI 控件的使用方式，希望能帮到大家。（如果你的浏览器不能打脏话可以使用这个链接：https://goshdarnswiftui.com/）

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### Vue Color Avatar

地址：https://github.com/Codennnn/vue-color-avatar

一个纯前端实现的头像生成网站，使用 Vite + Vue3 开发，是一款矢量风格头像的生成器，你可以搭配不同的素材组件，或者通过配置代码，来生成自己的个性化头像。

### 浏览器的工作原理：新式网络浏览器幕后揭秘

地址：https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/

这是一篇全面介绍 WebKit 和 Gecko 内部操作的入门文章，是以色列开发人员塔利·加希尔大量研究的成果。在过去的几年中，她查阅了所有公开发布的关于浏览器内部机制的数据，并花了很多时间来研读网络浏览器的源代码。学习浏览器的内部工作原理将有助于你作出更明智的决策，并理解那些最佳开发实践的个中缘由。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### 棒棒彬·技术参考周刊

地址：https://www.yuque.com/binboy/increment-magzine

这是一份由 [Binboy👻棒棒彬](https://www.yuque.com/binboy) 在语雀上梳理总结的技术参考周刊。这份周刊是作者学习与生活的沉淀和思考，既有广度，也有深度，还有态度。就像其发刊词的标题：「与技术世界保持链接」，在周刊中你可以看到作者学习技术的过程和经验，也能看到科技与生活的一些新鲜事，这里可能有你正在关注的，亦或者是从来没听说过的技术信息，这些信息既是作者与他自己「第二大脑」的链接，也是作者与读者交流的媒介，同时推动着作者与读者一起前进。这里改编引用一段[发刊词](https://www.yuque.com/binboy/increment-magzine/sno2ef)中的一段话来抛砖引玉 ：

> 做技术，追求深度无可厚非，只是无需厚此薄彼，我个人而言倾向于「修学储能，先博后渊」的。技术世界的开源、互联网的开放更是给了见多识广一片良好的土壤，我们可以了解了技术、工具现状，将其充分地应用、解决现实世界中的普通问题，并在过程中不断完善。当真正遇到边界时，再结合对已有技术和工具的融会贯通去创造真正的新技术、新工具，也不迟。
> 
> *朝一个方向看得再远，你也未必能看到新方向*
> 
> *———— 修学储能，先博后渊*

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### 戴铭的 Swift 小册子

地址：https://github.com/ming1016/SwiftPamphletApp

戴老师用 Swift 写的、按照声明式 UI、响应式编程范式开发的 Swift 小册子。你可以在这本小册子中查询到 Swift 的语法指南，同时还有 Combine、 Concurrency 和 SwiftUI 这些库的使用指南，你还可以在这追踪到一些知名仓库、开发者的 Github 动态和本仓库的 Issues。由于是开源的，你也可以自己调试学习或者是为项目作出贡献。

### 2021 黑五特惠

地址：https://github.com/mRs-/Black-Friday-Deals

这个仓库收集了今年黑五打折的开发类、效率类、工具类的软件，好多知名的不知名的软件都在打折，有需要的快冲！

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### 独立开发者经验分享

**地址**：https://github.com/loonggg/DevMoneySharing

全职独立开发者是一群相对比较自由的开发者，但自由的背后也有赚不到钱、产品没人用的焦虑，在这个仓库中你可以看到很多国内国外的独立开发者赚钱的经验。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### 计算机教育中缺失的一课（中文版）

**地址**：https://missing-semester-cn.github.io/

大学里的计算机课程通常专注于讲授从操作系统到机器学习这些学院派的课程或主题，而对于如何**精通工具**这一主题则往往会留给学生自行探索。在这个系列课程中，会讲授**命令行**、**文本编辑器**、**Git** 提供的多种特性等等。学生在他们受教育阶段以及在他们的未来职业生涯中都会和这些工具朝夕相处。因此，花时间打磨使用这些工具的能力并能够最终熟练地、流畅地使用它们，在计算机教育中也是重要的一个部分。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### 软件随想录

**地址**：https://book.douban.com/subject/4163938/

Joel Spolsky 的 Blog 纸质版文集，中文版由阮一峰翻译。作者 Joel Spolsky 毕业于耶鲁大学，曾任微软公司 Excel 开发小组项目经理，现在自己创业做 CEO，同时也是 Stack Overflow 的合伙人。他在书中以诙谐幽默的笔触将自己在软件行业的亲身感悟娓娓道来，其中包含关于软件、人才、创业和管理的很多看法。需要提醒读者的是本书的大部分内容都写于 2004 年底左右，是一本老书了，但其中很多内容都值得细细品味。这边节选一些有意思的观点供没看过的读者过过瘾:

> 1. 从数量上来说，优秀的人才很少，而且从不出现在招聘市场上。
> 2. 我从来没有见过哪个能用 Scheme 语言、Haskell 语言、C 语言中的指针函数编程的人，竟然不能在两天里面学会 Java，并且写出的 Java 程序质量竟然不能胜过那些有 5 年 Java 编程经验的人士。
> 3. 看东西的时候，你的视力只是在你的视野中很小一块区域是高分辨率的，而且视野中央还有相当大的一个盲点。但是，你依然想当然的认定你能够超清晰的看清视野中的每一个角落。
> 4. 别担心所有工作都被印度人抢走。😁

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### 学习正则表达式

**地址**：https://regexlearn.com/zh-cn

这是一个学习正则表达式的网站。它从零开始，可以让不懂正则表达式的小白简单入门，比较特别的是，它采用答题的方式，一步一步的带你了解正则表达式的工作方式以及原理，每一个小关卡都有对应的知识点和实时匹配展示，当你边写表达式的时候你就能看到对应的结果。另外这种关卡的方式也让人很有成就感，让你闯关欲罢不能！相信对不是很熟悉了解正则表达式的朋友来说是很好的学习材料。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### 《µGo语言实现——从头开发一个迷你Go语言编译器》

**地址**：https://github.com/chai2010/ugo-compiler-book

µGo 是 Go 语言的真子集（不含标准库部分）, 可以直接作为 Go 代码编译执行，作者尝试以实现 µGo 编译器为线索，以边学习边完善的自举方式实现一个玩具语言，目前还没写完，对编译器或者 Go 感兴趣的小伙伴可以关注一下。这里有一份作者写的 [Go 编译器定制简介](https://chai2010.cn/ugo-compiler-book/talks/go-compiler-intro.html "Go 编译器定制简介") 供参考，同时作者还有[《Go语法树入门(出版名:Go语言定制指南)》](https://github.com/chai2010/go-ast-book)和[《Go语言高级编程》](https://github.com/chai2010/advanced-go-programming-book)等开源图书作品。

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### Visual Web Skills

**地址**：https://andreasbm.github.io/web-skills/

这是一份可视化的 Web 技能列表，它对刚开始学习 Web 或已经工作多年并想学习新东西的人都很有用，你可以从中了解 Web 开发的大概路径和图谱，按顺序或者选择自己感兴趣的部分来看。除此之外最吸引人的是这个列表可视化的非常棒，每个图标符号都很大方美观形象，快来看一下！

![](https://cdn.zhangferry.com/Images/Web%20Skills.png)

***

整理编辑：[Mimosa](https://juejin.cn/user/1433418892590136)

### 程序员考公指南

**地址**：https://github.com/coder2gwy/coder2gwy

互联网首份程序员考公指南，由 3 位已经进入体制内的前大厂程序员联合献上。程序员近几年内卷的程度有些加重了，不少人萌生了回家当公务员的想法，这个仓库主要分享了他们上岸的一些经历和一些最佳实践，也有他们上岸之后的一些感想和感悟。

### Vim 从入门到精通（中文）

**地址**：https://github.com/wsdjeg/vim-galore-zh_cn

许多程序员可能了解过一点点 Vim，但从没用过，也不知道具体是怎么用的以及有什么有点，为什么有这么多人用。该仓库会从 Vim 是什么开始，讲述 Vim 的哲学，并带你入门 Vim 的世界。同时仓库中也记录列举了大部分用法和规则，其作为一个速查表也是很好用的。

## 开发工具汇总

较少好用的开发工具。

### Vimac App - control macOS UI with the keyboard only

推荐来源：[beatman423](https://github.com/beatman423)

下载地址：https://vimacapp.com

软件状态：免费、开源

一款Mac上的键盘效率工具，通过用键盘代替鼠标操作从而提高电脑使用效率，非常适合程序员使用。
功能简介：

* 快捷键“Ctrl+Space”激活点击模式，输入提示字母完成鼠标单击操作，按住“Shift”键输入提示字母完成鼠标右键单击操作，按住“Command”键输入提示字母完成鼠标双击操作
* 快捷键“Ctrl+S”激活滚动模式，使用HJKL+DU键进行滚动操作，按“TAB”键即可循环选择滚动区域

### Xnip - Mac上简单好用的截图工具

推荐来源：[once-liu](https://github.com/once-liu)

下载地址：https://zh.xnipapp.com/

软件状态：免费

为什么有微信或QQ的默认截图，还推荐这个？
因为好用。相比于微信或QQ的截图，还有几个好用功能：

- 滚动截图
- 贴图
- 可漂浮与桌面，多桌面切换时也会存在
  在一些需要局部数据对比时尤其好用。比如服务端的接口API，截图漂浮后，可以方便的撸代码。

### Dozer -  Mac端的状态栏管理工具

推荐来源：[zhangferry](https://github.com/zhangferry)

下载地址：https://github.com/Mortennn/Dozer/releases

软件状态：免费、开源

当在Mac上开较多软件时，会发现状态栏总是满满当当，看着很不舒服，也降低我们需要选择特定软件的效率，而Dozer就是为解决这种问题而生的。Dozer可以将系统状态栏按照两个小点分为三部分，对于不想让一直显示的图标，我们可以按住Command拖动图标至第一个小圆点的左侧，之后点击第二个小圆点就可以实现隐藏状态栏的功能了。

之前我的状态栏是这样的：

![](https://cdn.zhangferry.com/Images/20201219214427.png)

整理之后就变成了这样：

![](https://cdn.zhangferry.com/Images/20201219214453.png)

![](https://cdn.zhangferry.com/Images/wechat_official.png)

***

推荐好用的开发工具。

### A Companion for SwiftUI

推荐来源：[AlleniCode](https://github.com/AlleniCode)

下载地址：https://apps.apple.com/cn/app/a-companion-for-swiftui/id1485436674?mt=12

软件状态：付费￥328.00

作者的 [SwiftUI 实验室](https://swiftui-lab.com)，A Companion for SwiftUI 是一款可以记录 iOS 和 macOS 平台的 SwiftUI 视图，形状，协议，场景和属性包装的应用程序。该应用程序还包含每种方法的示例，其中有许多都是交互式的，并且嵌入在应用程序中运行。通过使用关联的控件，你可以看到它们对视图的直接影响，以及如何修改你的代码以产生这样的效果。

![](https://cdn.zhangferry.com/Images/20210103204133.png)

### Go2Shell - 在终端中打开当前Finder目录

推荐来源：[RayLeeBoy](https://github.com/RayLeeBoy)

下载地址：https://zipzapmac.com/go2shell

软件状态：免费

使用介绍：

1. 双击下载的文件, 将Go2Shell拖入Applications目录中
2. 在Applications中, 双击打开Go2Shell, 出现下面的窗口
   ![](https://cdn.zhangferry.com/Images/20210103221327.png)
3. 点击Install Go2Shell to Finder完成安装
4. 打开Finder窗口, 在工具栏中出现Go2Shell图标
5. 点击Go2Shell图标, 就会在终端中打开当前Finder目录

#### 使用 Alfred 制作打开终端的快捷键

这是我目前在用的一种形式，前提是需要安装Alfred：选中某一文件，按下`Command+ T`，就可以打开终端并定位到该文件夹路径。它和Go2Shell实现效果类似，但它可以不依赖Finder，对于桌面文件的操作更友好一些。

实现方式如下：

1、在Workflows里新建HotKeys，编辑快捷键`Command + T`

2、右键该HotKeys > Insert After > Actions > Run Script 新建脚本

3、脚本编辑窗口选择脚本语言：/usr/bin/osascript(AS)，意为Apple Script

4、在脚本框输入如下脚本，保存即可：

```
tell application "Finder"
    -- get selection path
    set pathFile to selection as text
    set pathFile to get POSIX path of pathFile
    -- fix space problem in the directory
    set pathFile to quoted form of pathFile
    tell application "iTerm"
       create window with default profile
       tell current session of current window
          write text pathFile
       end tell
    end tell
end tell
```

该脚本是针对`iTerm`终端设置的。

***

推荐好用的开发工具。

### MacZip(原名eZip)

**推荐来源**：[zhangferry](https://github.com/zhangferry)

**下载地址**：https://ezip.awehunt.com/

**软件状态**：免费

**使用介绍**

Mac上非常好用的解压缩软件：

* 支持rar, zip, 7z, tar, gz, bz2, iso, xz, lzma, apk, lz4等超过二十种压缩格式。
* 支持批量文件加密。
* 支持压缩包预览

![](https://cdn.zhangferry.com/Images/20210110110014.png)

### uTools

**推荐来源**：[zhangferry](https://github.com/zhangferry)

**下载地址**：https://u.tools/

**软件状态**：免费（部分功能付费）

**使用介绍**

uTools是一个丰富的生产力工具集，支持将近百种的插件。它的使用方式和 Alfred 类似，通过快捷键调出输入框，并通过特殊指令执行结果。但它有比 Alfred 更简单的插件集成方式，在我看来它是更易用的。

![](https://cdn.zhangferry.com/Images/20210110110536.png)

***

推荐好用的开发工具。

### kaleidoscope

**推荐来源**：zhangferry

**下载地址**：https://kaleidoscope.app/

**软件状态**：付费，$69.99

**使用介绍**

kaleidoscope中文翻译是万花筒，它是一款颜值很高，专业性很强的diff工具。不光能查看文本的不同，还能识别图片和文件夹的不同。我们可以将它与 git 组合使用，使用它替换git的mergetool。

![](https://cdn.zhangferry.com/Images/20210124184141.png)

### Sherlock

**推荐来源**：zhangferry

**下载地址**：https://sherlock.inspiredcode.io/

**软件状态**：付费，$49

**使用介绍**

在iOS开发过程中的UI调试常常是让人痛苦的，因为不支持热更新，我们稍微改动一点地方就需要编译整个项目重新运行，这无疑很浪费时间。而Sherlock就是用于解决这个问题的工具（仅支持模拟器），我们可以实时修改各个控件的UI属性，并进行查看最终效果。

![](https://cdn.zhangferry.com/Images/20210124195019.png)

***

推荐好用的开发工具。

### Diagrams.net

**推荐来源**：[zhangferry](zhangferry.com)

**地址**：https://www.diagrams.net/

**软件状态**：免费，[开源](https://github.com/jgraph/drawio)

**使用介绍**

强大且方便的流程图绘制软件，同时支持Web端和桌面端。和[Processon的](https://www.processon.com/)免费版只能添加9个文件的限制，Diagrams.net的文件数量是无限制的，而且它支持的流程图控件比Processon还要更多。

![](https://cdn.zhangferry.com/Images/20210227191005.png)

* 支持几乎所有的主流流程图元素
* 远程存储，文件数量不限，可以存储至Github、Google Drive、Dropbox等地方
* 支持本地桌面端，可以离线绘制，本地存储
* 支持链接共享，通过链接查看我们当前绘制的流程图
* 可以导出为图片、HTML、PDF等多种格式

### Github1s.com

**推荐来源**：[zhangferry](zhangferry.com)

**地址**：https://github.com/conwnet/github1s

这个工具可以使我们访问github的仓库就像直接在VSCode中打开一样，使用方法非常简单，就是将网站域名换成github1s，以Swift仓库为例，访问：https://github1s.com/apple/swift，得到的结果如下。

![](https://cdn.zhangferry.com/Images/20210228152659.png)

我们可以像在VSCode里一样，直接在浏览器里查看仓库代码。

***

推荐好用的工具。

### F.lux

**推荐来源**：[zhangferry](zhangferry.com)

**地址**：https://justgetflux.com/

**软件状态**：免费

**使用介绍**

电脑的显示器亮度一般是全天保持不变的，这个亮度对于白天使用来说没有任何问题，但是对于夜间使用的话就会有些刺眼，出于对视力的保护，夜间应该让屏幕亮度低一些，暖一些。

F.lux就是处理这一问题的软件，他可以根据时间调节屏幕颜色，白天亮度像太阳光，在夜间时会让屏幕看着更像是室内光。

![](https://cdn.zhangferry.com/Images/20210314141348.png)

### Kap

**推荐来源**：[highway](https://github.com/HighwayLaw)

**地址**：https://getkap.co/

**软件状态**：免费，[开源](https://github.com/wulkano/kap "Kap开源地址")

**使用介绍**

一款开源且简洁高效的屏幕录制软件，可以导出为GIF，MP4，WebM，APNG等格式，而且会有很不错的压缩率。

![](https://cdn.zhangferry.com/Images/20210313211617.png)

鉴于微信公众号对GIF的两条限制：

1、不能超过300帧

2、大小不能超过2M

我们需要对一些GIF进行修剪和压缩才能上传。

删除帧数有一个简单的方法：用Mac自带的预览功能打开GIF，选中想要删除的帧，按Command + Delete即可删除指定帧。另外对于多个连续帧的选中，可以先单击选中第一帧，再按住Shift单击选中末尾帧，即可选中这个区间连续的所有帧。

对于GIF的压缩，推荐另一个工具：docsmall。

### docsmall

**推荐来源**：[zhangferry](zhangferry.com)

**地址**：https://docsmall.com/gif-compress

**软件状态**：免费，Web端

**使用介绍**

上传需要压缩的gif文件即可

![](https://cdn.zhangferry.com/Images/20210313211739.png)

***

推荐好用的工具。

### P4Merge

**推荐来源**：zhangferry

**地址**：https://www.perforce.com/downloads/visual-merge-tool

**软件状态**：对开发者免费

**使用介绍**

非常强大的可视化diff工具，如果你嫌[Kaleidoscope](https://kaleidoscope.app/)太贵的话，可以用它做代替品。我们可以把它集成进git，通常diff工具有两个作用一个是作为difftool，一个是作为mergetool。配置流程如下：

```shell
# difftool
$ git config --global diff.tool p4merge
$ git config --global difftool.p4merge.cmd \
"/Applications/p4merge.app/Contents/Resources/launchp4merge \$LOCAL \$REMOTE"
# mergetool
$ git config --global merge.tool p4merge
$ git config --global mergetool.p4merge.cmd "/Applications/p4merge.app/Contents/MacOS/p4merge $PWD/$BASE $PWD/$LOCAL $PWD/$REMOTE"
```

以下是作为mergetool的界面，下面内容为最终合并的内容，我们可以通过右侧的扩展按钮选择当前应该选择哪个分支的内容。

![](https://cdn.zhangferry.com/Images/20210327200304.png)

***

推荐好用的工具。

### Cleaner for Xcode

**推荐来源**：zhangferry

**地址**：https://github.com/waylybaye/XcodeCleaner-SwiftUI

**软件状态**：开源版本免费，AppStore版本$0.99

**使用介绍**

这个应用可以帮助你清除遗留以及废弃文件，从而极大的节省硬盘空间。 你可以每月或者每周运行一次进行清理。

![](https://cdn.zhangferry.com/Images/20210410105340.png)

******

整理编辑：[zhangferry](https://zhangferry.com)

### SwitchHosts

**地址**：https://swh.app/zh/

**软件状态**：[开源](https://github.com/oldj/SwitchHosts)，免费

**使用介绍**

SwitchHosts 是一个管理、切换多个 Host 方案的工具。它支持多个 Host 方案的不同组合；支持导入导出，方便协作分享；还可以通过 Alfred 插件进行快速切换。
![SwitchHosts](https://cdn.zhangferry.com/Images/20210430084948.png)

### DevUtils

**地址**：https://devutils.app/

**软件状态**：[开源](https://github.com/DevUtilsApp/DevUtils-app)，部分功能付费

**使用介绍**

DevUtils 是一个开源的开发工具聚合的应用。它包含了常用的时间戳解析，JSON 格式化，Base64 编解码，正则表达式测试等功能。有了它我们就可以放弃掉站长之家，各种 JSON 格式化网站的使用了。

大家如果不想付费，直接下源码，关掉付费验证就行。如果觉得软件有帮助且有支付能力的话希望还是可以支持下作者。

![DevUtils](https://cdn.zhangferry.com/Images/20210430085707.png)

***

整理编辑：[zhangferry](https://zhangferry.com)

### Moment

**地址**：https://fireball.studio/moment

**软件状态**：￥30，可以试用7天

**使用介绍**

Moment 是一个存在于菜单栏和通知中心的倒计时应用程序，以帮助你记住最难忘的日子和生活。这个类似手机端的 Countdown。

![](https://cdn.zhangferry.com/Images/menubar-mockup.jpg)

### One Switch

**地址**：https://fireball.studio/oneswitch

**软件状态**：￥30，可以试用7天

**使用介绍**

One Switch 是一个聚合的开关控制软件，使用它可以在菜单控制栏直接配置桌面的隐藏显示、锁屏、暗黑模式、连接AirPods 等功能。

![](https://cdn.zhangferry.com/Images/mbp-mockup.png)

***

整理编辑：[brave723](https://juejin.cn/user/307518984425981/posts)

### SwiftFormat for Xcode

**地址**：https://github.com/nicklockwood/SwiftFormat

**软件状态**：免费 ，开源

**使用介绍**

SwiftFormat 是用于重新格式化 Swift 代码的命令行工具。它会在保持代码意义的前提下，将代码进行格式化

很多项目都有固定的代码风格，统一的代码规范有助于项目的迭代和维护，而有的程序员却无视这些规则。同时，手动强制的去修改代码的风格又容易出错，而且没有人愿意去做这些无聊的工作。

如果有自动化的工具能完成这些工作，那几乎是最完美的方案了。在代码 review 时就不需要每次都强调无数遍繁琐的代码格式问题了。

![](https://cdn.zhangferry.com/Images/20210522213832.png)

### Notion

**地址**: https://www.notion.so/desktop

**软件状态**：个人免费，团队收费

**使用介绍**

Notion 是一款极其出色的个人笔记软件，它将“万物皆对象”的思维运用到笔记中，让使用者可以天马行空地去创造、拖拽、链接；Notion 不仅是一款优秀的个人笔记软件，其功能还涵盖了项目管理、wiki、文档等等。

##### 核心功能

* 支持导入丰富的文件和内容 
* 内置丰富的模板
* 简洁的用户界面、方便的拖动和新建操作
* 支持 Board 视图，同时可以添加任意数量的其他类型视图并自定义相关的过滤条件
* 复制图片即完成上传，无需其他图床 
* 保存历史操作记录并记录相关时间
* 强大的关联功能，比如日历与笔记，笔记与文件以及网页链接

![](https://cdn.zhangferry.com/Images/20210522213919.png)

***

整理编辑：[zhangferry](https://zhangferry.com)

### Whatpulse

**地址**：https://whatpulse.org/

**软件状态**：基础功能免费，高级功能付费

**使用介绍**

Whatpulse是一个电脑使用检测统计软件，它可以统计你每天的键盘、鼠标、网络等情况的使用详情并将其做成简单的统计表格，用于分析每天的电脑使用情况。

翻到一张之前公司电脑使用该软件将近一年的留存成果，100万+ 按键次数，使用最多的竟然是删除键。。

![](https://cdn.zhangferry.com/Images/20210529185605.png)

### OctoMouse

**地址**：https://konsomejona.github.io/OctoMouse/index.html

**软件状态**：免费，[开源](https://github.com/KonsomeJona/OctoMouse)

**使用介绍**

该软件主要用于统计键盘及鼠标的行为信息，比较有意思的是，它对鼠标的统计会包含移动距离参数。可以试试看多久才能让鼠标移动 5km。

![](https://cdn.zhangferry.com/Images/20210529191107.png)

***

### 柠檬清理

 整理编辑：[brave723](https://juejin.cn/user/307518984425981/posts)

**地址**: https://lemon.qq.com/

**软件状态**: 免费 

**软件介绍**

腾讯柠檬清理 Lite 版-重点聚焦清理功能，包含系统/应用垃圾清理、大文件清理、重复文件清理、相似照片清理 4 个方面，当前还支持在状态栏上查看当前网速信息，帮助你实时了解 Mac 状况。

![](https://cdn.zhangferry.com/Images/16227749924686.jpg)

**核心功能**

* 便捷好用的状态栏清理：可直接在状态栏上查看实时网速，方便及时了解网速变化。支持快速清理，轻轻一点，不留垃圾。
* 系统/应用垃圾清理
* 大文件清理：帮你快速全面查找占用超过 50M 的大文件。
* 重复文件清理

***

整理编辑：[brave723](https://juejin.cn/user/307518984425981/posts)

### Diffchecker

**地址**：https://www.diffchecker.com/

**软件状态**：Web端免费，桌面端 $9/月

**介绍**

Diffchecker 是一款简单好用的差异比较工具，使用可帮助用户快速的比较您的文本文件、文档、PDF、照片、图形和扫描等，并且界面简单直观，输入两个文件的内容，然后单击“查找差异”即可，并且具有绝对的安全性，能够保障您的文件安全，具有统一差异、字符级差异、文件夹差异、导出为 PDF、语法高亮、文件导入、无广告等优势。

![](https://cdn.zhangferry.com/Images/1623388796593.jpg)

***

整理编辑：[zhangferry](https://zhangferry.com)

### WWDC

**地址**：https://wwdc.io/ 

**软件状态**：免费，[开源](https://github.com/insidegui/WWDC)

**介绍**

一个开源的非官方 WWDC 视频的应用，其支持视频下载、最高 5 分钟的视频切割、书签功能、iCloud 同步、Chromecast 投屏、画中画功能等等。相比于官方应用来说，其功能只多不少（官方新版的 Developer 应用添加了代码片段预览功能），而且更新比较迅速，已经发展到了 v7.3.3 版本，可以查看 2021 年的 Sessions。

![](https://cdn.zhangferry.com/Images/20210626230114.png)

### ScreenSize

**地址**：https://www.screensizes.app/

**介绍**

一个在线的 Apple 设备尺寸及设备内各组件的尺寸整理网站，非常之全。这里简要概括下其在 iPhone 设备包含的内容：

* 横竖屏状态的安全区域大小
* 三种 Widget 尺寸的大小
* 标准模式和系统放大模式的尺寸大小
* 各个设备之间的尺寸对比

![](https://cdn.zhangferry.com/Images/20210626223430.png)

***

整理编辑：[brave723](https://juejin.cn/user/307518984425981/posts)，[zhangferry](https://zhangferry.com)

### Cakebrew

**地址**：https://www.cakebrew.com/

**软件状态**：免费，[开源](https://github.com/brunophilipe/Cakebrew)

**软件介绍**：

Homebrew 是 Mac 端常用的包管理工具，但其仅能通过命令行操作，对那些不擅长使用命令行的开发来说会是一种苦恼，而且命令行确实不够直观。Cakebrew 是一款桌面端的 Homebrew 管理工具，它包含常用的 Homebrew 功能，并将其可视化，像是已安装工具，可升级工具以及工具库等功能。

![](https://cdn.zhangferry.com/Images/20210704205546.png)

### Paste - Clipboard Manager

**地址**: https://apps.apple.com/us/app/paste-clipboard-manager/id967805235

**软件状态**: 收费 ¥98/年 

**软件介绍**：

Paste for Mac 是 Mac 平台上一款专业的剪切板记录增强工具，它能够为您储存您在设备上复制的所有内容，并将其储存在 Paste for Mac 的历史记录中。

![](https://cdn.zhangferry.com/Images/20210703184817.png)

***

整理编辑：[zhangferry](https://zhangferry.com)

### SnippetsLab

**地址**：http://www.renfei.org/snippets-lab/

**软件状态**：$9.99

**软件介绍**：

一款强大的代码片段管理工具，从此告别手动复制粘贴，SnippetsLab 的设计更符合 Apple 的交互习惯，支持导航栏快速操作。另外还可以同步 Github Gist 内容，使用 iCloud 备份。

![](https://cdn.zhangferry.com/Images/20210710232333.png)

### CodeExpander

**地址**：https://codeexpander.com/

**软件状态**：普通版免费，高级版付费

**软件介绍**：

专为开发者开发的一个集输入增强、代码片段管理工具，支持跨平台，支持云同步（Github/码云）。免费版包含 90% 左右功能，相对 SnippetsLab 来说其适用范围更广泛，甚至包括一些日常文本的片段处理。

![](https://cdn.zhangferry.com/Images/20210710231521.png)

***

整理编辑：[brave723](https://juejin.cn/user/307518984425981/posts)

**地址**： https://github.com/huanxsd/LinkMap

**软件状态**： 免费 

**软件介绍**

iOS 包的大小，是每个开发必须关注的问题，对于大型项目来说，只是代码段就有可能超过 100M，算上 armv7 和 arm64 架构，会超过 200M。 LinkMap 工具通过分析项目的 LinkMap 文件，能够计算出各个类、各个三方库占用的空间大小（代码段+数据段），方便开发者快速定位需要优化的文件。

![](https://cdn.zhangferry.com/Images/linkmap.png)

***

整理编辑：[CoderStar](https://juejin.cn/user/588993964541288/posts)

### Snipaste

**地址**： https://zh.snipaste.com/

**软件状态**： 普通版免费，专业版收费，有 Mac、Windows 两个版本

**软件介绍**：

Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！普通版的功能已经足够使用，笔者认为其是最好用的截图软件了！（下图是官方图）

![Snipaste](https://cdn.zhangferry.com/Images/N3QEb3VA.png)

### LSUnusedResources

**地址**： https://github.com/tinymind/LSUnusedResources

**软件状态**： 免费

**软件介绍**：

一个 Mac 应用程序，用于在 Xcode 项目中查找未使用的图像和资源，可以辅助我们优化包体积大小。

![LSUnusedResources](https://cdn.zhangferry.com/Images/LSUnusedResourcesExample.png)

***

整理编辑：[zhangferry](https://zhangferry.com)

### Messier

**地址**：https://messier-app.github.io/

**软件状态**：免费

**软件介绍**：

Messier 是基于 AppleTrace 开发的 Objective-C 方法耗时测量应用，其相对于 AppleTrace 更易用，且能更方便的在越狱设备上 Trace 任意应用。它由三部分组成：Tweak 插件，动态库（Messier.framework），桌面端应用。非越狱场景，我们使用后两个部分可完成对自己应用的耗时监控，输出为 json 文件，再使用 `chrome://tracing` 将 json 文件绘制为火焰图，效果如下：

![](https://cdn.zhangferry.com/Images/messier-content.gif)

***

整理编辑：[zhangferry](https://zhangferry.com)

### regex101

**地址**：https://regex101.com

一个正则表达式测试和分析网站，不仅可以将匹配结果进行输出，还会逐个分析表达式的含义。我们以摸鱼周报`关于我们`的文案进行测试，我们想匹配出 “iOS 摸鱼周报”（中间有空格），“iOS成长之路”，这两个字符串。文案特征为：”iOS“开头，不能紧跟其他字母，以逗号结尾但不包括逗号。测试结果如下：

![](https://cdn.zhangferry.com/Images/20210807164527.png)

观察右侧结果分析，示例中使用的 `*?` 非贪婪模式和 `(?=，)` 零宽度正预测先行断言，都有很详细的讲解。这对于我们理解他人写的正则表达式能起到很好的帮助作用。

***

整理编辑：[zhangferry](https://zhangferry.com)

### explainshell

**地址**：https://explainshell.com/

这个网站跟上期介绍的 [regex101](https://regex101.com) 很类似，一个用于解析正则表达式，一个用于解析 shell 指令。不常接触 shell 的小伙伴对于一个参数巨多，又巨长的指令可能会手足无措，没关系，这个网站来帮你😏。它会把主要命令和各个参数，传值进行详细的拆分讲解。比如这句列出所有包含 `1a1b1c` 这一 commit 的分支：

```bash
git branch -a -v --no-abbrev --contains 1a1b1c
```

解析结果：

![](https://cdn.zhangferry.com/Images/20210814184638.png)

***

整理编辑：[zhangferry](https://zhangferry.com)

### KeeWeb

**地址**：https://keeweb.info/

**软件状态**：免费，[开源](https://github.com/keeweb/keeweb)

**软件介绍**：

KeeWeb 是一个浏览器和桌面密码管理器，兼容 KeePass 数据库。它不需要任何服务器或额外的资源。该应用程序可以在浏览器中运行，也可以作为桌面应用程序运行。更重要的是它还可以利用 Dropbox、Google  Drive 进行远程同步。

![](https://cdn.zhangferry.com/Images/20210822081714.png)

***

整理编辑：[CoderStar](http://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18#wechat_redirect)

### OhMyStar

**地址**：https://ohmystarapp.com/

**软件状态**：普通版免费，Pro 版收费

**软件介绍**：

直接引用官方自己介绍的话吧：

> The best way to organise your GitHub Stars. Beautiful and efficient way to manage, explore and share your Github Stars.

其中 Pro 版增加的功能是设备间同步，不过软件本身也支持数据的导入导出，大家根据自己的情况进行选择。

![](https://cdn.zhangferry.com/Images/20210828101929.png)

***

整理编辑：[zhangferry](https://zhangferry.com)

### Wechatsync

**地址**：https://www.wechatsync.com/

**软件状态**：免费，[开源](https://github.com/wechatsync/Wechatsync)

**软件介绍**：

作为号主通常会将文章发布到多个平台，每个平台都重复地登录、复制、粘贴是一件很麻烦的事。Wechatsync就是这样一款解脱重复工作的神器。它是一款 Chrome 浏览器插件，支持多个平台的文章发布，这需要我们提前登录各个平台获得授权。它会自动识别公众号文章，弹出「同步该文章」按钮，然后点击就可以同步文章到我们授权的平台。

![](https://cdn.zhangferry.com/Images/20210904171532.png)

***

整理编辑：[brave723](https://juejin.cn/user/307518984425981/posts)

### XcodeProjects

**地址**： https://github.com/DKalachniuk/XcodeProjects

**软件状态**： 免费，开源

**软件介绍**

日常开发过程中，经常在终端中执行 pod install、pod update、或者 clear derived data 等操作，XcodeProjects 工具执行这些操作，只需要点击两下就能完成，还能为自己的项目自定义 command，很大程度的简化我们的操作步骤，节省开发时间。

![](https://cdn.zhangferry.com/Images/XcodeProjects.png)

***

整理编辑：[brave723](https://juejin.cn/user/307518984425981/posts)

### XcodesApp

**地址**： https://github.com/RobotsAndPencils/XcodesApp

**软件状态**： 免费，开源

**软件介绍**

AppStore 自带的升级功能经常因为某些奇怪的原因卡住而被吐槽，如果你也经历过这些事情可以试下 Xcodes。Xcodes 是一个 Xcode 下载管理器，支持下载不同版本的 Xcode，还可以切换默认版本。如果你喜欢命令行，还可以使用其[命令行版本](https://github.com/RobotsAndPencils/xcodes "xcodes")进行安装。

![](https://cdn.zhangferry.com/Images/xcodes.png)

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18) 、[zhangferry](zhangferry.com)

### SCADE

**地址**：https://www.scade.io/

**软件状态** 

- SCADE Community：免费
- SCADE Professional：$29 per month / user

**软件介绍**：

利用 `SCADE` 我们可以使用 Swift 语言进行跨端原生开发。其描述特点如下：

- 跨平台：使用相同的源代码为 iOS 和 Android 开发
- 原生功能：不受限制地使用所有 iOS 和 Android 功能
- 无与伦比的速度：Swift 被编译为本机二进制代码以获得无与伦比的应用程序性能
- Swift 框架：在 iOS 和 Android 上使用流行的 Swift 框架，如 Swift Foundation，无需更改代码
- ...

![SCADE](https://cdn.zhangferry.com/Images/SCD_Auora1-1-1-1240x791.png)

### Privacy-Insight

**地址**：https://github.com/Co2333/Privacy-Insight/releases

**软件状态** ：免费，开源

**软件介绍**：

解析 iOS 15 下格式为 `.ndjson` 的系统隐私报告，用 SwiftUI 写成。

隐私日志的生成为设置 -> 隐私 -> 打开记录 App 活动，等待一段时间之后点击下面的存储 App 活动按钮，即可收集这一段时间的隐私日志。存储会生成一个 `.ndjson` 格式的文件，导出使用 Privacy-Insight 打开即可查看。

以下为我使用 1 天的隐私请求记录：

![](https://cdn.zhangferry.com/Images/4301634041484_.pic_hd.jpg)

微信和今日头条的隐私权限获取频率均非常高，我是肯定没有那么频繁通过微信访问相册的。对于微信频繁获取相册权限的问题最近也在热议，希望不仅是微信，各个主流 App 都应该对于用户隐私问题予以重视。

作为使用者相对有效的保护隐私的方案是，关闭对应 App 的「后台刷新」，非必要情况下关闭蓝牙、定位等权限，并将相册调用权限改为「选中的照片」。

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18)

### wakapi

**地址**：https://wakapi.dev/

**软件状态**：免费，[开源](https://github.com/muety/wakapi)

**软件介绍**：

`Wakapi` 是一个开源工具，可帮助我们跟踪使用不同编程语言等在不同项目上编码所花费的时间，并使用图表等形式展现出来，支持 Xcode，值得一玩。

![wakapi](https://cdn.zhangferry.com/Images/screenshot.png)

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18)

### fig

**地址**：https://fig.io/

**软件状态**：免费，[开源](https://github.com/Coder-Star/autocomplete)

**软件介绍**：

`fig` 是一个开源的终端自动补全工具，支持数百个 CLI 工具，如 `git`、`docker`、`npm `等等，并且可以无缝添加到你现有的终端，如 `iTerm`、`Hyper`、`VSCode` 和 `macOS 终端`，支持我们自己自定义一些补全规则。

![fig](https://cdn.zhangferry.com/Images/Snipaste_2021-10-27_21-04-03.png)

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18)

### ipatool

**地址**：https://github.com/majd/ipatool

**软件状态**：免费，[开源](https://github.com/majd/ipatool)

**软件介绍**：

`ipatool` 是一个允许你在 `App Store` 上搜索 iOS 应用程序并下载应用程序包的命令行工具。当然，这过程中需要你的账户以及密码，并且也只能下载账户过去已经下载过的应用程序。相对于使用 `Apple Configurator 2` 操作更加便捷一些。

![ipatool](https://cdn.zhangferry.com/Images/demo.gif)

> 注意 gif 中的 `ipa` 命令实际使用中可能为 `ipatool`

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18)

### swiftenv

**地址**：https://github.com/kylef/swiftenv

**软件状态**：免费，[开源](https://github.com/kylef/swiftenv)

**软件介绍**：

`swiftenv` 允许您：

* 更改每个用户的全局 Swift 版本。
* 设置每个项目的 Swift 版本。
* 允许您使用环境变量覆盖 Swift 版本。

![swiftenv](https://cdn.zhangferry.com/Images/swiftenv.png)

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18)

### Mounty

**地址**：https://mounty.app/

**软件状态**：免费，[开源](https://mounty.app/)

**软件介绍**：

`Mounty` 是一个在 macOS 下以读写模式重新挂载写保护的 NTFS 卷的小工具，功能类似于 `NTFS For Mac`，最大也是最重要的区别是它是**免费**的。

![mounty](https://cdn.zhangferry.com/Images/example.png)

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18)

### PhotoSweeper

**地址**：https://overmacs.com/

**软件状态**：$9.99，可以试用

**软件介绍**：

`PhotoSweeper` 是一款快速而强大的重复照片清理器，旨在帮助您在 Mac 上查找和删除重复和相似的照片。

我们可以考虑用在给应用瘦身时扫描相似图片资源场景下。

![PhotoSweeper](https://cdn.zhangferry.com/Images/PhotoSweeper_MacBook.jpeg)

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18)

### 思源笔记

**地址**：https://github.com/siyuan-note/siyuan

**软件状态**：开源、免费

**软件介绍**：

思源笔记是一款本地优先的个人知识管理系统， 支持细粒度块级引用和 Markdown 所见即所得。

![siyuan-note](https://cdn.zhangferry.com/Images/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f73697975616e2d6e6f74652f73697975616e40383438393339373430316366353032356561623834376466623236613466333839366265353336332f73637265656e73686f74732f66656174757265302e706e67.png)

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18)

### myyearwithgit

**地址**：https://github.com/Co2333/myyearwithgit

**软件状态**：开源、免费

**软件介绍**：

看名字大家就知道这个是干啥的，还是配上老王的描述吧：

> 本程序目前支持使用常见 Git 仓库托管提供商以及本地代码仓库进行分析。

![myyearwithgit](https://cdn.zhangferry.com/Images/Screenshot.png)

### 往期推荐

[iOS摸鱼周报 第三十六期](https://mp.weixin.qq.com/s/K_JHs1EoEn222huWIoJRmA)

[iOS摸鱼周报 第三十五期](https://mp.weixin.qq.com/s/fCEbYkAPlK0nm7UtLKFx5A)

[iOS摸鱼周报 第三十四期](https://mp.weixin.qq.com/s/P0HjLDCIM3T-hAgQFjO1mg)

[iOS摸鱼周报 第三十三期](https://mp.weixin.qq.com/s/nznnGmBsqsrWcvZ4XFMttg)

![](https://cdn.zhangferry.com/Images/WechatIMG384.jpeg)

***

推荐来源：[iOSleep](https://github.com/iOSleep)

### Dropshelf

**地址**：https://pilotmoon.com/dropshelf/

**软件状态**：之前付费但是目前下架了，可以使用上面链接免费使用。

**软件介绍**：

Dropshelf 是一款 Mac OS 下的拖拽效率应用。它提供了一个可以吸附在屏幕边缘的 Dock，你可以拖拽任何东西「图片、文件、文字、链接...」暂存到 Dock 中，方便你在其他 App 中来使用。

![Dropshelf](https://cdn.zhangferry.com/Images/9964d0eee2c48e3d24ba63c09e25b10c_720w.jpeg)

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18)

### xcinfo

**推荐来源**：[faimin](https://github.com/faimin)

**地址**：https://github.com/xcodereleases/xcinfo

**软件状态**：开源、免费

**推荐语**：

`Xcodes` 的另一种选择，方便我们直接从苹果官网下载 Xcode。 据称下载速度比 `Xcodes` 更快。

![xcinfo](https://cdn.zhangferry.com/Images/inf.png)

### Mark Text

**地址**：https://marktext.app/

**软件状态**：开源、免费

**软件介绍**：

一个简单而优雅的开源 `markdown` 编辑器，专注于速度和可用性，适用于 `Linux`, `macOS` 和  `Windows`。

其和 `Typora` 一样，也是单窗的形式。

![Mark Text](https://cdn.zhangferry.com/Images/marktext.png)

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18)

### Tig

**地址**：https://jonas.github.io/tig/

**软件状态**：开源、免费

**软件介绍**：

`Tig` 是一个 `git` 资源库浏览器，采用 `ncurses` 开发，很适合习惯使用命令行进行 `git` 操作的小伙伴们。

![Tig](https://cdn.zhangferry.com/Images/Snipaste_20220106.png)

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18)

### SwiftInfo

**地址**：https://github.com/rockbruno/SwiftInfo

**软件状态**：开源、免费

**软件介绍**：

`SwiftInfo` 是一个 `CLI` 工具，用于提取、跟踪和分析对 `Swift` 应用程序有用的指标。除了该工具附带的默认跟踪选项外，还支持自定义编写 `.Swift` 脚本来实现额外的功能。

默认支持的工具包括：

- IPASizeProvider
- WarningCountProvider
- LinesOfCodeProvider
- ...

更多细节请直接前往 repo homepage 查看。

![SwiftInfo](https://cdn.zhangferry.com/Images/20220112183759.png)

***

整理编辑：[CoderStar](https://mp.weixin.qq.com/mp/homepage?__biz=MzU4NjQ5NDYxNg==&hid=1&sn=659c56a4ceebb37b1824979522adbb15&scene=18)

### 摸鱼单词

**地址**：https://apps.apple.com/cn/app/id1488909953?mt=12

**软件状态**：免费

**软件介绍**：

软件作者自述：电脑大部分使用场景是用来办公，如果在办公之余可以背背单词就很好啦，于是就有了摸鱼单词。专注于利用碎片时间学习记忆英语单词。

> 和《摸鱼周报》相得益彰，作者也是一直在维护这个软件。

![摸鱼单词](https://cdn.zhangferry.com/Images/Snipaste_2022-01-18_20-46-39%E7%9A%84%E5%89%AF%E6%9C%AC.png)

## 面试题汇总

整理编辑：[反向抽烟](opooc.com)、[师大小海腾](https://juejin.cn/user/782508012091645)

面试解析是新出的模块，我们会按照主题讲解一些高频面试题，本期主题是**计算机网络**，以下题目均来自真实面试场景。

### 输入网址进入网页按回车刷新网页都发生了什么？URL 输入到显示的过程？

1. **DNS 解析**：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址；
2. **TCP 连接**：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了；
3. **发送 HTTP 请求**：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的 TCP 连接中，按照 HTTP 协议标准发送一个索要网页的请求。在这一过程中，会涉及到负载均衡等操作；
4. **处理请求并返回**：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器；
5. **浏览器渲染**：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树。如果页面有 JavaScript 脚本文件，那么 JavaScript 文件下载完成并加载后，通过 DOM API 和 CSSOM API 来操作渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上；
6. **断开连接**：客户端和服务器通过四次挥手终止 TCP 连接。

### 拥塞控制有哪些阶段？如何实现拥塞控制？TCP 的拥塞控制解释一下？

1. 拥塞控制考虑整个网络，是全局性的考虑；
2. **慢启动算法**：由小到大逐渐增加发送数据量，每收到一个报文确认就加 1 倍的报文数量，以指数规律增长，增长到慢启动阈值后就不增了；
3. **拥塞避免算法**：维护一个拥塞窗口的变量，只要网络不拥塞，就试探着拥塞窗口调大，以加法规律增长，该算法可以保证在网络不拥塞的情况下，发送更多的数据；
4. **快速重传**：接收端收到的序列号不连续时，连发 3 个重复的确认报文给发送方；
5. **快速恢复**：拥塞窗口变为原来的一半，阈值也变为发生拥塞时大小的一半，继续拥塞避免算法。

### TCP 怎么保证可靠传输？TCP 怎样实现可靠传输的？TCP 为什么可以保证可靠传输？怎么理解 TCP 的连接，可靠和字节流？

1. **数据分块**：应用数据被分割成 TCP 认为最适合发送的数据块；
2. **序列号和确认应答**：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据；
3. **校验和**：TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段；
4. **流量控制**：TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制；
5. **拥塞控制**：当网络某个节点发生拥塞时，减少数据的发送；
6. **ARQ 协议**：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；
7. **超时重传**：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。

***

整理编辑：[反向抽烟](opooc.com)、[师大小海腾](https://juejin.cn/user/782508012091645)

面试解析是新出的模块，我们会按照主题讲解一些高频面试题，本期主题是**计算机网络**，以下题目均来自真实面试场景。计算机网络是面试必考的知识点，最好比较系统的去学习了解，推荐书籍：《图解 TCP/IP》、《网络是怎样连接的》；推荐付费课程：[计算机网络通关 29 讲](https://t7.lagounews.com/RR7FRYRDsi3B1 "计算机网络通关 29 讲")，大家可以根据自己喜欢的学习方式进行选择。

### 什么是 TCP 的三次握手和四次挥手？

我们先来看一下 TCP 报文头部结构：

![](https://cdn.zhangferry.com/Images/20210704165732.png)

握手阶段主要依靠以下几个标志位：

* SYN：在建立连接时使用，用来同步序号。SYN=1 代表这是一个请求建立连接或同意建立连接的报文，只有前两次握手中 SYN 才为 1，带 SYN 标志的 TCP 报文段称为同步报文段；
  * 当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段
  * 当 SYN=1，ACK=1 时，表示对方同意建立连接
* ACK：表示前面确认号字段是否有效。ACK=1 代表有效。带 ACK 标志的 TCP 报文段称为确认报文段；
* FIN：表示通知对方本端数据已发送完毕，要关闭连接了。带 FIN 标志的 TCP 报文段称为终止报文段。

**三次握手是指建立一个 TCP 连接时，需要客户端和服务端总共发送 3 个包，需要三次握手才能确认双方的接收与发送能力是否正常。**

![](https://cdn.zhangferry.com/Images/20210703051424.png)

1. 客户端向服务端发起连接请求，需要发送一个 SYN 报文到服务端。
2. 当服务端收到客户端发过来的 SYN 报文后，返回给客户端 SYN、ACK 报文。`这时候服务端可以确认客户端的发送能力和自己的接收能力正常`。
3. 客户端收到该报文。`这时候客户端可以确认双方的发送和接收能力都正常`。然后客户端再回复 ACK 报文给服务端，服务端收到该报文。`这时候服务端可以确认客户端的接收能力和自己的发送能力正常。所以这时候双方都可以确认自己和对方的接收与发送能力都正常`。就这样客户端和服务端通过 TCP 建立了连接。

**四次挥手的目的是关闭一个 TCP 连接。**

![](https://cdn.zhangferry.com/Images/20210703051443.png)

1. 客户端主动发起连接断开，发送一个 FIN 报文到服务端；
2. 服务端返回给客户端 ACK 报文。此时服务端处于关闭等待状态，而不是立马给客户端发 FIN 报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。`此时客户端到服务端的连接已经断开。但客户端和服务端之间所建立的 TCP 连接通道是全双工的，此时只是处于半关闭状态，所以服务端到客户端可能还会传递数据`；
3. 当服务端的数据都发送完毕后，给客户端发送一个 FIN，ACK 报文；
4. 客户端回应一个 ACK 报文。注意客户端发出 ACK 报文后不是立马释放 TCP 连接，而是要经过 2MSL（最长报文段寿命的 2 倍时长）后才释放 TCP 连接。而服务端一旦收到客户端发出的确认报文就会立马释放 TCP 连接，所以服务端结束 TCP 连接的时间要比客户端早一些。`此时服务端到客户端的连接也已经断开，整个 TCP 连接关闭`。

### 为什么 TCP 连接是三次握手？两次不可以吗？

TCP 是一个全双工协议，它要保证双方都具有接收与发送的能力。

因为需要考虑连接时丢包的问题，如果只握手两次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数据（可以理解为服务端已经连接成功），而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了（可以理解为客户端未连接成功），这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。

如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认报文丢失，服务端在一段时间内没有收到确认报文的话就会重新进行第二次握手，也就是服务端会重发 SYN 报文段，客户端收到重发的报文段后会再次给服务端发送确认报文。

### 为什么 TCP 连接是三次握手，关闭的时候却要四次挥手？

主要是建立连接时接收者的 SYN-ACK 一同发送了，而关闭时 FIN 和 ACK 却不能同时发送，因为断开连接要处理的情况比较多，比如服务器端可能还有发送出的消息没有得到 ACK，也可能服务器资源需要释放等。所以先发一个 ACK 表示已经收到了发送方的请求，等上述情况都有了确定的处理，再发 FIN 表示接收方已经完成了后续工作。

类比现实世界中，你收到了一个 Offer，出于礼貌你先回复一下，然后思考一段时间再回复 HR 最终的结果。

### 为什么客户端发出第四次挥手的确认报文后要等 2MSL 的时间才能释放 TCP 连接？

这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是 2MSL，所以需要等这么长时间来确认服务端确实已经收到了。

参考：[https://zhuanlan.zhihu.com/p/141396896](https://zhuanlan.zhihu.com/p/141396896 "https://zhuanlan.zhihu.com/p/141396896")

***

整理编辑：[反向抽烟](opooc.com)、[师大小海腾](https://juejin.cn/user/782508012091645)

面试解析会按照主题讲解一些高频面试题，本期面试题是 **block 的变量捕获机制**。

### block 的变量捕获机制

block 的变量捕获机制，是为了保证 block 内部能够正常访问外部的变量。

1、对于全局变量，不会捕获到 block 内部，访问方式为`直接访问`；作用域的原因，全局变量哪里都可以直接访问，所以不用捕获。

2、对于局部变量，外部不能直接访问，所以需要捕获。

* auto 类型的局部变量（我们定义出来的变量，默认都是 auto 类型，只是省略了），block 内部会自动生成一个同类型成员变量，用来存储这个变量的值，访问方式为`值传递`。**auto 类型的局部变量可能会销毁，其内存会消失，block 将来执行代码的时候不可能再去访问那块内存，所以捕获其值**。由于是值传递，我们修改 block 外部被捕获变量的值，不会影响到 block 内部捕获的变量值。

* static 类型的局部变量，block 内部会自动生成一个同类型成员变量，用来存储这个变量的地址，访问方式为`指针传递`。static 变量会一直保存在内存中， 所以捕获其地址即可。相反，由于是指针传递，我们修改 block 外部被捕获变量的值，会影响到 block 内部捕获的变量值。    

* 对于对象类型的局部变量，block 会连同它的所有权修饰符一起捕获。
  
  * 如果 block 是在栈上，将不会对对象产生强引用
  * 如果 block 被拷贝到堆上，将会调用 block 内部的 `copy(__funcName_block_copy_num)`函数，copy 函数内部又会调用 `assign(_Block_object_assign)`函数，assign 函数将会根据变量的所有权修饰符做出相应的操作，形成强引用（retain）或者弱引用。
  * 如果 block 从堆上移除，也就是被释放的时候，会调用 block 内部的 `dispose(_Block_object_dispose)`函数，dispose 函数会自动释放引用的变量（release）。

* 对于 `__block`（可用于解决 block 内部无法修改 auto 变量值的问题） 修饰的变量，编译器会将 `__block` 变量包装成一个 `__Block_byref_varName_num` 对象。它的内存管理几乎等同于访问对象类型的 auto 变量，但还是有差异。
  
  * 如果 block 是在栈上，将不会对 `__block` 变量产生强引用
  * 如果 block 被拷贝到堆上，将会调用 block 内部的 copy
    函数，copy 函数内部又会调用 assign 函数，assign 函数将会直接对 `__block` 变量形成强引用（retain）。
  * 如果 block 从堆上移除，也就是被释放的时候，会调用 block 内部的 dispose 函数，dispose 函数会自动释放引用的 `__block` 变量（release）。
    ![](https://user-gold-cdn.xitu.io/2020/2/23/170724cf4ff4b2bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 被 `__block `修饰的对象类型的内存管理：
  
  * 如果 `__block` 变量是在栈上，将不会对指向的对象产生强引用
  * 如果 `__block` 变量被拷贝到堆上，将会调用 `__block` 变量内部的 `copy(__Block_byref_id_object_copy)`函数，copy 函数内部会调用 assign 函数，assign 函数又会根据变量的所有权修饰符做出相应的操作，形成强引用（retain）或者弱引用。（注意：这里仅限于 ARC 下会 retain，MRC 下不会 retain，所以在 MRC 下还可以通过 `__block` 解决循环引用的问题）
  * 如果 `__block` 变量从堆上移除，会调用 `__block` 变量内部的 dispose 函数，dispose 函数会自动释放指向的对象（release）。

掌握了 block 的变量捕获机制，我们就能更好的应对内存管理，避免因使用不当造成内存泄漏。

常见的 block 循环引用为：`self(obj) -> block -> self(obj)`。这里 block 强引用了 self 是因为对于对象类型的局部变量，block 会连同它的所有权修饰符一起捕获，而对象的默认所有权修饰符为 __strong。

```objectivec
self.block = ^{
    NSLog(@"%@", self);
};
```

> 为什么这里说 self 是局部变量？因为 self 是 OC 方法的一个隐式参数。

为了避免循环引用，我们可以使用 `__weak` 解决，这里 block 将不再持有 self。

```objectivec
__weak typeof(self) weakSelf = self;
self.block = ^{
    NSLog(@"%@", weakSelf);
};
```

为了避免在 block 调用过程中 self 提前释放，我们可以使用 `__strong` 在 block 执行过程中持有 self，这就是所谓的 Weak-Strong-Dance。

```objectivec
__weak typeof(self) weakSelf = self;
self.block = ^{
    __strong typeof(self) strongSelf = weakSelf;
    NSLog(@"%@", strongSelf);
};
```

当然，我们平常用的比较多的还是 `@weakify(self)` 和 `@strongify(self)` 啦。

```objectivec
@weakify(self);
self.block = ^{
    @strongify(self);
    NSLog(@"%@", self);
};
```

如果你使用的是 RAC 的 Weak-Strong-Dance，你还可以这样：

```objectivec
@weakify(self, obj1, obj2);
self.block = ^{
    @strongify(self, obj1, obj2);
    NSLog(@"%@", self);
};
```

如果是嵌套的 block：

```objectivec
@weakify(self);
self.block = ^{
    @strongify(self);
    self.block2 = ^{
        @strongify(self);
        NSLog(@"%@", self);
    }
};
```

你是否会疑问，为什么内部不需要再写 @weakify(self) ？这个问题就留给你自己去思考和解决吧！

相比于简单的相互循环引用，block 造成的大环引用更需要你足够细心以及敏锐的洞察力，比如：

```objectivec
TYAlertView *alertView = [TYAlertView alertViewWithTitle:@"TYAlertView" message:@"This is a message, the alert view containt text and textfiled. "];
[alertView addAction:[TYAlertAction actionWithTitle:@"取消" style:TYAlertActionStyleCancle handler:^(TYAlertAction *action) {
    NSLog(@"%@-%@", self, alertView);
}]];
self.alertController = [TYAlertController alertControllerWithAlertView:alertView preferredStyle:TYAlertControllerStyleAlert];
[self presentViewController:alertController animated:YES completion:nil];
```

这里循环引用有两处：

1. `self -> alertController -> alertView -> handlerBlock -> self`
2. `alertView -> handlerBlock -> alertView`

避免循环引用：

```objectivec
TYAlertView *alertView = [TYAlertView alertViewWithTitle:@"TYAlertView" message:@"This is a message, the alert view containt text and textfiled. "];
@weakify(self, alertView);
[alertView addAction:[TYAlertAction actionWithTitle:@"取消" style:TYAlertActionStyleCancle handler:^(TYAlertAction *action) {
    @strongify(self, alertView);
    NSLog(@"%@-%@", self, alertView);
}]];
self.alertController = [TYAlertController alertControllerWithAlertView:alertView preferredStyle:TYAlertControllerStyleAlert];
[self presentViewController:alertController animated:YES completion:nil];
```

> 另外再和你提一个小知识点，当我们在 block 内部直接使用 _variable 时，编译器会给我们警告：`Block implicitly retains self; explicitly mention 'self' to indicate this is intended behavior`。
> 
> 原因是 block 中直接使用 `_variable` 会导致 block 隐式的强引用 self。Xcode 认为这可能会隐式的导致循环引用，从而给开发者带来困扰，而且如果不仔细看的话真的不太好排查，笔者之前就因为这个循环引用找了半天，还拉上了我导师一起查找原因。所以警告我们要显式的在 block 中使用 self，以达到 block 显式 retain 住 self 的目的。改用 `self->_variable` 或者 `self.variable`。
> 
> 你可能会觉得这种困扰没什么，如果你使用 `@weakify` 和 `@strongify` 那确实不会造成循环引用，因为 `@strongify` 声明的变量名就是 self。那如果你使用 `weak typeof(self) weak_self = self;` 和 `strong typeof(weak_self) strong_self = weak_self` 呢？

***

整理编辑：[反向抽烟](https://blog.csdn.net/opooc)、[师大小海腾](https://juejin.cn/user/782508012091645)

面试解析是新出的模块，我们会按照主题讲解一些高频面试题，本期主题是**属性及属性关键字**。

### 谈属性及属性关键字

#### @property、@synthesize 和 @dynamic

##### @property

属性用于封装对象中数据，属性的本质是 ivar + setter + getter。

可以用 @property 语法来声明属性。@property 会帮我们自动生成属性的 setter 和 getter 方法的声明。

##### @synthesize

帮我们自动生成 setter 和 getter 方法的实现以及 _ivar。

你还可以通过 @synthesize 来指定实例变量名字，如果你不喜欢默认的以下划线开头来命名实例变量的话。但最好还是用默认的，否则影响可读性。

如果不想令编译器合成存取方法，则可以自己实现。如果你只实现了其中一个存取方法 setter or getter，那么另一个还是会由编译器来合成。但是需要注意的是，如果你实现了属性所需的全部方法（如果属性是 readwrite 则需实现 setter and getter，如果是 readonly 则只需实现 getter 方法），那么编译器就不会自动进行 @synthesize，这时候就不会生成该属性的实例变量，需要根据实际情况自己手动 @synthesize 一下。

```objectivec
@synthesize ivar = _ivar;
```

##### @dynamic

告诉编译器不用自动进行 @synthesize，你会在运行时再提供这些方法的实现，无需产生警告，但是它不会影响 @property 生成的 setter 和 getter 方法的声明。@dynamic 是 OC 为动态运行时语言的体现。动态运行时语言与编译时语言的区别：动态运行时语言将函数决议推迟到运行时，编译时语言在编译器进行函数决议。

```objectivec
@dynamic ivar;
```

以前我们需要手动对每个 @property 添加 @synthesize，而在 iOS 6 之后 LLVM 编译器引入了 `property autosynthesis`，即属性自动合成。换句话说，就是编译器会自动为每个 @property 添加 @synthesize。

那你可能就会问了，@synthesize 现在有什么用呢？

1. 如果我们同时重写了 setter 和 getter 方法，则编译器就不会自动为这个 @property 添加 @synthesize，这时候就不存在 _ivar，所以我们需要手动添加 @synthesize。
2. 如果该属性是 readonly，那么只要你重写了 getter 方法，`property autosynthesis` 就不会执行，同样的你需要手动添加 @synthesize 如果你需要的话，看你这个属性是要定义为存储属性还是计算属性吧。
3. 实现协议中要求的属性。

此外需要注意的是，分类当中添加的属性，也不会 `property autosynthesis` 哦。因为类的内存布局在编译的时候会确定，但是分类是在运行时才加载并将数据合并到宿主类中的，所以分类当中不能添加成员变量，只能通过关联对象间接实现分类有成员变量的效果。如果你给分类添加了一个属性，但没有手动给它实现 getter、setter（如果属性是 readonly 则不需要实现）的话，编译器就会给你警告啦 `Property 'ivar' requires method 'ivar'、'setIvar:' to be defined - use @dynamic or provide a method implementation in this category`，编译器已经告诉我们了有两种解决方式来消除警告：

1. 在这个分类当中提供该属性 getter、setter 方法的实现
2. 使用 @dynamic 告诉编译器 getter、setter 方法的实现在运行时自然会有，您就不用操心了。当然在这里 @dynamic 只是消除了警告而已，如果你没有在运行时动态添加方法实现的话，那么调用该属性的存取方法还是会 Crash。

#### 属性修饰符分类

| 分类   | 属性关键字                                                                                                                                                                  |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 原子性  | `atomic`、`nonatomic`                                                                                                                                                   |
| 读写权限 | `readwrite`、`readonly`                                                                                                                                                 |
| 方法名  | `setter`、`getter`                                                                                                                                                      |
| 内存管理 | `assign`、`weak`、`unsafe_unretained`、`retain`、`strong`、`copy`                                                                                                           |
| 可空性  | (`nullable`、`_Nullable` 、`__nullable`)、<br>(`nonnull`、`_Nonnull`、`__nonnull`)、<br>(`null_unspecified`、`_Null_unspecified` 、`__null_unspecified`)、<br>`null_resettable` |
| 类属性  | `class`                                                                                                                                                                |

##### 原子性

| 属性关键字     | 用法                                                                                                                                                                                                                                             |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| atomic    | 原子性（默认），编译器会自动生成互斥锁（以前是自旋锁，后面改为了互斥锁），对 setter 和 getter 方法进行加锁，可以保证属性的赋值和取值的原子性操作是线程安全的，但不包括操作和访问。<br>比如说 atomic 修饰的是一个数组的话，那么我们对数组进行赋值和取值是可以保证线程安全的。但是如果我们对数组进行操作，比如说给数组添加对象或者移除对象，是不在 atomic 的负责范围之内的，所以给被 atomic 修饰的数组添加对象或者移除对象是没办法保证线程安全的。 |
| nonatomic | 非原子性，一般属性都用 nonatomic 进行修饰，因为 atomic 耗时。                                                                                                                                                                                                       |

##### 读写权限

| 属性关键字     | 用法                                                                                                                                                                        |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| readwrite | 可读可写（默认），同时生成 setter 方法和 getter 方法的声明和实现。                                                                                                                                 |
| readonly  | 只读，只生成 getter 方法的声明和实现。为了达到封装的目的，我们应该只在确有必要时才将属性对外暴露，并且尽量把对外暴露的属性设为 readonly。如果这时候想在对象内部通过 setter 修改属性，可以在类扩展中将属性重新声明为 readwrite；如果仅在对象内部通过 _ivar 修改，则不需要重新声明为 readwrite。 |

##### 方法名

| 属性关键字  | 用法                                                                                                                                                                                                                                                 |
| ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| setter | 可以指定生成的 setter 方法名，如 setter = setName。这个关键字笔者在给分类添加属性的时候会用得比较多，为了避免分类方法“覆盖”同名的宿主类（或者其它分类）方法的问题，一般我们都会加前缀，比如 bbIvar，但是这样生成的 setter 方法名就不美观了（为 setBbIvar），于是就使用到了 setter 关键字 `@property (nonatomic, strong, setter = bb_setIvar:) NSObject *bbIvar;` |
| getter | 可以指定生成的 getter 方法名，如 getter = getName。使用示例：`@property (nonatomic, assign, getter = isEnabled) BOOL enabled;`                                                                                                                                       |

##### 内存管理

| 属性关键字             | 用法                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| assign            | 1. 既可以修饰基本数据类型，也可以修饰对象类型；<br>2. setter 方法的实现是直接赋值，一般用于基本数据类型 ；<br>3. 修饰基本数据类型，如 NSInteger、BOOL、int、float 等；<br>4. 修饰对象类型时，不增加其引用计数；<br>5. 会产生悬垂指针（悬垂指针：assign 修饰的对象在被释放之后，指针仍然指向原对象地址，该指针变为悬垂指针。这时候如果继续通过该指针访问原对象的话，就可能导致程序崩溃）。                                                                                                                                                                                                                                         |
| weak              | 1. 只能修饰对象类型；<br>2. ARC 下才能使用；<br>3. 修饰弱引用，不增加对象引用计数，主要可以用于避免循环引用；<br>4. weak 修饰的对象在被释放之后，会自动将指针置为 nil，不会产生悬垂指针；<br>5. 对于视图，通常还是用在 xib 和 storyboard 上；代码中对于有必要进行 remove 的视图也可以使用 weak，这样 remove 之后会自动置为 nil。                                                                                                                                                                                                                                                             |
| unsafe_unretained | 1. 既可以修饰基本数据类型，也可以修饰对象类型；<br>2. MRC 下经常使用，ARC 下基本不用；<br>3. 同 weak，区别就在于 unsafe_unretained 会产生悬垂指针；<br>4. weak 对性能会有一定的消耗，当一个对象 dealloc 时，需要遍历对象的 weak 表，把表里的所有 weak 指针变量值置为 nil，指向对象的 weak 指针越多，性能消耗就越多。所以 unsafe_unretained 比 weak 快。当明确知道对象的生命周期时，选择 unsafe_unretained 会有一些性能提升。比如 A 持有 B 对象，当 A 销毁时 B 也销毁。这样当 B 存在，A 就一定会存在。而 B 又要调用 A 的接口时，B 就可以存储 A 的 unsafe_unretained 指针。虽然这种性能上的提升是很微小的。但当你很清楚这种情况下，unsafe_unretained 也是安全的，自然可以快一点就是一点。而当情况不确定的时候，应该优先选用 weak。 |
| retain            | 1. MRC 下使用，ARC 下基本使用 strong；<br>2. 修饰强引用，将指针原来指向的旧对象释放掉，然后指向新对象，同时将新对象的引用计数加 1；<br>3. setter 方法的实现是 release 旧值，retain 新值，用于 OC 对象类型。                                                                                                                                                                                                                                                                                                                                    |
| strong            | 1. ARC 下才能使用；<br>2. 原理同 retain；<br>3. 但是在修饰 block 时，strong 相当于 copy，而 retain 相当于 assign。                                                                                                                                                                                                                                                                                                                                                                                |
| copy              | setter 方法的实现是 release 旧值，copy 新值，一般用于 block、NSString、NSArray、NSDictionary 等类型。使用 copy 和 strong 修饰 block 其实都一样，用 copy 是为了和 MRC 下保持一致的写法；用于 NSString、NSArray、NSDictionary 是为了保证赋值后是一个不可变对象，以免遭外部修改而导致不可预期的结果。                                                                                                                                                                                                                                                             |

##### 类属性 class

属性可以分为实例属性和类属性：

* 实例属性：每个实例都有一套属于自己的属性值，它们之前是相互独立的；
* 类属性：可以为类本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份，因为类是单例。

说白了就是实例属性与 instance 关联，类属性与 class 关联。

用处：类属性用于定义某个类型所有实例共享的数据，比如所有实例都能用的一个常量/变量（就像 C 语言中的静态常量/静态变量）。

通过给属性添加 class 关键字来定义`类属性`。

```objectivec
@property (class, nonatimoc, strong) NSObject *object;
```

类属性是不会进行 `property autosynthesis` 的，那怎么关联值呢？

* 如果是存储属性
  1. 在 .m 中定义一个 static 全局变量，然后在 setter 和 getter 方法中对此变量进行操作。
  2. 在 setter 和 getter 方法中使用关联对象来存储值。笔者之前遇到的一个使用场景就是，类是通过 Runtime 动态创建的，这样就没办法使用 static 全局变量存储值。于是笔者在父类中定义了一个类属性并使用关联对象来存储值，这样动态创建的子类就可以给它的类属性关联值了。
* 如果是计算属性，就直接实现 setter 和 getter 方法就好。

#### 其它补充

在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义：

```objectivec
@property (nonatomic, copy) NSString *name;

— (instancetype)initWithName:(NSString *)name {
    if (self = [super init]) {
        _name = [name copy];
    }
       return self;
}
```

若是自己来实现存取方法，也应该保证其具备相关属性所声明的性质。

参考：[iOS - 再谈 OC 属性及属性关键字](https://juejin.cn/post/6986323251911720997/ "iOS - 再谈 OC 属性及属性关键字")

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645)

本期讲解**深浅拷贝的知识点**。文章将从深拷贝和浅拷贝的区别开始讲起，然后讲解在 iOS 中对 mutable 对象与 immutable 对象进行 copy 与 mutableCopy 的结果，以及如何对集合对象进行真正意义上的深拷贝，最后带你实现对自定义对象的深浅拷贝。

### 对深浅拷贝的理解

我们先要理解拷贝的目的：产生一个副本对象，跟源对象互不影响。

#### 深拷贝和浅拷贝

| 拷贝类型 | 拷贝方式                                      | 特点                                                                                           |
| ---- | ----------------------------------------- | -------------------------------------------------------------------------------------------- |
| 深拷贝  | 内存拷贝，让副本对象指针和源对象指针指向 `两片` 内容相同的内存空间。      | 1. 不会增加被拷贝对象的引用计数；<br>2. 产生了一个内存分配，出现了两块内存。                                                  |
| 浅拷贝  | 指针拷贝，对内存地址的复制，让副本对象指针和源对象指针指向 `同一片` 内存空间。 | 1. 会增加被拷贝对象的引用计数；<br>2. 没有进行新的内存分配。<br>注意：如果是小对象如 NSString，可能通过 `Tagged Pointer` 来存储，没有引用计数。 |

简而言之：

* 深拷贝：内存拷贝，产生新对象，不增加被拷贝对象引用计数
* 浅拷贝：指针拷贝，不产生新对象，增加被拷贝对象引用计数，相当于执行了 retain
* 区别：1. 是否影响了引用计数；2. 是否开辟了新的内存空间

![](https://cdn.zhangferry.com/Images/20210724043958.png)

#### 在 iOS 中对 mutable 对象与 immutable 对象进行 copy 与 mutableCopy 的结果

iOS 提供了 2 个拷贝方法：

* copy：不可变拷贝，产生不可变副本
* mutableCopy：可变拷贝，产生可变副本

对 mutable 对象与 immutable 对象进行 copy 与 mutableCopy 的结果：

| 源对象类型        | 拷贝方式        | 副本对象类型 | 拷贝类型（深/浅） |
|:------------:|:-----------:|:------:|:---------:|
| mutable 对象   | copy        | 不可变    | 深拷贝       |
| mutable 对象   | mutableCopy | 可变     | 深拷贝       |
| immutable 对象 | copy        | 不可变    | `浅拷贝`     |
| immutable 对象 | mutableCopy | 可变     | 深拷贝       |

> 注：这里的 immutable 对象与 mutable 对象指的是系统类 NSArray、NSDictionary、NSSet、NSString、NSData 与它们的可变版本如 NSMutableArray 等。

一个记忆技巧就是：对 immutable 对象进行 copy 操作是 `浅拷贝`，其它情况都是 `深拷贝`。

我们还可以根据拷贝的目的加深理解：

* 对 immutable 对象进行 copy 操作，产生 immutable 对象，因为源对象和副本对象都不可变，所以进行指针拷贝即可，节省内存
* 对 immutable 对象进行 mutableCopy 操作，产生 mutable 对象，对象类型不同，所以需要深拷贝
* 对 mutable 对象进行 copy 操作，产生 immutable 对象，对象类型不同，所以需要深拷贝
* 对 mutable 对象进行 mutableCopy 操作，产生 mutable 对象，为达到修改源对象或副本对象互不影响的目的，需要深拷贝

#### 使用 copy、mutableCopy 对集合对象进行的深浅拷贝是针对集合对象本身的

使用 copy、mutableCopy 对集合对象（Array、Dictionary、Set）进行的深浅拷贝是针对集合对象本身的，对集合中的对象执行的默认都是浅拷贝。也就是说只拷贝集合对象本身，而不复制其中的数据。主要原因是，集合内的对象未必都能拷贝，而且调用者也未必想在拷贝集合时一并拷贝其中的每个对象。

如果想要深拷贝集合对象本身的同时，也对集合内容进行 copy 操作，可使用类似以下的方法，copyItems 传 YES。但需要注意的是集合中的对象必须都符合 NSCopying 协议，否则会导致 Crash。

```objectivec
NSArray *deepCopyArray = [[NSArray alloc]initWithArray:someArray copyItems:YES];
```

> 注：`initWithArray:copyItems:` 方法不是所有情况下都深拷贝集合对象本身的。如果执行 `[[NSArray alloc]initWithArray:@[] copyItems:aBoolValue];`，也就是源对象为不可变的空数组的话，对源对象本身执行的是浅拷贝，苹果对 `@[]` 使用了享元。

但是，如果集合中的对象的 copy 操作是浅拷贝，那么对于集合来说还不是真正意义上的深拷贝。比如，你需要对一个 `NSArray<NSArray *>` 对象进行真正的深拷贝，那么内层数组及其内容也应该执行深拷贝，可以对该集合对象进行 `归档` 然后 `解档`，只要集合中的对象都符合 NSCoding 协议。而且，使用这种方式，无论集合中存储的模型对象嵌套多少层，都可以实现深拷贝，但前提是嵌套的子模型也需要符合 NSCoding 协议才行，否则会导致 Crash。

```objectivec
NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];
```

![](https://cdn.zhangferry.com/Images/20210724054744.png)

> 需要注意的是，使用 `initWithArray:copyItems:` 并将 copyItems 传 YES 时，生成的副本集合对象中的对象（下一个级别）是不可变的，所有更深的级别都具有它们以前的可变性。比如以下代码将 Crash。
> 
> ```objectivec
> NSArray *oldArray = @[@[].mutableCopy];
> NSArray *deepCopyArray = [[NSArray alloc] initWithArray:oldArray copyItems:YES];
> NSMutableArray *mArray = deepCopyArray[0]; // deepCopyArray[0] 已经被深拷贝为 NSArray 对象
> [mArray addObject:@""]; // Crash
> ```
> 
> 而 `归档解档集合` 的方式会保留所有级别的可变性，就像以前一样。

#### 实现对自定义对象的拷贝

如果想要实现对自定义对象的拷贝，需要遵守 `NSCopying` 协议，并实现 `copyWithZone:` 方法。

* 如果要浅拷贝，`copyWithZone:` 方法就返回当前对象：return self；
* 如果要深拷贝，`copyWithZone:` 方法中就创建新对象，并给希望拷贝的属性赋值，然后将其返回。如果有嵌套的子模型也需要深拷贝，那么子模型也需符合 NSCopying 协议，且在属性赋值时调用子模型的 copy 方法，以此类推。

如果自定义对象支持可变拷贝和不可变拷贝，那么还需要遵守 `NSMutableCopying` 协议，并实现 `mutableCopyWithZone:` 方法，返回可变副本。而 `copyWithZone:` 方法返回不可变副本。使用方可根据需要调用该对象的 copy 或 mutableCopy 方法来进行不可变拷贝或可变拷贝。

#### 以下代码会出现什么问题？

```objectivec
@interface Model : NSObject
@property (nonatomic, copy) NSMutableArray *array;
@end
```

不论赋值过来的是 NSMutableArray 还是 NSArray 对象，进行 copy 操作后都是 NSArray 对象（深拷贝）。由于属性被声明为 NSMutableArray 类型，就不可避免的会有调用方去调用它的添加对象、移除对象等一些方法，此时由于 copy 的结果是 NSArray 对象，所以就会导致 Crash。

参考：[iOS 面试解析 - 对深浅拷贝的理解](https://juejin.cn/post/6988858119182876680 "iOS 面试解析 - 对深浅拷贝的理解")

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645)

本期讲解 load 和 initialize 的相关知识点。

### load 和 initialize 的区别

| 区别   | load                                                                                                                                 | initialize                                                                                                                 |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------- |
| 调用时刻 | 在 `Runtime` 加载类、分类时调用<br>（不管有没有用到这些类，在程序运行起来的时候都会加载进内存，并调用 `load` 方法）。<br><br>每个类、分类的 `load`，在程序运行过程中只调用一次（除非开发者手动调用）。               | 在`类`第一次接收到消息时调用。<br><br>如果子类没有实现 `initialize` 方法，会调用父类的 `initialize`，所以父类的 `initialize` 方法可能会被调用多次，但不代表父类初始化多次，每个类只会初始化一次。 |
| 调用方式 | ① 系统自动调用 `load` 方式为直接通过函数地址调用；<br>② 开发者手动调用 `load` 方式为消息机制 `objc_msgSend` 函数调用。                                                      | 消息机制 `objc_msgSend` 函数调用。                                                                                                  |
| 调用顺序 | ① 先调用类的 `load`，按照编译先后顺序调用（先编译，先调用），调用子类的 `load` 之前会先调用父类的 `load`；<br>② 再调用分类的 `load`，按照编译先后顺序调用（先编译，先调用）（注意：通过消息机制调用分类方法是：后编译，优先调用）。 | ① 先调用父类的 `initialize`<br>② 再调用子类的 `initialize`<br>（先初始化父类，再初始化子类）。                                                         |

### 手动调用子类的 load 方法，但是子类没有实现该方法，会怎样？

* `load` 方法可以继承，手动调用 `load` 的方式是通过消息机制调用，先查找子类是否实现了 `load` 方法，由于子类没有实现，就会去查找父类，如果父类实现了 `load` 方法则调用，否则继续逐级查找；
* 如果父类的分类实现了 `load` 方法，那么会调用分类的，因为分类方法会“覆盖”同名宿主类方法；
* 如果存在多个父类的分类都实现了 `load` 方法的话，那么会调用最后参与编译的分类的 `load` 方法。

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645)

本期讲解 **block 类型** 的相关知识点。你是否遇到过这样的面试题：

* block 都有什么类型？
* 栈 block 存在什么问题？
* block 每种类型调用 copy 的结果分别是怎样的？

希望以下的总结能帮助到你。如果你对内容有任何疑问，或者有更好的解答，都可以联系我们。

### block 类型

block 有 3 种类型：栈块、堆块、全局块，最终都是继承自 NSBlock 类型。

| block 类型                                          | 描述                        | 环境                          |
|:-------------------------------------------------:|:-------------------------:|:---------------------------:|
| `__NSGlobalBlock__`<br>（ _NSConcreteGlobalBlock ） | 全局 block，保存在数据段区（.data 区） | 定义在全局区，或者没有访问自动局部变量         |
| `__NSStackBlock__`<br>（ _NSConcreteStackBlock ）   | 栈 block，保存在栈区             | 访问了自动局部变量                   |
| `__NSMallocBlock__`<br>（ _NSConcreteMallocBlock ） | 堆 block，保存在堆区             | `__NSStackBlock__` 调用了 copy |

**1. 栈块**

定义块的时候，其所占的内存区域是分配在栈中的。块只在定义它的那个范围内有效。

```objectivec
void (^block)(void);
if ( /* some condition */ ) {
    block = ^{
        NSLog(@"Block A");
    };
} else {
    block = ^{
        NSLog(@"Block B");
    };
}
block();
```

上面的代码有危险，定义在 if 及 else 中的两个块都分配在栈内存中，当出了 if 及 else 的范围，栈块可能就会被销毁。如果编译器覆写了该块的内存，那么调用该块就会导致程序崩溃。或者数据可能会变成垃圾数据，尽管将来该块还能正常调用，但是它捕获的变量的值已经错乱了。

> 若是在 ARC 下，上面 block 会被自动 copy 到堆，所以不会有问题。但在 MRC 下我们要避免这样写。

**2. 堆块**

为了解决以上问题，可以给块对象发送 copy 消息将其从栈拷贝到堆区，堆块可以在定义它的那个范围之外使用。堆块是带引用计数的对象，所以在 MRC 下如果不再使用堆块需要调用 release 进行释放。

```objectivec
void (^block)(void);
if ( /* some condition */ ) {
    block = [^{
        NSLog(@"Block A");
    } copy];
} else {
    block = [^{
        NSLog(@"Block B");
    } copy];
}
block();
[block release];
```

**3. 全局块**

如果运行块所需的全部信息都能在编译期确定，包括没有访问自动局部变量等，那么该块就是全局块。全局块可以声明在全局内存中，而不需要在每次用到的时候于栈中创建。
全局块的 copy 操作是空操作，因为全局块决不可能被系统所回收，其实际上相当于单例。

```objectivec
void (^block)(void) = ^{
    NSLog(@"This is a block");
};
```

**每一种类型的 block 调用 copy 后的结果如下所示：**

| block 类型               | 副本源的配置存储区        | 复制效果   |
|:---------------------- |:---------------- |:------ |
| _NSConcreteGlobalBlock | 程序的数据段区（.data 区） | 什么也不做  |
| _NSConcreteStackBlock  | 栈                | 从栈复制到堆 |
| _NSConcreteMallocBlock | 堆                | 引用计数增加 |

参考：[iOS 面试解析｜block 的类型](https://juejin.cn/post/6994082409687810079 "iOS 面试解析｜block 的类型")

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645)

本期通过一个 demo 讲解 `isMemberOfClass:`、`isKindOfClass:` 两个方法的相关知识点。

**以下打印结果是什么？**（严谨点就添加个说明吧：Person 类继承于 NSObject 类）

```objectivec
BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];
BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]];
BOOL res3 = [[Person class] isKindOfClass:[Person class]];
BOOL res4 = [[Person class] isMemberOfClass:[Person class]];

NSLog(@"%d, %d, %d, %d", res1, res2, res3, res4);
```

打印结果：1, 0, 0, 0

**解释：**

以下是 objc4-723 中 `isMemberOfClass:`、`isKindOfClass:` 方法以及 `object_getClass()` 函数的实现。

```objectivec
+ (BOOL)isMemberOfClass:(Class)cls {
    return object_getClass((id)self) == cls;
}

- (BOOL)isMemberOfClass:(Class)cls {
    return [self class] == cls;
}

+ (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls->superclass) {
        if (tcls == cls) return YES;
    }
    return NO;
}

- (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {
        if (tcls == cls) return YES;
    }
    return NO;
}

Class object_getClass(id obj)
{
    if (obj) return obj->getIsa();
    else return Nil;
}
```

emmm 整理的时候发现后面的版本又做了小优化，具体就不展开了，不过原理不变，以下是 824 版本的：

```objectivec
+ (BOOL)isMemberOfClass:(Class)cls {
    return self->ISA() == cls;
}

- (BOOL)isMemberOfClass:(Class)cls {
    return [self class] == cls;
}

+ (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = self->ISA(); tcls; tcls = tcls->getSuperclass()) {
        if (tcls == cls) return YES;
    }
    return NO;
}

- (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = [self class]; tcls; tcls = tcls->getSuperclass()) {
        if (tcls == cls) return YES;
    }
    return NO;
}
```

由此我们可以得出结论：

* `isMemberOfClass:` 方法是判断当前 `instance/class` 对象的 `isa` 指向是不是 `class/meta-class` 对象类型；
* `isKindOfClass:` 方法是判断当前 `instance/class` 对象的 `isa` 指向是不是 `class/meta-class` 对象或者它的子类类型。

显然 `isKindOfClass:` 的范围更大。如果方法调用者是 instance 对象，传参就应该是 class 对象。如果方法调用着是 class 对象，传参就应该是 meta-class 对象。所以 res2-res4 都为 0。那为什么 res1 为 1 呢？

因为 NSObject 的 class 的对象的 isa 指向它的 meta-class 对象，而它的 meta-class 的 superclass 指向它的 class 对象，所以 `[[NSObject class] isKindOfClass:[NSObject class]]` 成立 。

![](https://cdn.zhangferry.com/Images/objc-isa-class-diagram.jpg)

总之，`[instance/class isKindOfClass:[NSObject class]]` 恒成立。（严谨点，需要是 NSObject 及其子类类型）

***

整理编辑：[FBY展菲](https://github.com/fanbaoying)

本期面试解析讲解的是离屏渲染的相关知识点。

### 为什么圆角和裁剪后 iOS 绘制会触发离屏渲染？

默认情况下每个视图都是完全独立绘制渲染的。
而当某个父视图设置了圆角和裁剪并且又有子视图时，父视图只会对自身进行裁剪绘制和渲染。

当子视图绘制时就要考虑被父视图裁剪部分的绘制渲染处理，因此需要反复递归回溯和拷贝父视图的渲染上下文和裁剪信息，再和子视图做合并处理，以便完成最终的裁剪效果。这样势必产生大量的时间和内存的开销。

解决的方法是当父视图被裁剪和有圆角并且有子视图时，就单独的开辟一块绘制上下文，把自身和所有子视图的内容都统一绘制在这个上下文中，这样子视图也不需要再单独绘制了，所有裁剪都会统一处理。当父视图绘制完成时再将开辟的缓冲上下文拷贝到屏幕上下文中去。这个过程就是离屏渲染！！

所以离屏渲染其实和我们先将内容绘制在位图内存上下文然后再统一拷贝到屏幕上下文中的双缓存技术是非常相似的。使用离屏渲染主要因为 iOS 内部的视图独立绘制技术所导致的一些缺陷而不得不才用的技术。

推荐阅读：[关于iOS离屏渲染的深入研究](https://zhuanlan.zhihu.com/p/72653360 "关于iOS离屏渲染的深入研究")

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645/posts)

本期解析一道 GCD 死锁题。

分别在 mainThread 执行 test1 和 test2 函数，问执行情况如何？

```swift
  func test1() {
      DispatchQueue.main.sync { // task1
          print("1") 
      }
  }

  func test2() {
      print("1")
      let queue = DispatchQueue.init(label: "thread")
      queue.async { // task1
          print("2")
          DispatchQueue.main.sync { // task3
              print("3")
              queue.sync { // task4
                  print("4")
              }
          }
          print("5")
      }
      print("6")
      queue.async { // task2
          print("7")
      }
      print("8")
  }
```

1. 死锁。
   1. mainThread 当前正在执行 test1 函数。
   2. 这时候使用 sync 函数往 mainQueue 中提交 task1 以同步执行，需要 task1 执行完毕后才会返回。
   3. 由于队列 FIFO，要想从 mainQueue 取出 task1 放到 mainThread 执行，需要先等待上一个 task 也就是 test1 函数先执行完，而 test1 此时又被 sync 阻塞，需要 sync 函数先返回。因此 test1 与 task1 循环等待，产生死锁。
2. 打印 1、6、8、2、3，然后死锁。
   1. 创建一个 serialQueue。使用 async 函数往指定队列提交 task 以异步执行会直接返回，不会阻塞，因此打印 1、6、8，并且 mainThread 执行完 test2。
   2. 从 serialQueue 中取出 task1 放到一条 childThread 执行，因为是 serialQueue 所以 task2 需要等待 task1 执行完毕才会执行。 执行 task1，打印 2；
   3. 使用 sync 函数往 mainQueue 提交 task3。**此时 task1 被阻塞，需要等待 task3 执行完毕**，才会接下去打印 5；
   4. mainThread 当前没有在执行 task，因此执行 task3，打印 3；
   5. 接着，使用 sync 往 serialQueue 中提交 task4，**此时 task3 被阻塞，需要等待 task4 执行完毕**；
   6. 此时该 childThread 正在执行 task1，**因此 task4 需要等待 task1 先执行完毕**。
   7. 此时，task1 在等待 task3，task3 在等待 task4，task4 在等待 task1。循环等待，产生死锁。

使用 GCD 的时候，我们一定要注意死锁问题，不要使用 `sync 函数` 往 `当前 serialQueue` 中添加 task，否则会卡住当前 serialQueue，产生死锁。

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645/posts)

本期解析 KVO 的实现原理。

Apple 使用了 isa-swizzling 方案来实现 KVO。

**注册：**

当我们调用 `addObserver:forKeyPath:options:context:` 方法，为 **被观察对象** a 添加 KVO 监听时，系统会在运行时动态创建 a 对象所属类 A 的子类 `NSKVONotifying_A`，（如果是在Swift工程中，因为命名空间的存在，生成的类名会是`NSKVONotifying_ModuleName.A`） 并且让 a 对象的 isa 指向这个子类，同时重写父类 A 的 **被观察属性** 的 setter 方法来达到可以通知所有 **观察者对象** 的目的。

这个子类的 isa 指针指向它自己的 meta-class 对象，而不是原类的 meta-class 对象。

重写的 setter 方法的 SEL 对应的 IMP 为 Foundation 中的 `_NSSetXXXValueAndNotify` 函数（XXX 为 Key 的数据类型）。因此，当 **被观察对象** 的属性发生改变时，会调用 _NSSetXXXValueAndNotify 函数，这个函数中会调用：

* `willChangeValueForKey:` 方法
* 父类 A 的 setter 方法
* `didChangeValueForKey:` 方法

**监听：**

而 willChangeValueForKey: 和 didChangeValueForKey: 方法内部会触发 **观察者对象** 的监听方法：`observeValueForKeyPath:ofObject:change:context:`，以此完成 KVO 的监听。

willChangeValueForKey: 和 didChangeValueForKey: 触发监听方法的时机：

* didChangeValueForKey: 方法会直接触发监听方法
* `NSKeyValueObservingOptionPrior` 是分别在值改变前后触发监听方法，即一次修改有两次触发。而这两次触发分别在 willChangeValueForKey: 和 didChangeValueForKey: 的时候进行的。如果注册方法中 options 传入 NSKeyValueObservingOptionPrior，那么可以通过只调用 willChangeValueForKey: 来触发改变前的那次 KVO，可以用于在属性值即将更改前做一些操作。

**移除：**

在移除 KVO 监听后，被观察对象的 isa 会指回原类 A，但是 NSKVONotifying_A 类并没有销毁，还保存在内存中，不销毁的原因想必大家也很容易理解，其实就是一层缓存，避免动态类的频繁创建/销毁。

**重写方法：**

NSKVONotifying_A 除了重写 setter 方法外，还重写了 class、dealloc、_isKVOA 这三个方法（可以通过 class_copyMethodList 获得），其中：

* class：返回父类的 class 对象，目的是为了不让外界知道 KVO 动态生成类的存在，隐藏 KVO 实现（通过此处我们可以知道获取对象所属类的方式最好是使用class方法，而不是isa指针）；
* dealloc：释放 KVO 使用过程中产生的东西；
* _isKVOA：用来标志它是一个 KVO 的类。

参考：[iOS - 关于 KVO 的一些总结](https://juejin.cn/post/6844903972528979976 "iOS - 关于 KVO 的一些总结")

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645/posts)

本期面试解析讲解的知识点是 **KVC 取值和赋值过程的工作原理**。

**Getter**

以下是 `valueForKey:` 方法的默认实现，给定一个 `key` 作为输入参数，在消息接收者类中操作，执行以下过程。

* ① 按照 `get<Key>`、`<key>`、`is<Key>`、`_<key>` 顺序查找方法。
  <br>如果找到就调用取值并执行 ⑤，否则执行 ②；
* ② 查找 `countOf<Key>`、`objectIn<Key>AtIndex:`、`<key>AtIndexes:` 命名的方法。
  <br>如果找到第一个和后面两个中的至少一个，则创建一个能够响应所有 `NSArray` 的方法的集合代理对象（类型为 `NSKeyValueArray`，继承自 `NSArray`），并返回该对象。否则执行 ③；
  * 代理对象随后将其接收到的任何 `NSArray` 消息转换为 `countOf<Key>`、`objectIn<Key>AtIndex:`、`<Key>AtIndexes:` 消息的组合，并将其发送给 `KVC` 调用方。如果原始对象还实现了一个名为 `get<Key>:range:` 的可选方法，则代理对象也会在适当时使用该方法。
* ③ 查找 `countOf<Key>`、`enumeratorOf<Key>`、`memberOf<Key>:` 命名的方法。
  <br>如果三个方法都找到，则创建一个能够响应所有 `NSSet` 的方法的集合代理对象（类型为 `NSKeyValueSet`，继承自 `NSSet`），并返回该对象。否则执行④；
  * 代理对象随后将其接收到的任何 `NSSet` 消息转换为 `countOf<Key>`、`enumeratorOf<Key>`、`memberOf<Key>:` 消息的组合，并将其发送给 `KVC` 调用方。
* ④ 查看消息接收者类的 `+accessInstanceVariablesDirectly` 方法的返回值（默认返回 `YES`）。如果返回 `YES`，就按照 `_<key>`、`_is<Key>`、`<key>`、`is<Key>` 顺序查找成员变量。如果找到就直接取值并执行 ⑤，否则执行 ⑥。如果 `+accessInstanceVariablesDirectly` 方法返回 `NO` 也执行 ⑥。
* ⑤ 如果取到的值是一个对象指针，即获取的是对象，则直接将对象返回。
  * 如果取到的值是一个 `NSNumber` 支持的数据类型，则将其存储在 `NSNumber` 实例并返回。
  * 如果取到的值不是一个 `NSNumber` 支持的数据类型，则转换为 `NSValue` 对象, 然后返回。
* ⑥ 调用 `valueForUndefinedKey:` 方法，该方法抛出异常 `NSUnknownKeyException`，程序 `Crash`。这是默认实现，我们可以重写该方法对特定 `key` 做一些特殊处理。

**Setter**

以下是 `setValue:forKey:` 方法的默认实现，给定 `key` 和 `value` 作为输入参数，尝试将 `KVC` 调用方 `key` 的值设置为 `value`，执行以下过程。

* ① 按照 `set<Key>:`、`_set<Key>:` 顺序查找方法。
  <br>如果找到就调用并将 `value` 传进去（根据需要进行数据类型转换），否则执行 ②。
* ② 查看消息接收者类的 `+accessInstanceVariablesDirectly` 方法的返回值（默认返回 `YES`）。如果返回 `YES`，就按照 `_<key>`、`_is<Key>`、`<key>`、`is<Key>` 顺序查找成员变量（同 Getter）。如果找到就将 `value` 赋值给它（根据需要进行数据类型转换），否则执行 ③。如果 `+accessInstanceVariablesDirectly` 方法返回 `NO` 也执行 ③。
* ③ 调用 `setValue:forUndefinedKey:` 方法，该方法抛出异常 `NSUnknownKeyException`，程序 `Crash`。这是默认实现，我们可以重写该方法对特定 `key` 做一些特殊处理。

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645/posts)

本期面试解析讲解的知识点是 Objective-C 的消息机制（上）。为了避免篇幅过长这里不会展开太细，而且太细的笔者我也不会😅，网上相关的优秀文章数不胜数，如果大家看完还有疑惑🤔一定要去探个究竟🐛。

**消息机制派发**

“消息机制派发” 是 Objective-C 的消息派发方式，其 “动态绑定” 机制让所要调用的方法在运行时才确定，支持开发者使用 “method-swizzling”、“isa-swizzling” 等黑魔法来在运行时改变调用方法的行为。除此之外，还有 “直接派发”、“函数表派发” 等消息派发方式，这些方式在 Swift 中均有应用。

“消息” 这个词好像不常说，更多的是称之为 “方法”。其实，给某个对象 “发送消息” 就相当于在该对象上“ 调用方法”。完整的消息派发由 `接收者`、`选择子` 及 `参数` 构成。在 Objective-C 中，给对象发送消息的语法为：

```objectivec
id returnValue = [someObject message:parameter];
```

在这里，someObject 叫做 `接收者`，message 叫做 `选择子`，`选择子` 与 `参数` 合起来称为 `消息`。编译器看到此消息后，会将其转换为一条标准的 C 语言函数调用，所调用的函数为消息机制的核心函数 `objc_msgSend`：

```objectivec
void objc_msgSend(id self, SEL _cmd, ...)
```

该函数参数个数可变，能接受两个或两个以上参数。前面两个参数 `self 消息接收者` 和 `_cmd 选择子` 即为 Objective-C 方法的两个隐式参数，后续参数就是消息中的那些参数（也就是方法显式参数）。

Objective-C 中的方法调用在编译后会转换成该函数调用，比如以上方法调用会转换为：

```objectivec
id returnValue = objc_msgSend(someObject, @selector(message:), parameter);
```

> 除了 objc_msgSend，还有其它函数负责处理边界情况：
> 
> * objc_msgSend_stret：待发送的消息返回的是结构体
> * objc_msgSend_fpret：待发送的消息返回的是浮点数
> * objc_msgSendSuper：给父类发消息
> * ......

在讲了一大段废话之后（废话居然占了这么大篇幅 wtm），该步入重点了，objc_msgSend 函数的执行流程是什么样的？

objc_msgSend 执行流程通常分为三大阶段：`消息发送`、`动态方法解析`、`消息转发`。而有些地方又将 `动态方法解析` 阶段归并到 `消息转发` 阶段中，从而将其分为了 `消息发送` 和 `消息转发` 两大阶段，比如《Effective Objective-C 2.0》。好吧，其实我也不知道哪种是通常😅。

**消息发送**

* 判断 receiver 是否为 nil，是的话直接 return，这就是为什么给 nil 发送消息却不会 Crash 的原因。
* 去 receiverClass 以及逐级遍历的 superclass 中的 cache_t 和 class_rw_t 中查找 IMP，找到就调用。如果遍历到 rootClass 还没有找到的话，则进入 `动态方法解析` 阶段。
* 该阶段还涉及到 `initialize 消息的发送`、`cache_t 缓存添加、扩容 ` 等流程。

**动态方法解析**

**消息转发**

由于篇幅原因，剩下的内容我们下期再见吧👋。

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645/posts)

本期面试解析讲解的知识点是 Objective-C 的消息机制（下）。在上一期摸鱼周报中我们讲解了 objc_msgSend 执行流程的第一大阶段 `消息发送`，那么这一期我们就来聊聊后两大阶段 `动态方法解析` 与 `消息转发`。

**动态方法解析**

如果 `消息发送` 阶段未能处理未知消息，那么就会进行一次 `动态方法解析`。我们可以在该阶段通过动态添加方法实现，来处理未知消息。`动态方法解析` 后，会再次进入 `消息发送` 阶段，从 “去 receiverClass 的 method cache 中查找 IMP” 这一步开始执行。

具体来说，在该阶段，Runtime 会根据 receiverClass 的类型是 class/meta-class 来调用以下方法：

```objectivec
+ (BOOL)resolveInstanceMethod:(SEL)sel;
+ (BOOL)resolveClassMethod:(SEL)sel;
```

我们可以重写以上方法，并通过 `class_addMethod` 函数来动态添加方法实现。需要注意的一点是，实例方法存储在类对象中，类方法存储在元类对象中，因此这里要注意传参。

```c
BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
```

如果我们在该阶段正确地处理了未知消息，那么再次进入到 `消息发送` 阶段肯定能找到 IMP 并调用，否则将进入 `消息转发` 阶段。

**消息转发**

`消息转发` 又分为 Fast 和 Normal 两个阶段，顾名思义 Fast 更快。

1. Fast：找一个备用接收者，尝试将未知消息转发给备用接收者去处理。

具体来说，就是给 receiver 发送一条如下消息，注意有类方法和实例方法之分。

```objectivec
+/- (id)forwordingTargetForSelector:(SEL)selector;
```

如果我们重写了以上方法，并正确返回了一个 != receiver 的对象（备用接收者），那么 Runtime 就会通过 objc_msgSend 给备用接收者发送当前的未知消息，开启新的消息执行流程。

如果该阶段还是没能处理未知消息，就进入 Normal。需要注意，在 Fast 阶段无法修改未知消息的内容，如果需要，请在 Normal 阶段去处理。

2. Normal：启动完整的消息转发，将消息有关的全部细节都封装到一个 NSInvocation 实例中，再给接收者最后一次机会去处理未知消息。

具体来说，Runtime 会先通过调用以下方法来获取适合未知消息的方法签名。

```objectivec
+/- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;
```

然后根据这个方法签名，创建一个封装了未知消息的全部内容（target、selector、arguments）的 NSInvocation 实例，然后调用以下方法并将该 NSInvocation 实例作为参数传入。

```objectivec
+/- (void)forwardInvocation:(NSInvocation *)invocation;
```

我们可以重写以上方法来处理未知消息。在 `forwardInvocation:` 方法中，我们可以直接将未知消息转发给其它对象（代价太大，不如在 Fast 处理），或者改变未知消息的内容再转发给其它对象，甚至可以定义任何逻辑。

如果到了 Normal 还是没能处理未知消息，如果是没有返回方法签名，那么将调用 `doesNotRecognizeSelector:`；如果是没有重写 `forwardInvocation:`，将调用 NSObject 的 `forwardInvocation:` 的默认实现，而该方法的默认实现也是调用 `doesNotRecognizeSelector:`，表明未知消息最终未能得到处理，以 Crash 程序结束 objc_msgSend 的全部流程。

**一些注意点**

* 重写以上方法时，不应由本类处理的未知消息，应该调用父类的实现，这样继承体系中的每个类都有机会处理未知消息，直至 NSObject。
* 以上几个阶段均有机会处理消息，但处理消息的时间越早，性能就越高。
  - 最好在 `动态方法解析` 阶段就处理完，这样 Runtime 就可以将此方法缓存，稍后这个对象再接收到同一消息时就无须再启动 `动态方法解析` 与 `消息转发` 流程。
  - 如果在 `消息转发` 阶段只是单纯想将消息转发给备用接收者，那么最好在 Fast 阶段就完成。否则还得创建并处理 NSInvocation 实例。
* `respondsToSelector:`  会触发 `动态方法解析`，但不会触发 `消息转发`。

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645/posts)

Q：以下两段代码的执行情况分别如何？

```objectivec
  dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
  for (int i = 0; i < 1000; i++) {
      dispatch_async(queue, ^{
          self.name = [NSString stringWithFormat:@"abcdefghij"];
      });
  }
```

```objectivec
  dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
  for (int i = 0; i < 1000; i++) {
      dispatch_async(queue, ^{
          self.name = [NSString stringWithFormat:@"abcdefghi"];
      });
  }
```

* 第一段代码，self.name 是 `__NSCFString` 类型，存储在堆，需要维护引用计数，其 setter 方法实现为先 release 旧值，再 retain/copy 新值。这里异步并发执行 setter 就可能会有多条线程同时 release 旧值，过度释放对象，导致 Crash。
* 第二段代码，由于指针足够存储数据，字符串的值就直接通过 `Tagged Pointer` 存储在了指针上，self.name 是 `NSTaggedPointerString` 类型。在 `objc_release` 函数中会判断指针是不是 `Tagged Pointer`，是的话就不对对象进行 release 操作，更不会过度释放而导致 Crash 了。

这里是 release 的实现：

```c
__attribute__((aligned(16), flatten, noinline))
void 
objc_release(id obj)
{
    if (!obj) return;
    if (obj->isTaggedPointer()) return;
    return obj->release();
}
```

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645/posts)

Q：执行以下代码，打印结果是什么？

```objectivec
dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@"1");
    [self performSelector:@selector(test) withObject:nil afterDelay:.0];
    NSLog(@"3");
});

- (void)test {
    NSLog(@"2");
}
```

打印结果为 1、3。原因是：

1. `performSelector:withObject:afterDelay:` 的本质是拿到当前线程的 RunLoop 往它里面添加 timer
2. RunLoop 和线程是一一对应关系，子线程默认没有开启 RunLoop
3. 当前 `performSelector:withObject:afterDelay:` 在子线程执行

所以 2 不会打印。

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645/posts)

Q：能否向编译后的类增加实例变量？能否向运行时动态创建的类增加实例变量？为什么？

A：

* 不能向编译后的类增加实例变量。类的内存布局在编译时就已经确定，类的实例变量列表存储在 class_ro_t Struct 里，编译时就确定了内存大小无法修改，所以不能向编译后的类增加实例变量。
* 能向运行时动态创建的类增加实例变量。运行时动态创建的类只是通过 alloc 分配了类的内存空间，没有对类进行内存布局，内存布局是在类初始化过程中完成的，所以能向运行时动态创建的类增加实例变量。

```objectivec
Class newClass = objc_allocateClassPair([NSObject class], "Person", 0);
class_addIvar(newClass, "_age", 4, 1, @encode(int));
class_addIvar(newClass, "_name", sizeof(NSString *), log2(sizeof(NSString *)), @encode(NSString *));
objc_registerClassPair(newClass); // 要在类注册之前添加实例变量
```

***

整理编辑：[夏天](https://juejin.cn/user/3298190611456638)

现代开发⼯程师在⾯试过程中，算法⾯试往往有⼀定程度的重要性。

算法⾯试作为基本功之⼀，它包含了太多的逻辑思维，可以考察你思考问题的逻辑和解决问题的能⼒。完全类似的业务选手只能靠`挖掘`，但当⼀个⼈逻辑思维和能⼒不错的情况下，其业务匹配及后期上⼿概率也会很⾼。 

⾯试算法题⽬在难度上（尤其是代码难度上）会略低⼀些，倾向于考察⼀些基础数据结构与算法，通过交流暴露更多的⾯试题细节。

这也就是为什么现代算法⾯试中推崇**⼀题多解**，在实际算法⾯试中出现原题的概率往往不⾼，随着与面试官交流且探讨让已知的面试题出现变化。

下⾯我们以 [LeetCode](https://leetcode.com) 开篇 [TwoSum](https://leetcode.com/problems/two-sum/ "LeetCode - #1 Two Sum") 来简要说明。

> 默认读者有关于时间复杂度和空间复杂度的概念。

### TwoSum

给定⼀个整数数组 `nums` 和⼀个整数⽬标值 `target` ，请你在该数组中找出**和**为⽬标值 `target` 的那**两个**整数，并返回它们的数组下标。 

你可以假设每种输⼊**只会对应⼀个答案**。但是，数组中**同⼀个元素**在答案⾥不能重复出现。 

你可以按**任意顺序**返回答案。 

**示例 1：**

```
输⼊：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输⼊：nums = [3,2,4], target = 6 
输出：[1,2]
```

**示例 3：**

```
输⼊：nums = [3,3]，target = 6 
输出： [0,1]
```

**提示：**

* `2 <= nums.length <= 104` 
* `-109 <= nums[i] <= 109`
* `-109 <= target <= 109`
* **只会存在⼀个有效答案**

### 解析

作为⼏乎⼈⼈  [LeetCode](https://leetcode.com)  ，⼈⼈ Code 过的经典题⽬，本题的最优解就是时间复杂度及空间复杂度皆为 O(n) 的解法

```swift
class Solution {
  func twoSum(_ nums: [Int], _ target: Int) -> [Int] { 
    var dict: [Int: Int] = [:]

    for (i, n) in nums.enumerated() { 
      if let index = dict[target - n] { 
        return [i, index] 
      } 
      dict[n] = i 
    }

    return []
  }

}
```

但是这种面试原题，往往不是我们能正好遇到的。

#### 删减版两数之和

给定⼀个整数数组 `nums` 和⼀个整数⽬标值 `target` ，请你在该数组中找出和为⽬标值 target 的那**两个**整数，并返回它们的数组下标。

**示例 1：**

```
输⼊：nums = [2,7,11,15], target = 9 
输出：[0,1] 解释：
因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

这就很像我们会遇到的初始问题，现在我们一起跟`面试官` 来确认一下面试题吧！

##### 确认异常状态即确认出参与⼊参的限制

我们需要确保两数之和不会超过值的最⼤限制 `Int.Max` 以及会不会超过 `Int.min`

需要跟⾯试官确认参数的限制，以及超出限制以后返回的结果

##### 确认是否有多个答案及结果顺序，及同⼀位置能否⽤多次

确认是否存在**多个**答案，确认数组中是否存在相同数据，以及确认是否需要展示所有正确的值即答案是否唯一且两数下标是否是顺序的

例如：

```
输⼊：nums = [2,2,7,11,15], target = 9
```

这个答案可能是 `[0, 2]` 或 `[1, 2]` 这也会导致最终代码的编写

##### 确认是否整数数组是否有序

对于已经排序的数组，我们可以利⽤双指针的思想来优化我们的代码

```swift
class Solution {
  func twoSum(_ nums: [Int], _ target: Int) -> [Int] { 
    guard nums.count > 0 else {
      return []
    }

    var start = 0 
    var end = nums.count-1 
    while start < end {
      let sum = nums[start] + nums[end] 
      if sum == target { 
        return [start, end] 
      } else if sum < target { 
        start += 1 
      } else { 
        end -= 1 
      }
    } 

    return []
  }
}
```

##### ...

当然可能还有其他变种，如果你有什么想法也可以来丰富所有的示例。

### 总结

算法⾯试题是⼀个与⾯试官交流的好途径，而在⾯试过程中⼀步步与⾯试官交流，可以展现⾯试者逻辑思维能⼒以及沟通交流能⼒。

在实际遇到面试题的时候，我们不着急写出具体的代码，展现你的**思维过程**，利用交流丰富你的表现，思维能力和沟通交流能力。

***

整理编辑：[夏天](https://juejin.cn/user/3298190611456638) 

**树**作为最常见的数据结构之一，在算法中有举足轻重的地位。

理解树有助于我们理解很多其他的数据结构，例如**图**，**栈**等。也有助于我们理解一些算法类型，例如，**回溯算法**和**动态规划**。当然在练习关于树的解题过程中，也能够加深我们对**深度优先**及**广度优先**算法的理解。

今天我们以二叉树的**三序遍历**为题，来开启我们二叉树的学习。

### 题目

给定一个二叉树，返回他的 _**前序**_ _**中序**_ _**后序**_ 三种遍历

> 输入: [4,2,6,1,3,5,7]
>  4
> /   \
> 2     6
> / \   / \ 
> 1  3 5  7

#### 输出

前序遍历：首先访问根结点，然后遍历左子树，最后遍历右子树（根->左->右）

> 顺序：访问根节点->前序遍历左子树->前序遍历右子树
> 
> 前序遍历: [4, 2, 1, 3, 6, 5, 7]

中序遍历：首先遍历左子树，然后访问根节点，最后遍历右子树（左->根->右）

> 顺序：中序遍历左子树->访问根节点->中序遍历右子树
> 
> 中序遍历: [1, 2, 3, 4, 5, 6, 7]

后序遍历：首先遍历左子树，然后遍历右子树，最后访问根节点（左->右->根）

> 顺序：后序遍历左子树->后序遍历右子树->访问根节点
> 
> 后续遍历: [1, 3, 2, 5, 7, 6, 4]

二叉树的遍历方法一般有三种

* 递归
* 迭代（常规迭代加**颜色标记法**）
* 莫里斯遍历（今天暂时不涉及）

### 递归

在树的深度优先遍历中（包括前序、中序、后序遍历），递归方法最为直观易懂，但考虑到效率，我们通常不推荐使用递归。

递归步骤一般需要遵循以下三种：

1. 确定递归的参数以及返回值
2. 确定递归的终止条件，**递归算法一定有终止条件**，避免死循环。
3. 确定单次递归的逻辑

```swift
/// traversals 为输出的数组
func preorder(_ node: TreeNode?) {
    guard let node = node else {
        return
    }
    /// 前序遍历
    traversals.append(node.val) 
    preorder(node.left)
    preorder(node.right)
    /// 中序遍历
    preorder(node.left)
    traversals.append(node.val) 
    preorder(node.right)
    /// 后序遍历
    preorder(node.left)
    preorder(node.right)
    traversals.append(node.val) 
}
```

#### 迭代

二叉树的迭代步骤一般是将节点加入到一个 `栈` 中，然后通过访问栈头/栈尾，根据遍历顺序访问所有的符合的节点。

##### 前序遍历

```swift
func preorderIteration(_ root: TreeNode?) {
    var st:[TreeNode?] = [root]
    while !st.isEmpty {
        let node = st.removeFirst()
        if node != nil {
            traversals.append(node!.val)
        } else {
            continue
        }
        st.insert(node?.right, at: 0)
        st.insert(node?.left, at: 0)
    }
}
```

##### 中序遍历

```swift
func inorderIteration(_ root: TreeNode?) {
    var st:[TreeNode?] = []
    var cur:TreeNode? = root
    while cur != nil || !st.isEmpty {
        if cur != nil {
            st.insert(cur, at: 0)
            cur = cur?.left
        } else {
            cur = st.removeFirst()
            traversals.append(cur!.val)
            cur = cur?.right
        }
    }
}
```

##### 后序遍历

后序遍历其遍历步骤是 `左→右→中`，但是这个代码实现起来不简单。 所以我们可以先访问依次访问 `中→右→左` 的节点，最后将得到结果进行 `reversed`，其结果最终变成 `左→右→中` 。

```swift
func postorderIteration(_ root: TreeNode?) {
    var st:[TreeNode?] = [root]
    while !st.isEmpty {
        let node = st.removeFirst()
        if node != nil {
            print(node!.val)
            traversals.append(node!.val)
        } else {
            continue
        }
        st.insert(node?.left, at: 0)
        st.insert(node?.right, at: 0)
    }
    traversals = traversals.reversed()
}
```

#### 颜色标记法

传统的迭代由上述代码可知，比较繁琐，而且迭代过程中易错。参照 [颜色标记法-一种通用且简明的树遍历方法](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/ "颜色标记法-一种通用且简明的树遍历方法") ，利用一个**兼具栈迭代方法的高效，又像递归方法一样简洁易懂的方法，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码**。

其核心方法如下：

* 标记节点的状态，已访问的节点标记为 **1**，未访问的节点标记为 **0**

* 遇到未访问的节点，将节点标记为 **0**，然后根据三序排序的要求，按照特定的顺序入栈
  
  >  // 前序 `中→左→右` 按照 `右→左→中`
  > 
  >  // 中序 `左→中→右` 按照 `右→中→左`
  > 
  >  // 后序 `左→右→中` 按照 `中→右→左`

* 结果数组中加入标记为 **1** 的节点的值

```swift
    func tuple(_ root: TreeNode?) -> [Int] {
        var traversals = [Int]()
        var statck = [(0, root)]
        while !statck.isEmpty {
            let (isVisted, node) = statck.removeLast()
            if node == nil {
                continue
            }
            if isVisted == 0 {
//                ///前序遍历
//                statck.append((0, node?.right))
//                statck.append((0, node?.left))
//                statck.append((1, node))
//                ///中序遍历
//                statck.append((0, node?.right))
//                statck.append((1, node))
//                statck.append((0, node?.left))
                ///后序遍历
                statck.append((1, node))
                statck.append((0, node?.right))
                statck.append((0, node?.left))
            } else {
                traversals.append(node!.val)
            }
        }
        return traversals
    }
```

利用颜色标记法可以简单的理解迭代的方法，并写出模板代码。

#### 莫里斯遍历

作为兼具性能及低空间复杂度的**莫里斯遍历**，可以在线下讨论。

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645/posts)

### Swift 中 struct 和 class 的区别，值类型和引用类型的区别

**struct & class**

在 Swift 中，其实 `class` 与 `struct` 之间的核心区别不是很多，有很多区别是值类型与引用类型这个区别隐形带来的天然的区别。

- `class` 可以继承，`struct` 不能继承（当然 `struct` 可以利用 `protocol` 来实现类似继承的效果。）；受此影响的区别有：

- - `struct` 中方法的派发方式全都是直接派发，而 `class` 中根据实际情况有多种派发方式，详情可看 [CoderStar｜Swift 派发机制](https://mp.weixin.qq.com/s?__biz=MzU4NjQ5NDYxNg==&mid=2247483768&idx=1&sn=0a6be7a9c5a374cbc5c5ba9a3c48020a&scene=21#wechat_redirec)；

- `class` 需要自己定义构造函数，`struct` 默认生成；

- `class` 是引用类型，`struct` 是值类型；受此影响的区别有：

- - `struct` 改变其属性受修饰符 let 影响，不可改变，`class` 不受影响；
  - `struct` 方法中需要修改自身属性时 (非 `init` 方法)，方法需要前缀修饰符 `mutating`；
  - `struct` 因为是值类型的原因，所以自动线程安全，而且也不存在循环引用导致内存泄漏的风险；
  - ...

- ...

**值类型 & 引用类型**

- 存储方式及位置：大部分值类型存储在栈上，大部分引用类型存储在堆上；
- 内存：值类型没有引用计数，也不会存在循环引用以及内存泄漏等问题；
- 线程安全：值类型天然线程安全，而引用类型需要开发者通过加锁等方式来保证；
- 拷贝方式：值类型拷贝的是内容，而引用类型拷贝的是指针，从一定意义上讲就是所谓的深拷贝及浅拷贝

你可以在 [CoderStar｜从 SIL 角度看 Swift 中的值类型与引用类型](https://mp.weixin.qq.com/s/6bvZ1YIhf2WCNsdkukTlew) 中查看详细内容。

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645/posts)

### 事件传递及响应链

对于 iOS 的事件传递及响应链，你是否还掌握得不够好，推荐阅读我们编辑 @Mim0sa 和 @CoderStar 的这几篇文章以及 Apple 的文档，相信你一定能在面试中所向披靡。

* [@Mim0sa：iOS | 事件传递及响应链](https://juejin.cn/post/6894518925514997767 "@Mim0sa：iOS | 事件传递及响应链")
* [@Mim0sa：iOS | 响应链及手势识别](https://juejin.cn/post/6905914367171100680 "@Mim0sa：iOS | 响应链及手势识别")
* [@CoderStar：iOS 中的事件响应](https://mp.weixin.qq.com/s/OFwC7Z3iir2wKPJoRpLhFw "@CoderStar：iOS 中的事件响应")
* [@Apple：Event Handling Guide for iOS](https://github.com/zhangferry/iOSWeeklyLearning/blob/main/Resources/Books/Event%20Handling%20Guide%20for%20iOS%20官方文档.pdf "@Apple：Event Handling Guide for iOS")
* [Event Handling Guide for iOS 中文翻译版](https://github.com/zhangferry/iOSWeeklyLearning/blob/main/Resources/Books/Event%20Handling%20Guide%20for%20iOS%20中文翻译版.pdf "Event Handling Guide for iOS 中文翻译版")

***

整理编辑：[夏天](https://juejin.cn/user/3298190611456638) 

面试题：HTTP/1.0，HTTP/1.1，HTTP/2 有哪些区别？

### 什么是 HTTP

HTTP（超文本传输协议，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。其默认使用 80 端口，由 HTTP 客户端发起一个请求，建立一个到服务器指定端口（默认是 80 端口）的 **TCP** 连接。

### HTTP/1.0

老的 HTTP 协议标准是 **HTTP/1.0**，为了提高系统的效率，**HTTP/1.0** 规定浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不会跟踪客户也不会记录已经请求过的请求。

这就是  **HTTP/1.0** 的两个主要特性：

* 无状态：服务器不跟踪不记录请求过的状态
* 无连接：每次请求都需要建立 TCP 连接

对于 `无状态` 来说，可以通过设置 `cookie` 或 `seesion` 等机制来实现身份校验和状态记录。

影响一个 HTTP 网络请求的因素主要有两个：**带宽**和**延迟**。 当下，网络设施的逐渐完善使得带宽问题得到较好的解决，从而**延迟**成为主要的影响因素。

**HTTP/1.0** `无连接` 特性导致两种了性能缺陷：

* **连接无法复用**
  
  连接无法复用会导致每次请求都需要进行一次 TCP 连接（即 3 次握手 4 次挥手）和慢启动，降低了网络使用率。

* **队头阻塞**
  
  在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也会阻塞的。这会导致带宽无法被充分利用，以及后续健康请求被阻塞。

### HTTP/1.1

为了消除  **HTTP/1.0** 标准中的歧义内容和提升性能，我们很快的就过渡到了 **HTTP/1.1** 标准，也是当前使用最为广泛的 HTTP 协议 ：

* **默认支持长连接**：在 Header 中新增 `Connection` 参数，其值默认为 `Keep-Alive`。默认保持长连接，数据传输完成后保持 TCP 连接不断开，可以继续使用这个通道传输数据。
  
  > 默认的服务端的长连接时间是 30S。在 iOS 端的实践过程中会有概率出现下面的错误：
  > 
  > > Error Domain=NSURLErrorDomain Code=-1005 "The network connection was lost.

* **HTTP pipeline**：基于长连接的基础，在同一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。

* **缓存处理**：相较于 **HTTP/1.0**，**HTTP/1.1** 提供了更为丰富的缓存策略。在 **HTTP/1.0** 中主要是根据 Header 里的 `If-Modified-Since`、`Expires` 来做为判断缓存的标准，**HTTP/1.1** 则引入了诸如 `Entity tag`、`If-Unmodified-Since`、 `If-Match`、 `If-None-Match` 等缓存方式。并且还在 Header 中新增了 `Cache-control` 参数来管理缓存。

* **断点传输**：相较于 **HTTP/1.0** 无法部分返回数据对象，**HTTP/1.1** 在 Header 中新增了两个参数来支持**请求响应分块**，客户端发请求时对应的是 `Range`，服务器端响应时对应的是 `Content-Range`。

* **Host 头处理**： **HTTP/1.0** 认为每台服务器都指向了唯一的 IP 地址，请求消息中的 URL 中并没有主机的信息。在 **HTTP/1.1** 中新增了 Host 头域，能够使不同域名配置在同一个 IP 地址的服务器上。

### HTTP/2

**SPDY 协议是 HTTP/2 协议的基础**。**HTTP/2** 最大的改进就是从**文本协议**转变为**二进制协议**。

* **帧、消息、流和 TCP 连接**：**HTTP/2** 将一个 TCP 连接分为若干个流（`Stream`），每个流中可以传输若干消息（`Message`），每个消息由若干最小的二进制帧（`Frame`）组成。**HTTP/2** 中，每个用户的操作行为被分配了一个流编号（`stream ID`），这意味着用户与服务端之间创建了一个 TCP 通道；协议将每个请求分割为二进制的控制帧与数据帧部分，以便解析。
* **多路复用**：基于二进制分帧，在同一域名下所有访问都是从同一个 TCP 连接中走，HTTP 消息被分解为独立的帧，无序发送，服务端根据标识符和首部将消息重新组装起来。
* **请求优先级**：为了避免多路复用可能会导致关键请求被阻塞，即利用请求优先级完成高优先级请求先处理。
* **HPACK 算法**：**HTTP/2** 引入了头部压缩算法。利用合适的压缩算法来处理消息头的数据。避免了重复 Header 的传输，减小了传输数据的大小。
* **服务端推送（Server Push）**：在 **HTTP/2**  中，服务器可以对客户端的一个请求发送多个响应。

***

整理编辑：[zhangferry](https://zhangferry.com)

### dealloc 在哪个线程执行

在回答这个问题前需要了解 `dealloc` 在什么时机调用，`dealloc` 是在对象最后一次 `release` 操作的时候进行调用的，对应的源码在 `rootRelease` 中，针对 `nonpointer` 和 SideTable 有两种释放的操作。

 SideTable 管理的引用计数会调用 `sidetable_release`：

```c
uintptr_t
objc_object::sidetable_release(bool performDealloc)
{
#if SUPPORT_NONPOINTER_ISA
    ASSERT(!isa.nonpointer);
#endif
    SideTable& table = SideTables()[this];

    bool do_dealloc = false;

    table.lock();
    auto it = table.refcnts.try_emplace(this, SIDE_TABLE_DEALLOCATING);
    auto &refcnt = it.first->second;
    if (it.second) {
        do_dealloc = true;
    } else if (refcnt < SIDE_TABLE_DEALLOCATING) {
        // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.
        do_dealloc = true;
        refcnt |= SIDE_TABLE_DEALLOCATING;
    } else if (! (refcnt & SIDE_TABLE_RC_PINNED)) {
        refcnt -= SIDE_TABLE_RC_ONE;
    }
    table.unlock();
    if (do_dealloc  &&  performDealloc) {
          // 可以释放的话，调用dealloc
        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));
    }
    return do_dealloc;
}
```

对于 `nonpointer` 指针管理的引用计数，会修改 `extra_rc`值，需要释放时在`rootRelease`方法的底部还是会调用：

```c
if (do_dealloc  &&  performDealloc) {
    ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));
}
```

这里可以看出 `dealloc` 的调用并没有设置线程，所以其执行会根据触发时所在的线程而定，就是说其即可以是子线程也可以是主线程。这个也可以很方便的验证。

### NSString *str = @"123" 这里的 str 和  "123" 分别存储在哪个区域

可以先做一下测试：

```objectivec
NSString *str1 = @"123"; // __NSCFConstantString
NSLog(@"str1.class=%@, str1 = %p, *str1 = %p", str1.class, str1, &str1);
// str1.class=__NSCFConstantString, str1 = 0x1046b8110, *str1 = 0x7ffeeb54dc50
```

这时的 str1 类型是 `__NSCFConstantString`，str1 的内容地址较短，它代表的是常量区，指向该常量区的指针 `0x7ffeeb54dc50` 是在栈区的。

再看另外两种情况：

```objectivec
NSString *str2 = [NSString stringWithFormat:@"%@", @"123"];
NSLog(@"str2.class=%@, str2 = %p, *str2 = %p", str2.class, str2, &str2);
// str2.class=NSTaggedPointerString, str2 = 0xe7f1d0f8856c5253, *str2 = 0x7ffeeb54dc58

NSString *str3 = [NSString stringWithFormat:@"%@", @"iOS摸鱼周报"]; //
NSLog(@"str3.class=%@, str3 = %p, *str3 = %p", str3.class, str3, &str3);
// str3.class=__NSCFString, str3 = 0x600002ef8900, *str3 = 0x7ffeeb54dc30
```

这里的字符串类型为 `NSTaggedPointerString` 和 `__NSCFString`，他们的指针都是在栈区，这三个对象的指针还是连续的，内容部分，前者在指针里面，后者在堆区。（栈区地址比堆区地址更高）

这里再回顾下内存的分区情况，大多数情况我们只需关注进程的虚拟内存就可以了：

![](https://cdn.zhangferry.com/Images/20211216172748.png)

***

整理编辑：[zhangferry](https://zhangferry.com)

### HTTPS 建立的过程中客户端是如何保证证书的合法性的？

HTTPS 的建立流程大概是这样的：

1、Client -> Server: 支持的协议和加密算法，随机数 A

2、Server -> Client: 服务器证书，随机数 B

3、Client -> Server: 验证证书有效性，随机数 C

4、Server -> Client: 生成秘钥，SessionKey = f(A + B + C)

5、使用 SessionKey 进行对称加密沟通

其中第 3 步，就需要客户端验证证书的有效性。有效性的验证主要是利用证书的信任链和签名。

#### 证书信任链

我们以 `zhangferry.com`这个网站的 HTTPS 证书为例进行分析：

![](https://cdn.zhangferry.com/Images/20211223165541.png)

`zhangferry.com` 的证书里有一个 Issuer Name 的分段，这里表示的是它的签发者信息。其签发者名称是 *TrustAsia TLS RSA CA*，而我们可以通过上面的链式结构发现，其上层就是*TrustAsia TLS RSA CA*。再往上一层是 *DigiCert Global Root CA*，所以证书签发链就是：*DigiCert Global Root CA* -> *TrustAsia TLS RSA CA* -> *zhangferry.com*。

其中 *DigiCert Global Root CA* 是根证书，它的签发者是它自己。根证书由特定机构颁发，被认为是可信的。我们的电脑在安装的时候都会预装一些 CA 根证书，查看钥匙串能够找到刚才的根证书：

![](https://cdn.zhangferry.com/Images/20211223170915.png)

如果能够验证签发链是没有篡改的，那就可以说明当前证书有效。

#### 签发有效

要验证 *DigiCert Global Root CA*（简称 A） 签发了 *TrustAsia TLS RSA CA*（简称 B） ，可以利用 RSA 的非对称性。这里分两步：签发、验证。

签发：A 对 B 签发时，由 B 的内容生成一个 Hash 值，然后 A 使用它的私钥对这个 Hash 值进行加密，生成签名，放到 B 证书里。

验证：使用 A 的公钥（操作系统内置在钥匙串中）对签名进行解密，得到签发时的 Hash 值 H1，然后单独对 B 内容进行 Hash 计算，得到 H2，如果 H1== H2，那么就说明证书没有被篡改过，验证通过。

这些过程中使用到的对称加密算法和 Hash 算法都会在证书里说明。同理逐级验证，直到最终的证书节点，都没问题就算是证书验证通过了。流程如下：

![](https://cdn.zhangferry.com/Images/20211223174908.png)

图片来源：https://cheapsslsecurity.com/blog/digital-signature-vs-digital-certificate-the-difference-explained/

### Hash 冲突的解决方案

当两个不同的内容使用同一个 Hash 算法得到相同的结果，被称为发生了 Hash 冲突。Hash 冲突通常有两种解决方案：开放定址法、链地址法。

#### 开放定址法

开放定址法的思路是当地址已经被占用时，就再重新计算，直到生成一个不被占用地址。对应公式为：

![](https://cdn.zhangferry.com/Images/20211223221219.png)

其中 di 为增量序列，m 为散列表长度， i 为已发生的冲突次数。根据 di 序列的内容不同又分为不同的处理方案：

di = 1, 2, 3...(m-1)，为线性数列，就是线性探测法。

di = 1^2, 2^2, 3^2...k^2，为平方数列，就是平法探测法。

di = 伪随机数列，就是伪随机数列探测法。

#### 链地址法

链地址法是用于解决开放定址法导致的数据聚集问题，它是采用一个链表将所有冲突的值一一记录下来。

#### 其他方法

再哈希法：设置多个哈希算法，如果冲突就更换算法，重新计算。

建立公共溢出区：将哈希表和溢出数据分开存放，冲突内容填入溢出表中。

参考：[wiki-散列表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8 "wiki-散列表")

***

整理编辑：[zhangferry](https://zhangferry.com)

### dyld 2 和 dyld 3 有哪些区别

dyld 是动态加载器，它主要用于动态库的链接和程序启动加载工作，它目前有两个主要版本：dyld 2 和 dyld 3。

**dyld 2**

[dyld2](https://github.com/opensource-apple/dyld/tree/master/src "dyld开源地址") 从 iOS 3.1 开始引入，一直到 iOS 12 被 dyld 3 全面代替。它经过了很多次版本迭代，我们现在常见的特性比如 ASLR，Code Sign，Shared Cache 等技术，都是在 dyld 2 中引入的。dyld 2 的执行流程是这样的：

![](https://cdn.zhangferry.com/Images/20220104235847.png)

- 解析 `mach-o` 头文件，找到依赖库，依赖库又可能有别的依赖，这里会进行递归分析，直到获得所有 dylib 的完整图。这里数据庞大，需要进行大量的处理；
- 映射所有 `mach-o` 文件，将它们放入地址空间；
- 执行符号查找，若你的程序使用 `printf` 函数，将会查找 `printf` 是否在库系统中，然后我们找到它的地址，将它复制到你的程序中的函数指针上；
- 进行 bind 和 rebase，修复内部和外部指针；
- 运行一些初始化任务，像是加载 category、load 方法等；
- 执行 main；

**dyld 3**

dyld 3 在 2017 年就被引入至 iOS 11，当时主要用来优化系统库。现在，在 iOS 13 中它也将用于启动第三方 APP，完全替代 dyld 2。

dyld 3 最大的特点就是引入了启动闭包，闭包里包含了启动所需要的缓存信息，而且这个闭包在进程外就完成了。在打开 APP 时，实际上已经有不少工作都完成了，这会使 dyld 的执行更快。

最重要的特性就是启动闭包，闭包里包含了启动所需要的缓存信息，从而提高启动速度。下图是 dyld 2 和 dyld 3 的执行步骤对比：

![](https://cdn.zhangferry.com/Images/20220105001119.png)

dyld 3 的执行步骤分两大步，以图中虚线隔开，虚线以上进程外执行，以下进程创建时执行：

* 前 3 步查找依赖和符号相对耗时，且涉及一些安全问题，所以将这些信息做成缓存闭包写入磁盘里，对应地址：`tmp/com.apple.dyld`。闭包会在重启手机/更新/下载 App 的首启等时机创建。

* 进程启动时，读取闭包并验证闭包有效性。

* 后面步骤同 dyld 2 

[iOS 13中dyld 3的改进和优化](https://easeapi.com/blog/blog/83-ios13-dyld3.html "iOS 13中dyld 3的改进和优化")

[iOS dyld 前世今生](https://www.yotrolz.com/posts/c2aae680/ "iOS dyld 前世今生")

### 编译流程

一般的编译器架构，比如 LLVM 采用的都是三段式，也即从源码到机器码需要经过三个步骤：

前端 Frontend -> 优化器 Optimizer -> 后端 Backend

这么设计的好处就是将编译职责进行分离，当新增语言或者新增 CPU 架构时，只需修改前端和后端就行了。

其中前端受语言影响，Objective-C 和 Swift 对应的前端分别是 clang 和 swiftc。下图整理了两种语言的编译流程：

![](https://cdn.zhangferry.com/Images/ios_compiler.png)

#### 前端

编译前端做的工作主要是：

1. 词法分析：将源码进行分割，生成一系列记号（token）。
2. 语法分析：扫描上一步生成的记号生成语法树，该分析过程采用上下文无关的语法分析手段。
3. 语义分析：语义分析分为静态语义分析和动态语义分析两种，编译期间确认的都是静态语义分析，动态语义需运行时期间才能确定。该步骤包括类型匹配和类型转换，会确认语法树中各表达式的类型。

之后导出 IR 中间件供优化器使用。这一步 Swift 会比 ObjC 多几个步骤，其中一个是 ClangImporter，这一步用于兼容 OC。它会导入 Clang Module，把 ObjC 或者 C 的 API 映射为 Swift API，导出结果能够被语义分析器使用。

另外一个不同是 Swift 会有几个 SIL 相关的步骤（蓝色标注），SIL 是 Swift Intermediate Language 的缩写，意为 Swift 中间语言，它不同于 IR，而是特定于 Swift 的中间语言，适合用于对 Swift 源码进行分析和优化。它这里又分三个步骤：

1. 生成原始的 SIL
2. 进行一些数据流诊断，转成标准 SIL
3. 做一些特定于 Swift 的优化，包括 ARC、泛型等

#### 优化器

编译前端会生成统一的 IR (Intermediate Representation) 文件传入到优化器，它是一种强类型的精简指令集，对目标指令进行了抽象。Xcode 中的 Optimization Level 的几个优化等级: `-O0` , `-O1` , `-O2` , `-O3` , `-Os`，即是这个步骤处理的。

如果开启了 Bitcode，还会转成 Bitcode 格式，它是 IR 的二进制形式。

#### 后端

这个步骤相对简单，会根据不同的 CPU 架构生成汇编和目标文件。

#### 链接

项目编译是以文件为单位的，跨文件调用方法是无法定位到调用地址的，链接的作用就是用于绑定这些符号。链接分为静态链接和动态链接两种：

* 静态链接发生在编译期，在生成可执行程序之前会把各个 .o 文件和静态库进行一个链接。常用的静态链接器为 GNU 的 `ld`，LLVM4 里也有自己的链接器 `lld`。

* 动态链接发生在运行时，用于链接动态库，它会在启动时找到依赖的动态库然后进行符号决议和地址重定向。动态链接其为 `dyld`。

[Swift.org - Swift Compiler](https://www.swift.org/swift-compiler/#compiler-architecture "Swift.org - Swift Compiler")

***

整理编辑：[zhangferry](https://zhangferry.com)

### 如何检测内存泄露

**内存泄漏**指的是程序中已动态分配的堆内存（程序员自己管理的空间）由于某些原因未能释放或无法释放的现象。该现象会造成系统内存的浪费，导致程序运行速度变慢甚至系统崩溃。

在 ARC 模式下，导致内存泄露的主要原因是循环引用，其次是非 OC 对象的内存处理、野指针等。针对内存泄露的检测方案也基本从以上几种类型中入手，它们可以分为两类：工具类和代码类。

#### 工具类

工具类比较多：

* Instruments 里的 Leaks

* Memory Graph Debugger

* Schems 里的 Memory Management

* XCTest 中的 XCTMemoryMetric

前两种方式比较常见，后两种内存泄露还需要借助于 Xcode 导出的 memgraph 文件，结合 `leaks`、`malloc_history` 等命令行工具进行分析。工具类检测方案都有一个缺点就是比较繁琐，开发阶段很容易遗漏，所以基于代码的自动化内存泄露检测方案更适合使用。

#### 代码类

代码类检测泄露方式有三个典型的库。

**MLeaksFinder**

地址：https://github.com/Tencent/MLeaksFinder

它的基本原理是这样的，当一个 ViewController 被 pop 或 dismiss 之后，我们认为该 ViewController，包括它上面的子 ViewController，以及它的 View，View 的 subView 等等，都很快会被释放，如果某个 View 或者 ViewController 没释放，我们就认为该对象泄漏了。

它是基于 Method Swizzled 方式，需要 Hook ViewController 的 `viewDidDisappear` ，`viewWillAppear` 等方法。所以仅适用于 Objective-C 项目。

**LifetimeTracker**

地址：https://github.com/krzysztofzablocki/LifetimeTracker

LifetimeTracker 是使用 Swift 实现的，可以同时支持 OC 和 Swift 项目。它的原理是用一个协议表达监听泄露能力，我们提前设置监听入口和允许存在的对象个数。内部维护一个类似引用计数一样的数值，进入监听会进行一个 +1 操作，还会监听该对象的 `deinit` 方法，如果调用执行 `-1`。如果该「引用计数」大于我们设置的最大对象个数，就触发可视化的泄露警告。

简化一些流程之后的代码：

```swift
internal func track(_ instance: Any, configuration: LifetimeConfiguration, file: String = #file) {
    let instanceType = type(of: instance)
    let configuration = configuration
    configuration.instanceName = String(reflecting: instanceType)

    func update(_ configuration: LifetimeConfiguration, with countDelta: Int) {
        let groupName = configuration.groupName ?? Constants.Identifier.EntryGroup.none
        let group = self.trackedGroups[groupName] ?? EntriesGroup(name: groupName)
        group.updateEntry(configuration, with: countDelta)
        // 检测当前计数是否大于最大引用数
        if let entry = group.entries[configuration.instanceName], entry.count > entry.maxCount {
            self.onLeakDetected?(entry, group)
        }
        self.trackedGroups[groupName] = group
    }
    // 开始检测，计数+1
    update(configuration, with: +1)

    onDealloc(of: instance) {
        // 执行deinit，计数-1
        update(configuration, with: -1)
    }
}
```

**FBRetainCycleDetector**

地址：https://github.com/facebook/FBRetainCycleDetector

上面两种方案都是粗略的检测，是 ViewController 或者 View 级别的，要想知道更具体的信息，到底哪里导致的循环应用就无能为力了。而 FBRetainCycleDetector 就是用于解决这类问题，因为需要借助 OC 的动态特性，所以该库无法在 Swift 项目中发挥作用。

它的实现相对上面两个方案更复杂一些，大致原理是基于 `DFS` 算法，把整个对象之间的强引用关系当做图进行处理，查找其中的环，就找到了循环引用。

核心是寻找对象之间的强引用关系，在 OC 语言中，强引用关系主要发生在这三种场景里，针对这三种场景也有不同的处理方案：

**类的成员变量**

通过 `runtime` 的 `class_getIvarLayout` 获取描述该类成员变量的布局信息，然后通过 `ivar_getOffset` 遍历获取成员变量在类结构中的偏移地址，然后获取强引用变量的集合。

**关联对象**

利用 fishhook hook `objc_setAssociatedObject` 和 `objc_removeAssociatedObjects` 这两个方法，对通过 `OBJC_ASSOCIATION_RETAIN`和`OBJC_ASSOCIATION_RETAIN_NONATOMIC` 策略进行关联的对象进行保存。

**block 持有**

理解这个原理还需要再回顾下 block 的内存布局，FBRetainCycleDetector 对 block 结构体进行了等价的封装：

```c
struct BlockLiteral {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct BlockDescriptor *descriptor;
    // imported variables
};

struct BlockDescriptor {
  unsigned long int reserved;                // NULL
  unsigned long int size;
  // optional helper functions
  void (*copy_helper)(void *dst, void *src); // IFF (1<<25)
  void (*dispose_helper)(void *src);         // IFF (1<<25)
  const char *signature;                     // IFF (1<<30)
};
```

在 `BlockLiteral` 结构体的 descriptor 字段之后的位置会存放 block 持有的对象，但是并非所有对象都是我们需要的，我们只需要处理强引用对象即可。而恰恰 block 的引用对象排列基于寻址长度对齐，较大地址放在前面，且强引用对象会排在弱引用之前，所以从 descriptor 之后的成员变量，可以按固定的指针长度依次取出对象。这之后的对象用 `FBBlockStrongRelationDetector` 封装，但这有可能会多取对象，比如 weak 类型的引用其实是不需要捕捉的。

该库的做法是重写 `FBBlockStrongRelationDetector` 对象的 release 方法，仅设置标记位，然后外部调用它的 dispose 方法，这样其强引用对象都会调用 release，被调用这部分都是强引用对象。

```objectivec
static NSIndexSet *_GetBlockStrongLayout(void *block) {
    ...
    void (*dispose_helper)(void *src) = blockLiteral->descriptor->dispose_helper;
    const size_t ptrSize = sizeof(void *);    
    const size_t elements = (blockLiteral->descriptor->size + ptrSize - 1) / ptrSize;

    void *obj[elements];
    void *detectors[elements];

    for (size_t i = 0; i < elements; ++i) {
        FBBlockStrongRelationDetector *detector = [FBBlockStrongRelationDetector new];
        obj[i] = detectors[i] = detector;
    }

    @autoreleasepool {
        dispose_helper(obj);
    }
    ...
}
```

当拿到以上所有强引用关系时就可以利用 DFS 深度优先搜索遍历引用树，查找是否有环形引用了。

`FBRetainCycleDetector` 的检测方案明显更复杂、更耗时，所以几乎不可能针对所有对象都进行检测，所以更好的方案是配合 MLeaksFinder 或者 facebook 自己的 [FBAllocationTracker](https://github.com/facebookarchive/FBAllocationTracker "FBAllocationTracker")，先找到潜在泄露对象，然后分析这些对象的强引用关系，查找是否存在循环引用。

**其他方案**

在资料查找过程中还发现了另一个库 [BlockStrongReferenceObject](https://github.com/tripleCC/Laboratory/tree/master/BlockStrongReferenceObject "BlockStrongReferenceObject") ，它只检测 Block 导致的循环引用问题，跟 `FBRetainCycleDetector` 类似，也是要分析 block 内存布局。但不同的是，它可以完全根据内存布局，来定位到强引用对象。主要是依据 block 和 clang 源码进行分析得出，真的非常强👍🏻，如果对实现细节感兴趣可以阅读这篇文章：[聊聊循环引用的检测](https://triplecc.github.io/2019/08/15/%E8%81%8A%E8%81%8A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E6%A3%80%E6%B5%8B/ "聊聊循环引用的检测")。

参考：

[检测和诊断 App 内存问题](https://mp.weixin.qq.com/s/E80VEIJma66fj7BZy1cCeQ)

[draveness的源码分析 - FBRetainCycleDetector](https://github.com/draveness/analyze/tree/master/contents/FBRetainCycleDetector "draveness的源码分析 - FBRetainCycleDetector")

***

整理编辑：[zhangferry](https://zhangferry.com)

### 如何治理 OOM

OOM（Out Of Memory）指的是应用内存占用过高被系统强制杀死的情况，通常还会再分为 FOOM （前台 OOM） 和 BOOM （后台 OOM）两种。其中 FOOM 现象跟常规 Crash 一样，对用户体验影响比较大。

OOM 产生的原因是应用内存占用过高，治理方法就是降低内存占用，这可以分两部分进行：

1、现存代码：问题检测，查找内存占用较大的情况进行治理。

2、未来代码：防裂化，对内存使用进行合理的规范。

#### 问题检测

OOM 与其他 Crash 不同的一点是它的触发是通过 `SIGKILL` 信号进行的，常规的 Crash 捕获方案无法捕获这类异常。那么该如何定位呢，线下我们可以通过 Schems 里的 Memory Management，生成 memgraph 文件进行内存分析，但这无法应用到线上环境。目前主流的线上检测 OOM 方案有以下几个：

**FBAllocationTracker**

由 Facebook 提出，它会 hook OC 中的 `+alloc` 和 `+ dealloc` 方法，分别在分配和释放内存时增加和减少实例计数。

```objectivec
@implementation NSObject (AllocationTracker)

+ (id)fb_newAlloc
{
 id object = [self fb_originalAlloc];
 AllocationTracker::tracker()->incrementInstanceCountForClass([object class]);
 return object;
}

- (void)fb_newDealloc
{
 AllocationTracker::tracker()->decrementInstanceCountForClass([object class]);
 [self fb_originalDealloc];
}
@end
```

然后，当应用程序运行时，可以定期调用快照方法来记录当前活动的实例数。通过实例数量的异常变化来定位发生OOM的问题。

该方案的问题是无法检测非 OC 对象的内存占用，且没有堆栈信息。

参考：[Reducing FOOMs in the Facebook iOS app](https://engineering.fb.com/2015/08/24/ios/reducing-fooms-in-the-facebook-ios-app/ "Reducing FOOMs in the Facebook iOS app")

**OOMDetector**

这个是腾讯采用的方案。

通过 Hook iOS 系统底层内存分配的相关方法（包括 `malloc_*zone`相关的堆内存分配以及 `vm*_allocate` 对应的 VM 内存分配方法），跟踪并记录进程中每个对象内存的分配信息，包括分配堆栈、累计分配次数、累计分配内存等，这些信息也会被缓存到进程内存中。在内存触顶的时候，组件会定时 Dump 这些堆栈信息到本地磁盘，这样如果程序爆内存了，就可以将爆内存前 Dump 的堆栈数据上报到后台服务器进行分析。

![](https://cdn.zhangferry.com/Images/20220119232138.png)

参考：[【腾讯开源】iOS爆内存问题解决方案-OOMDetector组件 - 掘金](https://juejin.cn/post/6844903550187733000)

**Memory Graph**

这个是字节采用的方案，基于内存快照生成内存分布情况。线上 Memory Graph 核心的原理是扫描进程中所有 Dirty 内存，通过内存节点中保存的其他内存节点的地址值建立起内存节点之间的引用关系的有向图，用于内存问题的分析定位，整个过程不使用任何私有 API。该方案实现细节未开源，目前已搭载在字节跳动火山引擎旗下应用性能管理平台（[APMInsight](https://www.volcengine.com/product/apminsight "APMInsight")）上，供开发者注册使用。

![](https://cdn.zhangferry.com/Images/20220120225034.png)

[有一篇文章](https://juejin.cn/post/6895583288451465230 "分析字节跳动解决OOM的在线Memory Graph技术实现")分析了这个方案的实现原理：通过 mach 内核的 `vm_*region_recurse/vm_region_recurse64` 函数遍历进程内所有 VM Region。这里包括二进制，动态库等内存，我们需要的是 Malloc Zone，然后通过 `malloc*_get_all_zones` 获取 libmalloc 内部所有的 zone，并遍历每个 zone 中管理的内存节点，获取 libmalloc 管理的存活的所有内存节点的指针和大小。再根据指针判断是 OC/Swift 对象，还是 C++ 对象，还是普通的 Buffer。

参考：[iOS 性能优化实践：头条抖音如何实现 OOM 崩溃率下降50%+](https://juejin.cn/post/6885144933997494280 "iOS 性能优化实践：头条抖音如何实现 OOM 崩溃率下降50%+")

#### 防劣化

防劣化即防止出现 OOM 的一些手段，可以从以下方面入手：

- 内存泄漏：关于内存泄漏的检测可以见[上期内容](https://mp.weixin.qq.com/s/DNXrfZgx0JaXyvfVZ4sYVA)。
- autoreleasepool：在循环里产生大量临时对象，内存峰值会猛涨，甚至出现 OOM。适当的添加 autoreleasepool 能及时释放内存，降低峰值。
- 大图压缩：可以降低图片采样率。
- 前后台切换：后台更容易发生 OOM，因为后台可利用的内存更小，我们可以在进入后台时考虑释放一些内存。

## 优秀博客汇总

### 性能优化

[UIView动画降帧探究](https://mp.weixin.qq.com/s/QVvrgWpjY6mxAqjkrRapPw "UIView动画降帧探究") -- 来自公众号：一瓜技术

[llvm 编译器高级用法：第三方库插桩](https://mp.weixin.qq.com/s/RKg8f6B2jSNuFEImtMnq2Q "llvm 编译器高级用法：第三方库插桩") -- 来自公众号：搜狐技术产品

[你不好奇 Linux 是如何收发网络包的？](https://mp.weixin.qq.com/s/ISQ2qutpJjYOdtM3taeO_A "你不好奇 Linux 是如何收发网络包的？") -- 来自公众号：小林coding

[App 启动提速实践和一些想法](https://mp.weixin.qq.com/s/v2Ym9GPU4J8xCFFNYcpJhg "App 启动提速实践和一些想法") -- 来自公众号：starming

[iOS Forensic Toolkit破解iPhone 5和5c密码](https://mp.weixin.qq.com/s/rFkYFJnIbRf0N-7kBlbzXA "iOS Forensic Toolkit破解iPhone 5和5c密码") -- 来自公众号：iOS进阶宝典

[iOS 性能监控：Runloop 卡顿监控的坑](https://mp.weixin.qq.com/s/vMRQ0VuHLxpaY9oCNd5G8w "iOS 性能监控：Runloop 卡顿监控的坑")  -- 来自公众号：老司机技术周报

[漫画：什么是红黑树？](https://juejin.cn/post/6844903519632228365 "漫画：什么是红黑树？") -- 来自掘金：程序员小灰

[iOS编译速度如何稳定提高10倍以上之一](https://juejin.cn/post/6903407900006449160#heading-19 "iOS编译速度如何稳定提高10倍以上之一") -- 来自掘金：Mr_Coder

[我看技术人的成长路径](https://juejin.cn/post/6906006025925558279 "我看技术人的成长路径") -- 来自掘金：阿里巴巴云原生

[App Store App隐私保护问卷填写指引](https://info.umeng.com/detail?id=398&cateId=1 "App Store App隐私保护问卷填写指引") -- 来自友盟：最新资讯

***

### 年终总结

[GitHub 2020 报告：全球开发者工作与生活的平衡情况](https://juejin.cn/post/6908880779963695118 "GitHub 2020 报告：全球开发者工作与生活的平衡情况") -- 来自掘金：LeviDing

[2020 腾讯Techo Park - Flutter与大前端的革命](https://juejin.cn/post/6908357007749693454 "2020 腾讯Techo Park - Flutter与大前端的革命") -- 来自掘金：恋猫de小郭

[WWDC20 iOS14 Runtime优化](https://mp.weixin.qq.com/s/opD__14wpHL06VKPtXeM4g "WWDC20 iOS14 Runtime优化") -- 来自公众号：知识小集

[使用 Swift 编写 CLI 工具的入门教程](https://mp.weixin.qq.com/s/V4IdsYUouKGr68ULyb88Qw "使用 Swift 编写 CLI 工具的入门教程") -- 来自公众号：一瓜技术

[阿里 10 年：一个普通技术人的成长之路](https://juejin.cn/post/6908569967289958408 "阿里 10 年：一个普通技术人的成长之路") -- 来自掘金：阿里巴巴云原生

2020年刚过完，有挺多写的非常好的年终总结可以看看：

[写在2020最后一天](https://mp.weixin.qq.com/s/bHcXtxheajtpzPvnPqmHRw) -- 来自公众号：iOS成长之路

[如何持续的自我提升](https://mp.weixin.qq.com/s/ysvDfhF-ckKu2qEZTQSb1A) -- 来自公众号：酷酷的哀殿

[2020 的 cxuan 在掘金 | 掘金年度征文](https://juejin.cn/post/6902212510527520775 "2020 的 cxuan 在掘金 | 掘金年度征文") -- 来自掘金：cxuan

[中年裸辞，我的2020 | 掘金年度征文](https://juejin.cn/post/6901709371294613512 "中年裸辞，我的2020 | 掘金年度征文") -- 来自掘金：Semo

[2020：非适应性完美主义、存在主义哲学、架构、基金翻倍、有效休息｜掘金年度征文](https://juejin.cn/post/6913418068953661448 "2020：非适应性完美主义、存在主义哲学、架构、基金翻倍、有效休息｜掘金年度征文") -- 来自掘金：FeelsChaotic

***

### 科技公司技术公众号

这期博客推荐顺带考察了一下各大厂的技术公众号运营情况（仅限移动端），虽然技术号不能反映一个公司的全貌，但多少还是能够体现出该公司的开源分享精神的，顺道推荐几篇高质量的文章。内容较多，还会再有一期，先后顺序不代表排名。

#### 爱奇艺

公众号：**爱奇艺技术产品团队**

综合公众号，输出稳定，质量较高，排版方面可以，大绿框用了好久了，真的可以换一下🤣。

[效率提升50%，移动端UI自助验收在爱奇艺的探索与实践](https://mp.weixin.qq.com/s/K9p8986Gq1DoQ1fUYivPrg "效率提升50%，移动端UI自助验收在爱奇艺的探索与实践")

[爱奇艺知识移动端组件化探索和实践](https://mp.weixin.qq.com/s/DCrixXqnEnuHpYfUPjyACA "爱奇艺知识移动端组件化探索和实践")

#### 阿里

公众号：**淘系技术**

综合技术公众号，输出稳定且高产，质量很高，覆盖面很广，排版也不错，在这几个技术公众号里我感觉是做的最用心也是最好的。

[移动前端开发和 Web 前端开发的区别是什么？](https://mp.weixin.qq.com/s/kPn-2y3Q_CMjwCB1c1yVTA "移动前端开发和 Web 前端开发的区别是什么？")

[一文读懂架构整洁之道](https://mp.weixin.qq.com/s/XAm1MO4RQYtkj3ay-2jT7A "一文读懂架构整洁之道")

公众号：**闲鱼技术**

综合技术公众号，纯移动端内容较少，闲鱼是较早使用Flutter的团队，这里有不少Flutter 相关的实战干货。

#### 百度

公众号：**百度App技术**

偏前端的公众号，稳定输出，质量可以，但是选题较单一，排版有待提高。

[百度App Objective-C/Swift 组件化混编之路（一）](https://mp.weixin.qq.com/s/Vk6KNT_Ca_0se2eckYRuBg "百度App Objective-C/Swift 组件化混编之路（一）")

[百度App Objective-C/Swift 组件化混编之路（二）- 工程化](https://mp.weixin.qq.com/s/xA3g0GdNvfKNgfvG6imEvw "百度App Objective-C/Swift 组件化混编之路（二）- 工程化")

#### 字节跳动

公众号：**字节跳动技术团队**

综合技术公众号，输出稳定，质量较高，感觉仅次于淘系技术。

[iOS性能优化实践：头条抖音如何实现OOM崩溃率下降50%+](https://mp.weixin.qq.com/s/4-4M9E8NziAgshlwB7Sc6g "iOS性能优化实践：头条抖音如何实现OOM崩溃率下降50%+")

[今日头条优化实践： iOS 包大小二进制优化，一行代码减少 60 MB 下载大小](https://mp.weixin.qq.com/s/TnqAqpmuXsGFfpcSUqZ9GQ "今日头条优化实践： iOS 包大小二进制优化，一行代码减少 60 MB 下载大小")

#### 京东

公众号：**京东零售技术**

综合技术公众号，稳定输出，质量也可以，排版感觉一般，有待提高。

[带你深入了解OC对象的销毁过程](https://mp.weixin.qq.com/s/p8RRpuY2AgNc-lJ0NzG9bg "带你深入了解OC对象的销毁过程")

[iOS链接原理解析与应用实践](https://mp.weixin.qq.com/s/_3WXnDolNICs2euoJph44A "iOS链接原理解析与应用实践")

#### 网易

公众号：**网易云音乐大前端团队**

大前端技术公众号，移动端相对较少，输出稳定，质量可以。从2020年5月份建立，排版不断在优化，最新一期挺不错，跟字节跳动技术团队风格一致了。

[网易云音乐 iOS 14 小组件实战手册](https://mp.weixin.qq.com/s/gFd8fkJBkQd5RpFSD0P8Ig "网易云音乐 iOS 14 小组件实战手册")

网易还有另外两个技术号，**网易传媒技术团队**，输出相对少，有兴趣的也可以看下。

#### 拼多多

很抱歉，没有找到他们的技术公众号，只搜到一堆砍价群0。0，如果有了解的小伙伴可以告知下。

#### 搜狐

公众号：**搜狐技术产品**
综合性技术公众号，输出稳定，质量也不错。偏重运营一些，会有很多转载内容。

[带你实现完整的视频弹幕系统](https://mp.weixin.qq.com/s/Y0L1d124V9tWoJA7hYNRMQ "带你实现完整的视频弹幕系统")

[iOS插件化架构探索](https://mp.weixin.qq.com/s/QJ9YHX-Uy6lDIhJe_5wPGw "iOS插件化架构探索")

#### 腾讯

公众号：**腾讯音乐技术团队**
腾讯音乐开发团队公众号，更新不稳定，可能一两个月才会有一篇文章，但质量还是不错的。

[Q音直播编译优化与二进制集成方案](https://mp.weixin.qq.com/s/5q_PLdLeuuuQnsLrbzaOeQ "Q音直播编译优化与二进制集成方案")

腾讯还有个号是**腾讯技术工程**，综合性技术公众号，更新较稳定。
另外有点奇怪的是，微信团队和QQ团队竟然没有单独的技术公众号。微信团队之前有个博客：https://wereadteam.github.io/ ，但看了下2020年只发过一篇文章。

#### 美团

公众号：**美团技术团队**
综合性技术公众号，输出稳定，质量很高，原创文章数量已达358篇，都是团队内部人员写的，非常不错。

[移动端UI一致性解决方案](https://mp.weixin.qq.com/s/oq7ylltdRIdJuSlL7EIiNA "移动端UI一致性解决方案")

[Flutter包大小治理上的探索与实践](https://mp.weixin.qq.com/s/adC-YUWd-xuUlzeAPHzJoQ "Flutter包大小治理上的探索与实践")

#### 滴滴

公众号：**滴滴技术**
综合性技术公众号，但是移动端内容真的很少。不过滴滴在开源社区的贡献还是挺大的，DoraemonKit和chameleon都有很高的star数。

[滴滴开源 DoraemonKit：一款像哆啦A梦般全能的App研发工具](https://mp.weixin.qq.com/s/FXATxeEoRMdKzFRDg-zPFg "滴滴开源 DoraemonKit：一款像哆啦A梦般全能的App研发工具")

#### 即刻

公众号：**即刻技术团队**
综合技术公众号，移动端内容也不少。整理来看即刻做的还是挺不错的。

[iOS中的网络调试](https://mp.weixin.qq.com/s/K0_3efxXKJM3fU-Icyh7Hg "iOS中的网络调试")

#### 其他公司

还有很多科技公司在维护技术公众号，不再过多展开了，大家有兴趣可以自行查找。

| 公司名  | 公众号名    | 说明         |
| ---- | ------- | ---------- |
| 小米   | 小米科技    | 无移动端内容     |
| 贝壳找房 | 贝壳产品技术  | 综合号，有移动端内容 |
| 快手   | 快手Ytech | 无移动端内容     |
| 360  | 360技术   | 综合号，有移动端内容 |
| 携程   | 携程技术    | 综合号，有移动端内容 |

***

### 包体优化 & 开发证书

来自字节跳动技术团队的三篇包体优化文章，涵盖了几乎所有可行且有效的包体优化方案：

[抖音品质建设 - iOS安装包大小优化实践篇](https://juejin.cn/post/6916317500992913421 "抖音品质建设 - iOS安装包大小优化实践篇") -- 来自掘金：字节跳动技术团队

[今日头条iOS安装包大小优化-新阶段、新实践](https://juejin.cn/post/6924107853141655565 "今日头条iOS安装包大小优化-新阶段、新实践") -- 来自掘金：字节跳动技术团队

[今日头条优化实践：iOS包大小二进制优化，一行代码减少60MB下载大小](https://juejin.cn/post/6911121493573402638 "今日头条优化实践：iOS包大小二进制优化，一行代码减少60MB下载大小") -- 来自掘金：字节跳动技术团队

启动优化：

[抖音品质建设 - iOS启动优化《实战篇》](https://juejin.cn/post/6921508850684133390 "抖音品质建设 - iOS启动优化《实战篇》") -- 来自掘金：字节跳动技术团队

[iOS 性能优化：优化App启动速度](https://mp.weixin.qq.com/s/h3vB_zEJBAHCfGmD5EkMcw "iOS 性能优化：优化App启动速度") -- 来自公众号：老司机技术周报

iOS签名及证书的几篇文章：

[iOS证书幕后原理](http://chuquan.me/2020/03/22/ios-certificate-principle/ "iOS证书幕后原理") -- 来自博客：楚权的世界

[iOS App 签名的原理](http://blog.cnbang.net/tech/3386/ "iOS App 签名的原理") -- 来自博客：bang's blog

介绍Swift与OC混编机制的文章：

[从预编译的角度理解Swift与Objective-C及混编机制](https://mp.weixin.qq.com/s/gI9vL1KlHuMzMoWWf2tnIw "从预编译的角度理解Swift与Objective-C及混编机制") -- 来自公众号：美团技术团队

***

### 稳定性 & Flutter 2.0

[函数节流（Throttle）和防抖（Debounce）解析及其OC实现](https://mp.weixin.qq.com/s/h1MYGTYtYo9pcHmqw6tHBw "函数节流（Throttle）和防抖（Debounce）解析及其OC实现")  -- 来自公众号：iOS成长之路

[2021阿里淘系工程师推荐书单](https://mp.weixin.qq.com/s/zi7qWTg8xGf3GaxW6Czj2A "2021阿里淘系工程师推荐书单") -- 来自公众号：淘系技术

[分析字节跳动解决OOM的在线Memory Graph技术实现](https://juejin.cn/post/6895583288451465230 "分析字节跳动解决OOM的在线Memory Graph技术实现") -- 来自掘金：有点特色

[iOS 稳定性问题治理：卡死崩溃监控原理及最佳实践](https://juejin.cn/post/6937091641656721438 "iOS 稳定性问题治理：卡死崩溃监控原理及最佳实践") -- 来自掘金：字节跳动技术团队

[一个iOS流畅性优化工具](https://juejin.cn/post/6934720152546050078 "一个iOS流畅性优化工具") -- 来自掘金：BangRaJun

[iOS防黑产虚假定位检测技术](https://juejin.cn/post/6938197133908672519 "iOS防黑产虚假定位检测技术") -- 来自掘金：欧阳大哥2013

[【译】Flutter 2.0 正式版发布，全平台 Stable](https://juejin.cn/post/6935621027116531720 "[译]Flutter 2.0 正式版发布，全平台 Stable") -- 来自掘金：恋猫de小郭

[如何做一场高质量的分享](https://juejin.cn/post/6938208336802217991 "如何做一场高质量的分享") -- 来自掘金：相学长

***

### Swift Hook & 代码签名

[翻译-为什么objc_msgSend必须用汇编实现](http://tutuge.me/2016/06/19/translation-why-objcmsgsend-must-be-written-in-assembly/ "翻译-为什么objc_msgSend必须用汇编实现") -- 来自博客：土土哥的blog

[深度长文：细说iOS代码签名](http://xelz.info/blog/2019/01/11/ios-code-signature/ "深度长文：细说iOS代码签名") -- 来自博客：xelz's blog

[从Mach-O角度谈谈Swift和OC的存储差异](https://www.jianshu.com/p/ef0ff6ee6bc6 "从Mach-O角度谈谈Swift和OC的存储差异") -- 来自简书：皮拉夫大王在此

[一种Swift Hook新思路——从Swift的虚函数表说起](https://www.jianshu.com/p/0cbbbe783ac9 "一种Swift Hook新思路——从Swift的虚函数表说起") -- 来自简书：皮拉夫大王在此

[Swift5.0 的 Runtime 机制浅析](https://juejin.cn/post/6844903889523884039 "Swift5.0 的 Runtime 机制浅析") -- 来自掘金：欧阳大哥2013

[编译原理初学者入门指南](https://mp.weixin.qq.com/s/ZTxVG6KG-4vzbvclC_Q1LQ "编译原理初学者入门指南") -- 来自公众号：腾讯技术工程

[神秘！申请内存时底层发生了什么？](https://mp.weixin.qq.com/s/DN-ckM1YrPMeicN7P9FvXg "神秘！申请内存时底层发生了什么？") -- 来自公众号：码农的荒岛求生

[推荐收藏 | 美团技术团队的书单](https://tech.meituan.com/2020/04/23/read-book-2020-04-23.html "推荐收藏 | 美团技术团队的书单") -- 来自博客：美团技术团队

[青年人在美团是怎样成长的？](https://tech.meituan.com/2020/05/04/meituan-0504-young-people.html "青年人在美团是怎样成长的？") -- 来自博客：美团技术团队

***

### bitcode & DWARF

1、[我离职了](https://juejin.cn/post/6943384976909942815 "我离职了") -- 来自掘金：敖丙

敖丙还在B站录了[视频](https://www.bilibili.com/video/BV1cp4y1a7DW "我离职了 B站")，看视频可能更有感染力。

2、[我的玩具——乐高魔方机器人](http://xelz.info/blog/2017/02/18/lego-cube-solver/ "我的玩具——乐高魔方机器人") -- 来自博客：xelz's blog

这个真的非常有意思，有理工科思维做一件具体有趣的事情非常酷。大概思路是这样的;

- 手机与LEGO通过蓝牙连接
- LEGO检测到魔方放入之后通知手机开始扫描
- 手机扫描完一个面之后，通知LEGO将魔方翻转到下一个面
- 扫描完毕后，手机开始计算还原步骤
- 手机通过蓝牙将还原公式发送给LEGO
- LEGO按照公式将魔方还原

3、[关于bitcode, 知道这些就够了](http://xelz.info/blog/2018/11/24/all-you-need-to-know-about-bitcode/ "关于bitcode, 知道这些就够了") -- 来自博客：xelz's blog

4、[哈啰出行iOS App首屏秒开优化](https://mp.weixin.qq.com/s/5Ez2BrsyBgQ8aHZqlYtAjg "哈啰出行iOS App首屏秒开优化") -- 来自公众号：哈罗技术团队

5、[SwiftUI: Text 中的插值](https://mp.weixin.qq.com/s/PX8bXSFXgJWMgHqien85jQ "SwiftUI: Text 中的插值") -- 来自公众号：老司机技术周报

6、[深入理解MachO数据解析规则](https://mp.weixin.qq.com/s/z8s4urq_KCf2ny5kKOYMHA) -- 来自公众号：iOS成长之路

7、[MacBook 升级 SSD 硬盘指北](https://mp.weixin.qq.com/s/LMeO6chdac65JQu1Yy2-Iw) -- 来自公众号：iOS成长之路

8、[DWARF文件初探——提取轻量符号表](https://mp.weixin.qq.com/s/s8iwQLNtla5nxF_Tmj2wJg "DWARF文件初探——提取轻量符号表") -- 来自公众号：皮拉夫大王在此

***

### 项目架构 & Swift函数式

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)

1、[我在Uber亲历的最严重的工程灾难](https://mp.weixin.qq.com/s/O1haH28cTr0tkhRAnVZQ6g "我在Uber亲历的最严重的工程灾难") -- 来自公众号：infoQ

准备或者已经接入Swfit可以先了解下

2、[美团 iOS 工程 zsource 命令背后的那些事儿](https://mp.weixin.qq.com/s/3qcv1NW4-ce87cvAS4Jsxg "美团 iOS 工程 zsource 命令背后的那些事儿") -- 来自公众号： 美团技术团队

美团技术团队历史文章，对DWARF文件的另一种应用。文章还原了作者解决问题的思路历程，除了技术本身外，解决问题的思路历程也是值得借鉴的。

3、[NSObject方法调用过程详细分析](https://juejin.cn/post/6844904000450478087 "NSObject方法调用过程详细分析") -- 来自掘金：maniac_kk

字节跳动maniac_kk同学的一篇优质文章，无论深度还是广度都是非常不错的，很多底层知识融会贯通，值得细细品味

4、[iOS疑难Crash的寄存器赋值追踪排查技术](https://www.jianshu.com/p/958d4f109bb0 "iOS疑难Crash的寄存器赋值追踪排查技术") -- 来自简书：欧阳大哥

在缺少行号信息时如何通过寄存器赋值推断出具体的问题代码，具有很高的参考价值，在遇到疑难问题时可以考虑是否能借鉴此思路

5、[抖音 iOS 工程架构演进](https://juejin.cn/post/6950454120826765325 "抖音 iOS 工程架构演进") -- 来自掘金：字节跳动技术团队

业务的发展引起工程架构做出调整，文章介绍了抖音的工程架构演进历程。作为日活过亿的产品，其工程架构的演变对多数APP来说都具有一定的借鉴意义。

6、[Swift的一次函数式之旅](https://mp.weixin.qq.com/s/yiF0NwXffrkunGOieWbIRA "Swift的一次函数式之旅") -- 来自公众号：搜狐技术产品

编程本身是抽象的，编程范例就是我们如何抽象这个世界的方法，而函数式编程就是其中一个编程范例。在函数式编程的世界里一切皆函数，那如何利用这个思想解决实际问题呢？文中给出了两个有趣的例子，希望可以帮你解决对函数式编程的疑惑。

7、[Category无法覆写系统方法？](https://zhangferry.com/2021/04/21/overwrite_system_category/) -- 来自公众号：iOS成长之路

这是一次非常有趣的解决问题经历，以至于我认为解决方式可能比问题本身更有意思。解决完全没有头绪的问题，我们应该避免陷入不断的猜测和佐证中。深挖问题，找到正确方向才更容易出现转机。

***

### libffi && Swift 生态

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)

1、[iOS14.5隐私追踪功能现重大bug！IDFA选项变灰且无法开启(附解决方案)](https://mp.weixin.qq.com/s/rqzI3iiwdPxtWyP8q4wXJg "iOS14.5隐私追踪功能现重大bug！IDFA选项变灰且无法开启（附解决方案") -- 来自公众号：七麦研究院

千呼万唤始出来——iOS14.5上线了。

2、[Swift 2021 生态调研报告](https://mp.weixin.qq.com/s/5SXAozM2c6Ivyzl7B9IfQQ "Swift 2021 生态调研报告") -- 来自公众号： 一瓜技术

Swift 崛起一直是大家的共识，但是缺少量化数据。本文对 Swift 的覆盖量做了细致的分析，从数据层面可以分析 Swift 的形势。对开发者学习和转型有非常积极的意义。

3、[学会黑科技，一招搞定 iOS 14.2 的 libffi crash](https://mp.weixin.qq.com/s/XLqcCfcNhpCA8Tg6LknBCQ "学会黑科技，一招搞定 iOS 14.2 的 libffi crash") -- 来自公众号： 字节跳动技术团队

本文主要介绍了 libffi 在 iOS14.2 上崩溃的原因以及解决方案。如果有相关问题，可以参考本文解决。

4、[libffi探究](https://juejin.cn/post/6844904177609490440 "libffi探究") -- 来自掘金：酱了里个酱

如果对 libffi 不是很了解，可以通过本文来了解和认识下 libffi。

5、[CALayer 的 filters](https://juejin.cn/post/6938583362093187086 "CALayer 的 filters") -- 来自掘金：rickytan

相信很多同学都遇到了哀悼模式黑白色的问题，本文介绍了一种快速便捷的方式，不过存在被拒风险，大家可以灵活把控。

6、[从底层分析一下存在跨进程通信问题的 NSUserDefaults 还能用吗？](https://mp.weixin.qq.com/s/Y1AHFN1kJ9kCjXdFOnUviA "从底层分析一下存在跨进程通信问题的 NSUserDefaults 还能用吗？") -- 来自公众号：酷酷的哀殿

之前字节的文章介绍了卡死的几种情况，其中包括 NSUserDefaults 造成的卡死。本文深入分析了 NSUserDefaults 造成卡死的原因以及用法。

7、[用树莓派打造一个超薄魔镜的简单教程](https://onevcat.com/2021/04/magicmirror/ "用树莓派打造一个超薄魔镜的简单教程") -- 来自博客：OneV's Den

看喵神如何使用树莓派 + 单向玻璃 + 显示器打造一个魔镜。实现原理是：贴紧墙面的一侧无光，类似监控室；我们生活的空间光线较为充足，类似被监控房间；在镜子后方屏幕发出的光，相当于“改善”了镜子内侧的光线条件，这部分光透过镜子，被我们看到，从而形成“镜中屏”的效果。

***

### 性能优化 & LTO

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)

1、[Pecker：自动检测项目中不用的代码](https://juejin.cn/post/6844904012857229326  "Pecker：自动检测项目中不用的代码") -- 来自掘金：RoyCao

又看了一遍这篇文章，可以通过这篇文章学习下作者对**IndexStoreDB**的应用的思路。

2、[【译】你可能不知道的iOS性能优化建议（来自前Apple工程师）](https://juejin.cn/post/6844904067878092808 "[译]你可能不知道的iOS性能优化建议（来自前Apple工程师）") -- 来自掘金：RoyCao

RoyCao的另一篇文章，感觉挺有价值的也挺有意思的。

3、[在抖音 iOS 基础组的体验（文末附内推方式）](https://mp.weixin.qq.com/s/ZOENpzfYk3b1T-OlRi7EYg "在抖音 iOS 基础组的体验（文末附内推方式）") -- 来自公众号：一瓜技术

一线大厂核心APP的基础技术团队究竟在做什么？技术方向有哪些？深度如何？团队成员发展和团队氛围如何？可能很多同学和我有一样的疑问，可以看看这篇文章

4、[iOS 内存管理机制](https://juejin.cn/post/6956144382906990623 "iOS 内存管理机制") -- 来自掘金：奉孝

内存方面总结的很全面，内容很多，准备面试的同学可以抽时间看看。

5、[LLVM Link Time Optimization](https://mp.weixin.qq.com/s/Th1C3_pVES6Km6A7isgYGw "LLVM Link Time Optimization") -- 来自公众号：老司机周报

相信很多同学都尝试开启LTO比较优化效果，但是我们真的完全开启LTO了吗？个人感觉这是一篇让人很有收获的文章，可以仔细阅读一番

6、[A站 的 Swift 实践 —— 上篇](https://mp.weixin.qq.com/s/rUZ8RwhWf4DWAa5YHHynsQ "A站 的 Swift 实践 —— 上篇") -- 来自公众号：快手大前端技术

不用看作者，光看插图就知道是戴老师的文章。期待后续对混编和动态性的介绍。

***

### Wakeup & 稳定性

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)

1、[普通技术人的成长路径 - 一位客户端老兵的经验之谈](https://mp.weixin.qq.com/s/IrSQyyc0J3SXBuWs9M3SYA "普通技术人的成长路径 - 一位客户端老兵的经验之谈") -- 来自公众号： 老司机周报

青衫不负踏歌行，莫忘曾经是书生。很认同其中的一些观点和思考。不知道大家是否跟我一样，存在各种各样的焦虑：客三消、内卷、35岁危机... 抽空可以读读此文，让内心的焦躁得到暂时的缓解。

2、[Swift 汇编（一）Protocol Witness Table 初探](https://mp.weixin.qq.com/s/lRKVZk5c1tX7AtWVgD56OA "Swift 汇编（一）Protocol Witness Table 初探") -- 来自公众号：Swift 社区

之前关注过 Protocol Witness Table，但是没有抽时间去了解。很有深度的一篇文章，值得阅读，如果有时间可以跟着作者的思路亲自动手调试下。

3、[Wakeup in XNU](https://mp.weixin.qq.com/s/8OBAmyCLa6_eFYqIJgoCQw "Wakeup in XNU") -- 来自公众号： 网易云音乐大前端团队

去年年底的时候在群里帮一位同学解析了一个 wakeup 日志。wakeup 日志看起来比较奇怪，可能很多同学并没有遇到类似的问题。通过这篇专业的文章可以让大家对 wakeup 有个初步了解。

4、[快手客户端稳定性体系建设](https://blog.csdn.net/Kwai_tech/article/details/107964806 "快手客户端稳定性体系建设") -- 来自CSDN：快手技术团队

这里面就提到了快手遇到了 wakeup 崩溃以及如何定位相关问题的。

5、[iOS技能拓展 初识符号与链接](https://juejin.cn/post/6961576195332309006 "iOS技能拓展 初识符号与链接") -- 来自掘金：我是好宝宝

熟悉Mach-O与链接会成为面试的加分项，正在面试的同学可以关注下。

6、[了解和分析iOS Crash](https://segmentfault.com/a/1190000016411126 "了解和分析iOS Crash") -- 来自segmentfault：腾讯WeTest

iOS crash相关很好很全面的文章，作者加了注解帮助我们理解，已收藏。

7、[A站 的 Swift 实践 —— 下篇](https://mp.weixin.qq.com/s/EIPHLdxBMb5MiRDDfxzJtA "A站 的 Swift 实践 —— 下篇") -- 来自公众号：快手大前端技术

这个是戴铭老师的 Swift 实践的下篇，相对于上篇更偏向于宏观的介绍 Swift，这篇则更加贴近实际开发场景。Swift 实战的推进有两个重要问题需要解决，一个是 Module 化，处理组件及混编问题，一个是 Swift 的 Hook 方案，处理各种 Hook 场景。

***

### watchdog

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)

1、[iOS watchdog (看门狗机制)](https://www.jianshu.com/p/6cf4aeced795 "iOS watchdog (看门狗机制)") -- 来自简书：Mr_Xie

先来简单了解什么是 watchdog。

2、[iOS App 后台任务的坑](http://www.cocoachina.com/articles/27303 "iOS App 后台任务的坑") -- 来自cocoachina ：米米狗

后台任务泄漏是导致触发 watchdog 常见情况之一，还有一种情况就是主线程卡死，文章中有介绍如何区分。

3、[Addressing Watchdog Terminations](https://developer.apple.com/documentation/xcode/addressing-watchdog-terminations "Addressing Watchdog Terminations")

苹果的官方文档。对我个人而言，了解 scene-create 和 scene-update 的含义在排查问题过程中起到了一定的作用。

4、[你的 App 在 iOS 13 上被卡死了吗](https://zhuanlan.zhihu.com/p/99232749 "你的 App 在 iOS 13 上被卡死了吗")

进入实践阶段，其实我们很少真的在主线程做大量耗时操作如网络请求等。触发 watchdog 往往是不经意的，甚至你不会怀疑你的代码有任何问题。这篇文章介绍的是 58 同城团队如何定位到剪切板造成的启动卡死。

5、[iOS 稳定性问题治理：卡死崩溃监控原理及最佳实践](https://juejin.cn/post/6937091641656721438 "iOS 稳定性问题治理：卡死崩溃监控原理及最佳实践")

这篇文章是字节跳动 APM 团队早些时候发表的，是业界少有的公开介绍卡死崩溃的原因的文章，具有很强的借鉴意义。我们在做启动卡死优化的过程中，文中提到的相关问题基本都有遇到，只不过在此之前并不知道什么原因以及如何解决。所以说如果你想做卡死治理，可以参考下这篇文章。

6、[面试过 500+ 位候选人之后，想谈谈面试官视角的一些期待](https://mp.weixin.qq.com/s/kv-_oZObp7QRHeAbrkdfsA "面试过500+位候选人之后，想谈谈面试官视角的一些期待")

《iOS 稳定性问题治理：卡死崩溃监控原理及最佳实践》的作者在面试了 500+ 候选人后写的文章，有需要的同学可以针对性的做些准备。

7、[论证：iOS安全性，为什么需要审核？](https://juejin.cn/post/6967199105541996575 "论证：iOS安全性，为什么需要审核？")

[@iHTCboy](https://github.com/iHTCboy)：从辩论的视角分析 iOS 安全性，同时与 macOS 安全性进行对比，提出了让 iOS 更加安全的建议，文中同时也总结了非常多 iOS 和 macOS 安全技术小知识，可以让大家在短时间里快速入门和重温 Apple OS 安全性知识点。

***

### APP 性能

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)

[揭秘 APM iOS SDK 的核心技术](https://github.com/aozhimin/iOS-APM-Secrets "揭秘 APM iOS SDK 的核心技术") -- 来自 github:aozhimin

[iOS-Monitor-Platform](https://github.com/aozhimin/iOS-Monitor-Platform "iOS-Monitor-Platform") -- 来自 github:aozhimin

以上两篇文章来自 aozhimin，作者在介绍性能监控方案的同时也透露了如何利用逆向技术分析他人的技术方案。

[美团外卖iOS App冷启动治理](https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html "美团外卖iOS App冷启动治理") -- 来自美团技术团队

美团早些年的技术文章，文中的很多内容依旧不过时。

[抖音品质建设 - iOS启动优化《实战篇》](https://mp.weixin.qq.com/s/ekXfFu4-rmZpHwzFuKiLXw  "抖音品质建设 - iOS启动优化《实战篇》")-- 微信公众号：字节跳动技术团队

本文介绍的都是抖音遇到的具体问题，很具有参考性。

[从探索到实践，iOS动态库懒加载实录](https://mp.weixin.qq.com/s/g5FKnOcW6KonqBSW8XO9Jw "从探索到实践，iOS动态库懒加载实录") -- 微信公众号：58技术

上文中提到了非常规方案--动态库懒加载。本文则介绍了 58同城APP 中如何对部分代码修改为动态库并实现懒加载的。目前动态库懒加载在 58集团 有大量的应用。

[抖音品质建设 - iOS 安装包大小优化实践篇](https://mp.weixin.qq.com/s/LSP8kC09zjb-sDjgZaikbg "抖音品质建设 - iOS 安装包大小优化实践篇") -- 微信公众号：字节跳动技术团队

我们统计到 58APP iOS12 及以下还是有相当一部分用户的。文中提到的段迁移实践后确实起到了不小的下载优化作用。

[揭秘苹果应用审核团队（史上最全版）](https://juejin.cn/post/6970363897668698148/ "揭秘苹果应用审核团队（史上最全版）") -- 掘金：37手游iOS技术运营团队

[@iHTCboy](https://github.com/iHTCboy)：史上最全版：揭秘苹果应用审核团队，告诉你 App Store 的由来，是怎样发展到今天这样辉煌，如何自动化：机器审核+人工审核？审核速度是怎么从 7-10 天，提升到如今只需要 48 小时的？

***

### 逆向原理篇

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)

[iosre](https://iosre.com "iosre") -- 来自网站：https://iosre.com

一个活跃逆向论坛。

[iOS逆向(11)-砸壳原理剖析，主动加载所有framework](https://juejin.cn/post/6844904006024691726 "iOS逆向(11)-砸壳原理剖析，主动加载所有framework") -- 来自掘金：一缕清风扬万里

[砸壳这件破事](https://mp.weixin.qq.com/s/xFHA2tlc6HCLti_ihlrsZA "砸壳这件破事") -- 来自：非尝咸鱼贩

谈到逆向首先需要来了解下砸壳。到底什么是“壳”，砸壳到底砸的是什么？

[iOS App 签名的原理](http://blog.cnbang.net/tech/3386/ "iOS App 签名的原理") -- 来自：bang's blog

这篇文章是我经常拿出来翻看的，每次谈到签名流程都需要查看下。

[Code Signing - iOS 代码段的校验机制分析](https://mp.weixin.qq.com/s/msUwo3YUcfHXkuAp5wRfyQ "Code Signing - iOS 代码段的校验机制分析") -- 来自公众号：高级页面仔

这篇文章对签名校验讲述的很详细，使用 xnuspy 可以 hook 系统缺页中断函数，这可能对我们日后的性能分析有帮助。

[iOS LLDB中反反调试分析与实现](https://mp.weixin.qq.com/s/egrQxxJSympB-L6BdVDQVA "iOS LLDB中反反调试分析与实现")  -- 来自公众号：看雪学院

`__TEXT` 段是只读的，到底能不能在运行期间修改呢？可以看看这篇文章。

***

### 启动优化

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)

一、[如何实现 iOS App 的冷启动优化](https://juejin.cn/post/6844904085108310024 "如何实现 iOS App 的冷启动优化") -- 来自掘金：FiTeen

工欲善其事，必先利其器。想要优化启动速度首先要了解什么是冷启动，以及冷启动过程中经历了哪些阶段，然后找到可以进行优化的关键点。作者详细介绍了启动的理论知识和检测工具，包括冷启动与热启动的区别，如何查看阶段耗时以及相关概念解读。这是优化启动速度的必备功课，对于想要做启动速度优化相关同学来说，值得学习。

二、[深入探索 iOS 启动速度优化（二进制重排）](https://juejin.cn/post/6844904121896534024 "深入探索 iOS 启动速度优化（二进制重排）") -- 来自掘金：SimonYe

二进制重排原理是，在启动过程中，会调用各种函数，这些函数分布在各个 TEXT 段中且可能是不连续的，此时需要多次 page fault 创建分页，而每页大概 16kb，每次 page fault 都有耗时。如果我们重排二进制，把他们放在一起，减少 page fault 的次数，是不是就可以减少耗时了？作者介绍了二进制重排的理论基础，以及实践流程，还有关于二进制重排的总结，具体二进制重排能提升多少，还得你自己实践。如果想要实践二进制重排，这篇文章将给你帮助。

三、[🐻记录启动速度优化30%的过程](https://juejin.cn/post/6844904151483154445 "🐻记录启动速度优化30%的过程") -- 来自掘金：我是熊大

早期的 Pod 对于 Swift 工程只支持动态库的形式导入，但在 Cocoapods 1.9 中增加了新的特性 `use_frameworks! :linkage => :static` 支持以静态库形式导入，如果你是 Swift 的工程，那么可以试一下。本文还介绍了动态库与静态库的区别。

四、[抖音品质建设 - iOS启动优化《原理篇》]( https://juejin.cn/post/6887741815529832456  "抖音品质建设 - iOS启动优化《原理篇》") -- 来自掘金：字节跳动技术团队

面试官经常问一个问题：从用户点击图标开始，到用户看到第一帧图像，都经历了哪些过程。这篇文章将会给出非常全面的答案。想要做启动优化首先要了解 iOS 在启动时都做了哪些事情。文章首先介绍了一些基础概念，如：启动的种类、dyld、mmap、Page In等。随后介绍了 IPA 的构建流程，透露了如何基于 LLVM 插桩来实现无用代码检测。文章着重介绍了 dyld3 的启动流程。dyld3 都缓存了哪些内容？Rebase & Bind 各自是做什么的？启动终点应该定在哪里？这些内容是面试中常见的问题。

五、[58 同城 App 性能治理实践-iOS 启动时间优化]( https://mp.weixin.qq.com/s/wkK2UBvuUZW3Pf0Yd_3XTA) -- 来自公众号：58技术

这篇文章是 58同城 APP 做启动优化的实践整理。从启动耗时监控到启动治理文章都有介绍。文中介绍了如何横向对比两个 APP 的启动时间、如何进行动态库懒加载实现启动优化、Swift 符号如何收集等方案。对 APP 的启动优化实践有一定的参考意义。

六、[哈啰出行iOS App首屏秒开优化](https://mp.weixin.qq.com/s/5Ez2BrsyBgQ8aHZqlYtAjg) -- 来自公众号：哈啰技术

此篇文章与前两篇文章内容上稍有重叠，但是偏重于介绍图片及动画解码对 APP 启动的影响。本文提供了多个具有参考价值的案例，如：Lottie 框架在同步处理转码时的性能问题。作者提出了 Lottie 处理大图或者关键帧多张的图片阻塞主线程的问题，并给出了相应的处理方式。

***

### 网络优化

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)

网络优化大致可分为三个阶段：
1、请求前阶段：接口冷却，优先级调整、接口依赖、数据压缩、请求拦截

2、连接阶段：IP 直连、HTTPDNS、重试、不同网络环境的超时处理

3、数据处理阶段：数据解析、缓存

一、[全面理解DNS及HTTPDNS](https://juejin.cn/post/6844903987796246542 "全面理解DNS及HTTPDNS") -- 来自掘金：iosmedia

你有没有遇到过，某些地区的连接成功率很低，有时连接成功，有时连接不成功呢？如果你遇到这种情况那可能是 DNS 解析出现了问题。本文全面解析了 DNS 是什么，为什么会被劫持，为什么 HTTPDNS 可以解决这种问题，如果你有类似困惑，建议阅读本文，相信一定能收获满满。

二、[iOS IP 直连原理剖析](https://juejin.cn/post/6844903564960088071 "iOS IP 直连原理剖析") -- 来自掘金：joy_xx

HTTPDNS 是自研还是使用第三方的？如果自研的话会不会成本比较高呢？IP 直连可能适合，遇到 DNS 问题，但又不希望花费大量时间精力的解决方案。其本质就是服务器有多个 IP，app 内置多个 IP，如果连接成功，每次启动就去请求更新新的 IP 列表。

三、[网络请求优化之取消请求](https://juejin.cn/post/6844903736968478727 "网络请求优化之取消请求") -- 来自掘金：阿南

本文介绍了，我们在开发中一定会遇到的场景：销毁页面时，取消网络请求；同一接口短时间请求多次，做忽略处理；请求重试，防止网络抖动造成连接失败。

四、[iOS网络缓存扫盲篇](https://www.jianshu.com/p/fb5aaeac06ef "iOS网络缓存扫盲篇") -- 来自简书：iOS程序猿

iOS 系统会自动对 GET 请求进行缓存；同时提供了`NSURLCache`支持我们设置缓存路径和缓存大小，文中就如何控制缓存的有效性展开进行了讨论。

五、[移动端IM开发者必读(二)：史上最全移动弱网络优化方法总结](http://www.52im.net/thread-1588-1-1.html "移动端IM开发者必读(二)：史上最全移动弱网络优化方法总结") -- 来自即时通讯网

作者针对 IM 场景下弱网进行的一系列总结，文中提到了很多理论基础，提出自动重试时导致后台雪崩的重要因素的观点。本文篇幅较长，适合有一定网络底层基础的人阅读。

六、[iOS中的网络调试](https://juejin.cn/post/6844904185268273159 "iOS中的网络调试") -- 来自掘金：即刻团队

"开发 iOS 的过程中，有一件非常令人头疼的事，那就是网络请求的调试，无论是后端接口的问题，或是参数结构问题，你总需要一个网络调试的工具来简化调试步骤。" 本文是即刻团队进行网络调试的解决方案。

***

### 编译优化

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)

1、[iOS编译过程的原理和应用](https://blog.csdn.net/Hello_Hwc/article/details/53557308 "iOS编译过程的原理和应用") -- 来自 CSDN：黄文臣

做编译优化前，先了解下编译原理吧！该作者通过 iOS 的视角，白话了编译原理，通俗易懂。

2、[Xcode编译疾如风系列 - 分析编译耗时](https://cloud.tencent.com/developer/article/1817236 "Xcode编译疾如风系列 - 分析编译耗时") -- 来自腾讯社区：小菜与老鸟

在进行编译速度优化前，一个合适的分析工具是必要的，它能告诉你哪部分编译时间较长，让你发现问题，从而解决问题，本文介绍了几种分析编译耗时的方式，助你分析构建时间。该作者还有其他相关姊妹篇，建议前往阅读。

3、[iOS 微信编译速度优化分享](https://cloud.tencent.com/developer/article/1564372 "iOS 微信编译速度优化分享") -- 来自云+社区：微信终端开发团队

文章对编译优化由浅入深做了介绍。作者首先介绍了常见的现有方案，利用现有方案以及精简代码、将模板基类改为虚基类、使用 PCH 等方案做了部分优化。文章精彩的部分在于作者并没有止步于此，而是从编译原理入手，结合量化手段，分析出编译耗时的瓶颈。在找到问题的瓶颈后，作者尝试人工进行优化，但是效率较低。最终在 IWYU 基础上，增加了 ObjC 语言的支持，高效地处理了一部分多余的头文件。

4、[iOS编译速度如何稳定提高10倍以上之一](https://juejin.cn/post/6903407900006449160 "iOS编译速度如何稳定提高10倍以上之一") -- 来自掘金：Mr_Coder

美柚 iOS 的编译提效历程。作者对常见的优化做了分析，列举了各自的优缺点。有想做编译优化的可以参考这篇文章了解一下。对于业界的主流技术方案，别的技术文章往往只介绍优点，对方案的缺点谈的不够彻底。这篇文章从实践者的角度阐述了常见方案的优缺点，很有参考价值。文章介绍了双私有源二进制组件并与 ccache 做了对比，最后列出了方案支持的功能点。

5、[iOS编译速度如何稳定提高10倍以上之二](https://juejin.cn/post/6903408514778497031 "iOS编译速度如何稳定提高10倍以上之二") -- 来自掘金：Mr_Coder

作为上文的姊妹篇，本文详细介绍了双私有源二进制组件的方案细节以及使用方法。对该方案感兴趣的可以关注下。

6、[一款可以让大型iOS工程编译速度提升50%的工具](https://tech.meituan.com/2021/02/25/cocoapods-hmap-prebuilt.html "一款可以让大型iOS工程编译速度提升50%的工具") -- 来自美团技术团队：思琦 旭陶 霜叶

本文主要介绍了如何通过优化头文件搜索机制来实现编译提速，全源码编译效率提升 45%。文中涉及很多知识点，比如 hmap 文件的作用、Build Phases - Headers 中的 Public，Private，Project 各自是什么作用。文中详细分析了 podspec 创建头文件产物的逻辑以及 Use Header Map 失效的原因。干货比较多，可能得多读几遍。

***

### 卡顿优化

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)

1、[iOS卡顿监测方案总结](https://juejin.cn/post/6844903944867545096 "iOS卡顿监测方案总结")

文章总结了业界的很多卡顿监控技术。包括：FPS、runloop、子线程 Ping、CPU 占用率监测。文章中附带了作者参考和收集到的原文链接，以及部分相关上下游技术的文章。如果您想要做卡顿监控，阅读本文可以节省不少时间和精力。

2、[iOS 渲染原理解析](https://mp.weixin.qq.com/s/6ckRnyAALbCsXfZu56kTDw)

文章细致的介绍了图像渲染的流程。包括一些细小有趣的知识点，比如 CALayer 的 contents 保存了 bitmap 信息等。文中当然少不了对离屏渲染的介绍，包括离屏渲染的场景、离屏渲染的原因以及如何避免离屏渲染。文后附有小题目，可以让大家带着问题回顾文章，加深对知识的理解。

3、[UIView 动画降帧探究](https://mp.weixin.qq.com/s/EcVrrT1M4mI4f4d2b3qV0Q)

本文首先介绍为了降帧的目的：降低 GPU 的使用率，并介绍了为什么动画渲染对 GPU 有较大的影响。正文中主要介绍了降帧的方案：UIView animation 指定 `UIViewAnimationOptionPreferredFramesPerSecond30` 进行降帧、`CADisplayLink` 逐帧动画降帧。

4、[天罗地网？ iOS卡顿监控实战](https://juejin.cn/post/6844904005437489165 "天罗地网？ iOS卡顿监控实战") -- 来自掘金：进击的蜗牛君

本文利用 `ping` 方案，即每隔一段时间就去目标线程中检测状态，如果目标线程"运行良好"，则标记为正常，当一段时间 `ping` 均不正常时，上报目标线程的堆栈，此时认为目标线程发生了卡顿，作者已经做出了开源工具，方便大家深入研究。

5、[列表流畅度优化](https://juejin.cn/post/6844903656769208334 "列表流畅度优化") -- 来自掘金：Hello_Vincent

作者借鉴了 WWDC18 的相关 session，从实际角度出发，进行一次列表优化的旅程，从原因到解决办法，最后提出意见，称得上是一篇佳作。

6、[WWDC2016 Session笔记 - iOS 10 UICollectionView新特性](https://juejin.cn/post/6844903441416847374 "WWDC2016 Session笔记 - iOS 10 UICollectionView新特性
") -- 来自掘金：一缕殇流化隐半边冰霜

早在 WWDC16，官方针对 `UICollectionView` 已经做过优化教程，如果你还不知道，可以看一看这篇文章。

***

### 包大小优化

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)

1、[今日头条 iOS 安装包大小优化—— 新阶段、新实践](https://mp.weixin.qq.com/s/oyqAa8wKdioI5ZDG5LjkfA) -- 来自微信公众号：字节跳动技术团队

在多个渠道多次推荐的老文章了，再次推荐还是希望能跟大家一块打开思路，尤其在二进制文件的控制上，目前还有很多比较深入的手段去优化，资源的优化可能并不是全部的手段。

2、[今日头条优化实践： iOS 包大小二进制优化，一行代码减少 60 MB 下载大小](https://mp.weixin.qq.com/s/TnqAqpmuXsGFfpcSUqZ9GQ) -- 来自微信公众号：字节跳动技术团队

上篇文章的姊妹篇，也是大家比较熟悉的文章了。总而言之段迁移技术效果很明显，但是段迁移会带来一些其他的问题，比如文中提到的日志解析问题。我们在实践过程中也遇到了各种各样的小问题，一些二进制分析工具会失效，需要针对段迁移的 ipa 做适配。

3、[基于mach-o+反汇编的无用类检测](https://www.jianshu.com/p/c41ad330e81c "基于mach-o+反汇编的无用类检测") -- 来自简书：皮拉夫大王

很少在周报中推荐自己的文章，尤其是自己 2 年前的老文章。推荐这篇文章的原因是我在文中列举了 58 各个业务线的包大小占比分析。从数据中可以看出我们经过多年包大小治理后，资源的优化空间并不大，只能从二进制文件的瘦身上入手。可能很多公司的 APP 也有同样的问题，就是资源瘦身已经没有太大的空间了，这时我们就应该从二进制层面寻找突破口。文中工具地址：[Github WBBlades](https://github.com/wuba/WBBlades "Github WBBlades")

4、[Flutter包大小治理上的探索与实践](https://tech.meituan.com/2020/09/18/flutter-in-meituan.html "Flutter包大小治理上的探索与实践") -- 来自美团技术团队：艳东 宗文 会超

谈点新鲜的内容。作者首先对 Flutter 的包大小进行了细致的分析，并在双平台选择了不同的优化方案。在 Android 平台选择动态下发，而 iOS 平台则将部分非指令数据进行动态下发。通过修改 Flutter 的编译后端将 data 重定向输入到文件，从而实现了数据段与文本段的拆分。使用 Flutter 的团队可以关注下这个方案。

5、[iOS 优化 - 瘦身](https://mp.weixin.qq.com/s/wDcYvea5dTq0dh0PBwRu4A) -- 来自微信公众号：CoderStar

文章详细介绍了 APP 瘦身的技巧与方案，包括资源和代码层面。对图片压缩与代码的编译选项有深入的解释。方案比较全面，可以通过此文章检查 APP 瘦身是否还有哪些方案没有应用。

6、[科普：为什么iOS的APP比安卓大好几倍？](https://www.jianshu.com/p/6f2adc5aeb9a "科普：为什么iOS的APP比安卓大好几倍？") -- 来自简书：春暖花已开

前几篇文章已经将瘦身的技术介绍得比较完善了。接下来通过这篇文章回答下老板们经常会问到的问题：为什么 iOS 的包比安卓的大？是因为 iOS 的技术不如安卓吗？建议 iOS 程序员都看看这个问题，至少可以满足我们自己的好奇心。

***

### 内存优化

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)

内存优化可以从以下几点入手：

* 工具分析，可以利用 Xcode 自带的 Instruments 中的 leak、allocation，也可以利用 MLeaksFinder 等开源工具。找到内存泄漏、内存激增、内存不释放的位置。
* 利用 mmap，一种低内存的首选方案。
* 图片优化，经过第一步之后，一定会发现内存激增极有可能与图片相关。

1、[iOS的文件内存映射——mmap](https://www.jianshu.com/p/516e7ff6f251 "iOS的文件内存映射——mmap") -- 来自简书：落影loyinglin

mmap 一定是低内存方案的首选。文件映射，用于将文件或设备映射到虚拟地址空间中，以使用户可以像操作内存地址一样操作文件或设备，作者介绍了 mmap 原理并根据官方代码，整理了一个简单的 Demo，有兴趣的人还可以阅读下微信的开源仓库：MMKV。

2、[iOS图片加载速度极限优化—FastImageCache解析](http://blog.cnbang.net/tech/2578/ "iOS图片加载速度极限优化—FastImageCache解析") -- 来自博客：bang

在 app 中，图片在内存中占用比例相对较大，有没有办法优化缓存一些图片到磁盘中呢？答案是：FastImageCache。FastImageCache 是 Path 团队开发的一个开源库，用于提升图片的加载和渲染速度，让基于图片的列表滑动起来更顺畅，来看看它是怎么做的。

3、[Instruments学习之Allocations](https://www.jianshu.com/p/b617f16acb7f "Instruments学习之Allocations") -- 来自简书：Thebloodelves

详细介绍 Allocations 的使用，为你分析 app 内存助力。

4、[【基本功】深入剖析Swift性能优化](https://tech.meituan.com/2018/11/01/swift-compile-performance-optimization.html "[基本功]深入剖析Swift性能优化") -- 来自美团技术团队：亚男

Swift 已经是大势所趋，各个大厂都已经在做尝试和推广，所以内存优化也离不开 Swift。本文前半部分介绍了 Swift 的数据类型的内存分配情况，先了解 Swift 的内存基本原理才能在日常开发中提前避免问题的发生。

5、[Swift内存泄漏详解([weak self]使用场景)](https://www.jianshu.com/p/cb45b5e016ff "Swift内存泄漏详解([weak self]使用场景") -- 来自简书：码农淏

本文通过代码的方式列举了 Swift 中造成内存泄漏的一些情况，比较适合 Swift 的初学者，文章较短但是比较实用。OC 转 Swift 的同学可以关注下。

***

### 电量优化

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)

1、[iOS性能优化之耗电检测](https://www.diffit.cn/2020/09/03/EnergyDetection/ "iOS性能优化之耗电检测") -- 来自：杂货铺

文章介绍了耗电量检测的三种方式：Energy impact、Energy Log、sysdiagnose。 每种方案详细介绍了检测步骤。在 Energy Log 中提到了“当前台三分钟或后台一分钟 CPU 线程连续占用 80% 以上就判定为耗电，同时记录耗电线程堆栈供分析”，这对我们日常分析有一定的帮助。

2、[Analyzing Your App’s Battery Use](https://developer.apple.com/documentation/xcode/analyzing-your-app-s-battery-use "Analyzing Your App's Battery Use") -- 来自：Apple

苹果官方提供了一些性能监控的手段，通过 Xcode Organizer 可以查看 24 小时的性能数据，包括电量数据。

3、[iOS 性能优化：使用 MetricKit 2.0 收集数据](https://mp.weixin.qq.com/s/cbP0QlxVlr5oeTrf6yYfFw "iOS 性能优化：使用 MetricKit 2.0 收集数据") -- 来自老司机周报：Jerry4me

既然提到了官方的方案就不得不提到 MetricKit。本文介绍了什么是 MetricKit，如何使用以及 iOS 14 之后的新的数据指标。另外需要注意的是 MetricKit 是 iOS13 之后才支持的，并且并不能搜集全部用户的数据，只有共享 iPhone 分析的用户数据才能被收集。

4、[iOS进阶--App功耗优化](http://www.cocoachina.com/articles/21428 "iOS进阶--App功耗优化") -- 来自cocoachina：yyuuzhu 

直观上耗电大户主要包括：CPU、设备唤醒、网络、图像、动画、视频、动作传感器、定位、蓝牙。测试工具：Energy Impact、Energy Log，更加具体的信息查看本文。

5、[iOS耗电量和性能优化的全新框架](https://punmy.cn/2019/06/16/wwdc_417_metrics.html "iOS耗电量和性能优化的全新框架") -- 来自博客：Punmy

在 Session 417 中，苹果推出了三项新的电量和性能监测工具，分别用于开发阶段、内测阶段、以及线上阶段。相信通过本文，你会对你的 App 接下去的耗电量和性能优化的方向，有更好的计划。

6、[耗电优化的几点建议](https://lizhaobomb.github.io/2020/03/02/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%20-%20%E8%80%97%E7%94%B5%E4%BC%98%E5%8C%96/ "耗电优化的几点建议") -- 来自博客：Catalog

关于耗电优化的几点实操性的建议。

***

### Swift 指针、Swift 属性包裹器

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)

1、[Swift 中的指针使用]( https://onevcat.com/2015/01/swift-pointer/  "Swift 中的指针使用") -- 来自：onevcat

Swift 中指针使用场景并不常见，但是有些时候我们又不得不尝试去使用指针，因此还是需要对 Swift 的指针运用有一定的了解。这篇文章是喵神 15 年写的，并在 2020 年做了更新。文章对 C 指针和 Swift 的指针应用做了映射，对于有一定 C 指针基础的同学阅读比较友好。

2、[The 5-Minute Guide to C Pointers](https://denniskubes.com/2017/01/24/the-5-minute-guide-to-c-pointers/ "C语言指针5分钟教程") -- 来自：Dennis Kubes

喵神文章中推荐的 C 语言指针教程，如果对 C 指针不了解的话，直接切入到 Swift 的指针还是有一定的困难的。

3、[Swift5.1 - 指针Pointer](https://www.jianshu.com/p/8cff1ef20e8c "Swift5.1 - 指针Pointer") -- 来自简书：HChase

这篇文章根据 Swift 的类型给出了多种使用方法，查找用法非常方便。例如 malloc 之后如何填充字节、如何根据地址创建指针、如何进行类型转换等。如果在开发中需要使用 Swift 的指针，在不熟悉的情况下可以参考文中的小 demo。

4、[使用 Property Wrapper 为 Codable 解码设定默认值](https://onevcat.com/2020/11/codable-default/ "使用 Property Wrapper 为 Codable 解码设定默认值
") -- 来自：onevcat

在 Swift 中，json 转 model 可以使用 Codable，但因为其无法指定可选值的默认属性，在开发的过程中需要更冗余的代码进行解可选操作；onevcat 的这篇文章就利用 Property Wrapper 为 Codable 解码设定了默认值。此外我将其总结成了一个文件 [SSCodableDefault.swift](https://github.com/Tliens/SpeedySwift/blob/master/Example/SpeedySwift/SSCodableDefault.swift)，欢迎大家使用。

5、[What is a Property Wrapper in Swift](https://sarunw.com/posts/what-is-property-wrappers-in-swift/#custom-logic-over-swift-properties "What is a Property Wrapper in Swift") -- 来自：sarunw

属性包装器是一种包装属性以添加额外逻辑的新类型。作者先抛出问题，分析属性包装器出现之前如何对属性进行包装以及他遇到的问题，然后来利用属性包装器对属性进行逻辑包装，比较了二种方式的区别，简述了属性包装器的好处。

6、[Swift 5 属性包装器Property Wrappers完整指南](https://juejin.cn/post/6844904018121064456 "Swift 5 属性包装器Property Wrappers完整指南") -- 来自掘金：乐Coding

本文是使用属性包装器的一篇中文教程、可以结合 4、5 阅读。

***

### Swift 闭包

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[FBY展菲](https://github.com/fanbaoying)

1、[Swift 基于闭包的类型擦除](https://mp.weixin.qq.com/s/K1VfyOX96C4Hw2GxpcKnuw) -- 来自公众号：Swift社区

本文重点介绍在 Swift 中处理泛型时可能发生的一种情况，以及通常是如何使用基于**闭包的类型擦除技术**来解决这种情况。

2、[swift 闭包(闭包表达式、尾随闭包、逃逸闭包、自动闭包)](https://juejin.cn/post/6972560642427486238 "swift 闭包(闭包表达式、尾随闭包、逃逸闭包、自动闭包)") -- 来自掘金：NewBoy

关于 Swift 闭包的初级文章，内容整合了几乎所有 Swift 闭包的概念和用法。比较适合 Swift 初学者或者是从 OC 转向 Swift 的同学。

3、[Day6 - Swift 闭包详解 上](https://mp.weixin.qq.com/s/bE-Bt0VQ8aT3TtZz9EwfYg) -- 来自微信公众号： iOS成长指北

4、[Day7 - Swift 闭包详解 下](https://mp.weixin.qq.com/s/op8Kf3hOgmPHTXPiGioI0g) -- 来自微信公众号： iOS成长指北

Swift 闭包学习的两篇文章，也是包含了 Swift 的概念及用法，其中部分用法及概念更加细致。两篇文章是作者学习思考再输出的成果，因此在文章中有些作者的理解，这对我们学习是比较重要的，而且比较通俗易懂。

5、[Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html "Apple Document - Closures") -- 来自：Swift Document

[@zhangferry](zhangferry.com)：对于概念的理解官方文档还是非常有必要看的。Swift 里的闭包跟 C/OC 中的 Block，其他语言中的 Lambda 含义是类似的。Swift 与 OC 混编时，闭包与 Block 是完全兼容的。但就含义来说两者仍有区别，Block 更多强调的是匿名代码块，闭包则是除这之外还有真正的一级对象的含义。

***

### Swift 泛型

1、[Swift 进阶： 泛型](https://mp.weixin.qq.com/s/WOPbESx7YIAUes_1y3wyMw "Swift 进阶： 泛型") -- 来自公众号：Swift社区

[@FBY展菲](https://github.com/fanbaoying)：泛型是 Swift 最强大的特性之一，很多 Swift 标准库是基于泛型代码构建的。你可以创建一个容纳  Int 值的数组，或者容纳 String 值的数组，甚至容纳任何 Swift 可以创建的其他类型的数组。同样，你可以创建一个存储任何指定类型值的字典，而且类型没有限制。

2、[Swift 泛型解析](https://juejin.cn/post/7000916678150193159/ "Swift 泛型解析") -- 来自掘金：我是熊大

[@我是熊大](https://juejin.cn/user/1151943916921885)：本文通俗易懂的解析了什么是泛型，泛型的应用场景，泛型和其他 Swift 特性摩擦出的火花，最后对泛型进行了总结。

3、[WWDC2018 - Swift 泛型 Swift Generics](https://juejin.cn/post/6844903623185399822/ "WWDC2018 - Swift 泛型 Swift Generics") -- 来自掘金：西野圭吾

[@我是熊大](https://juejin.cn/user/1151943916921885)：本文回顾了 Swift 中对于泛型支持的历史变更，可以了解下泛型不同版本的历史以及特性。

4、[Swift 性能优化(2)——协议与泛型的实现](http://chuquan.me/2020/02/19/swift-performance-protocol-type-generic-type/ "Swift 性能优化(2)——协议与泛型的实现") -- 来自博客：楚权的世界

[@我是熊大](https://juejin.cn/user/1151943916921885)：本文探讨了协议和泛型的底层实现原理，文中涉及到编译器对于 Swift 的性能优化，十分推荐阅读。

5、[Swift 泛型底层实现原理](http://chuquan.me/2020/04/20/implementing-swift-generic/ "Swift 泛型底层实现原理") -- 来自博客：楚权的世界

[@皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)：本文介绍了 Swift 相关的底层原理，干货较多。例如 VWT 的作用、什么是 Type Metadata、Metadata Pattern 等等。如果有些概念不是很清楚的话可以阅读文章下面的参考文献。

6、[Generics Manifesto](https://github.com/apple/swift/blob/main/docs/GenericsManifesto.md "Generics Manifesto") -- 来自 Github：Apple/Swift

[@zhangferry](https://zhangferry.com)：[四娘](https://kemchenj.github.io/)对这篇官方说明进行了翻译，也可以直接阅读翻译版：[【译】Swift 泛型宣言](https://kemchenj.github.io/2017-11-26/?highlight=%E6%B3%9B%E5%9E%8B "[译]Swift 泛型宣言")。这份文档介绍了如何建立一个完善的泛型系统，以及 Swift 语言在发展过程中，不断补充的那些泛型功能。

***

### RxSwift

1、[RxSwift 中文文档](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/ "RxSwift 中文文档") -- 来自RxSwift 中文文档

[@我是熊大](https://juejin.cn/user/1151943916921885)：其实 RxSwift 的中文文档完善度很高，其目的就是帮助 iOS 开发人员快速上手 RxSwift，其中不仅讲了核心成员使用，还附带了精选的 demo 以及生态架构的相关文章。

2、[RxSwift 核心实现原理](http://chuquan.me/2020/08/24/rxswift-core-implement/ "RxSwift 核心实现原理") -- 来自博客：楚权的世界

[@我是熊大](https://juejin.cn/user/1151943916921885)：泛型和闭包，让 RxSwift 诞生，这篇文章带你还原 RxSwift 的设计现场，深入浅出，帮助你更深入的了解RxSwift 的原理。

3、[初识RxSwift及使用教程](https://developer.aliyun.com/article/233478?spm=a2c6h.13262185.0.0.3c6263e6j04OZD "初识RxSwift及使用教程")  -- 来自：韩俊强的博客

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：RxSwift 是 Swift 函数响应式编程的一个开源库。初次接触的同学可能会提问为什么要用 RxSwift。因此可以看看这篇文章。作为初学者，通过阅读这篇文章感觉 RxSwift 使逻辑离散的代码变的聚合，逻辑更加清晰。当然，RxSwift 不止于此，纸上得来终觉浅，更多的优势可能只有深入使用才会有所体会。

4、[RxSwift使用教程大全](https://developer.aliyun.com/article/233477?spm=a2c6h.13262185.0.0.3c6263e6hxn23r "RxSwift使用教程大全") -- 来自：韩俊强的博客

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：RxSwift 的教程大全，罗列了比较多的 RxSwift 使用方法。

5、[使用 RxSwift 进行响应式编程](https://academy.realm.io/cn/posts/altconf-scott-gardner-reactive-programming-with-rxswift/ "使用 RxSwift 进行响应式编程") -- 来自：AltConf

[@zhangferry](https://zhangferry.com)：这是 [AltConf 2016](http://altconf.com/) 中的一期讲座内容，整理翻译成了中文。虽然是2016年的内容，但RxSwift的基本概念是不会改变的，这篇内容 Scott Gardner 将带大家走入到响应式编程的世界当中，并告诉大家一个简单的方法来开始学习 RxSwift。

6、[RxSwift vs PromiseKit](https://medium.com/@DianQK/rxswift-vs-promisekit-5c617fc1b789 "RxSwift vs PromiseKit") -- 来自：靛青DKQing

[@zhangferry](https://zhangferry.com)：如果仅是为了处理回调地狱就选择引入 RxSwift，就有些大材小用了，处理回调地狱用 PromiseKit 就可以。RxSwift 里的回调处理只是附加功能，其真正的思想是响应式，PromiseKit 非响应式框架。**响应式是一种面向数据流和变化传播的编程范式**，不只是异步的网络请求，像是点击行为，文本框不同的输入都是数据流的一种形式，概念的理解在学习响应式编程中尤为重要。文中通过一个简单的例子，来说明 PromiseKit 不具备流的特性。

***

### Combine

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)

1、[深入浅出 Apple 响应式框架 Combine](https://www.infoq.cn/article/eaq01u5jevuvqfghlqbs "深入浅出 Apple 响应式框架 Combine") -- 来自 InfoQ：青花瓷的平方

[@我是熊大](https://juejin.cn/user/1151943916921885)：本文是 Joseph Heck 编写的教程的中文版本，适合新手阅读，学习 Combine。

2、[Combine debugging using operators in Swift](https://www.avanderlee.com/swift/combine-error-handling/ "Combine debugging using operators in Swift") -- 来自博客：avanderlee

[@我是熊大](https://juejin.cn/user/1151943916921885)：使用 RxSwift 会产生大量的不可读堆栈信息，这也是开发人员放弃 RxSwift 的原因之一，在 Combine 中这一点依旧如此。但好在有一些提示和技巧可以改善，本文就介绍了几种方式。

3、[Combine: Getting Started](https://www.raywenderlich.com/7864801-combine-getting-started#toc-anchor-011 "Combine: Getting Started")  -- 来自：raywenderlich

[@我是熊大](https://juejin.cn/user/1151943916921885)：Swift Combine 的硬核教程，作者利用 UnsplashAPI 带大家实现了一个简易的 App，让我们学习了解如何使用 Combine 的发布者和订阅者来处理事件流、合并多个发布者等。

4、[Combine - 介绍、核心概念](https://zhuanlan.zhihu.com/p/154621268 "Combine - 介绍、核心概念") -- 来自知乎：Talaxy

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：提到响应式编程就不得不说 Combine。这篇文章介绍了Combine 的相关概念和用法。包括发布者-订阅者的生命周期、发布者订阅者操作者的概念等等。

5、[Apple 官方异步编程框架：Swift Combine 应用](https://nemocdz.github.io/post/apple-官方异步编程框架swift-combine-应用/ "Apple 官方异步编程框架：Swift Combine 应用") -- 来自：Nemocdz's Blog

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：本文通过例子和代码介绍了 Combine 的用法，适合了解 Combine 相关概念和基础的同学阅读。

6、[RxSwift to Combine Cheatsheet](https://github.com/CombineCommunity/rxswift-to-combine-cheatsheet "RxSwift to Combine Cheatsheet") -- 来自 GitHub：CombineCommunity

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：RxSwift 与 Combine 的对照关系，如果你想从 RxSwift 过渡到 Combine，可以参考此文章。

***

### Swift Protocol

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)

1、[Swift 协议](https://swift.bootcss.com/02_language_guide/21_Protocols  "Swift 协议") -- 来自：Swift 编程语言中文教程

[@我是熊大](https://juejin.cn/user/1151943916921885)：在学习面向协议编程前，先了解 Swift 中的协议该如何使用。

2、[面向协议编程与 Cocoa 的邂逅 (上)](https://onevcat.com/2016/11/pop-cocoa-1/  "面向协议编程与 Cocoa 的邂逅 (上)") -- 来自：OneV's Den

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：文章先通过引入例子介绍 OOP 的核心思想：封装、继承。随后介绍 OOP 中 “Cross-Cutting Concerns”、多继承的菱形缺陷问题、动态派发的安全问题这三大困境。面向协议编程可以解决除菱形问题外的其他问题。

3、[面向协议编程与 Cocoa 的邂逅 (下)](https://onevcat.com/2016/12/pop-cocoa-2/  "面向协议编程与 Cocoa 的邂逅 (下)") -- 来自：OneV's Den

[@我是熊大](https://juejin.cn/user/1151943916921885)：作者使用协议演示了基于 Protocol 的网络请求，然后又回答了工作中的使用场景，正如作者所言："通过面向协议的编程，我们可以从传统的继承上解放出来，用一种更灵活的方式，搭积木一样对程序进行组装"。

4、[Swift Protocol 详解 - 协议&面向协议编程](https://juejin.cn/post/6844903502817263630 "Swift Protocol 详解 - 协议&面向协议编程") -- 来自掘金：RickeyBoy

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：文章概念性的东西较多，本文先介绍了协议的基本使用方法，主要介绍耦合相关的概念，例如耦合的 5 个级别、耦合带来的问题、依赖翻转和协议解耦等。

5、[如果你还在用子类（Subclassing），那就不对了](https://www.jianshu.com/p/80bd6633ec7c?utm_campaign=hugo&utm_medium=reader_share&utm_content=note "如果你还在用子类（Subclassing），那就不对了") -- 来自简书：97c49dfd1f9f 

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：本文主要介绍了面向协议、面向对象、函数式编程的优缺点。OC->Swift 不仅仅是语法上的变化，想想大家项目中的 xxxBasexxx.m，如果用 Swift开发需要避免再出现此类情况。

6、[Swift 中的面向协议编程：是否优于面向对象编程？](https://swift.gg/2018/12/03/pop-vs-oop/  "Swift 中的面向协议编程：是否优于面向对象编程？") -- 来自：SwiftGG

[@我是熊大](https://juejin.cn/user/1151943916921885)：引用作者的一句话：”30 年的开发经验，让我能够平心静气地说，你应该了解协议和 POP。开始设计并书写你自己的 POP 代码吧“。

***

### Swift Tips

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://github.com/Tliens)、[东坡肘子](https://www.fatbobman.com)

1、[【iOS】Swift Tips - （一）](https://juejin.cn/post/6973623744119963679 "【iOS】Swift Tips - （一）") -- 来自掘金：Layer

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：文章是作者的学习笔记，作者将 objccn.io/ 的内容整理出来，一共 6 篇，适合在地铁上阅读。在这篇文章中主要介绍了柯里化、多元组、操作符等写法和用途。

2、[十个技巧让你成为更加优秀的 Swift 工程师](https://zhuanlan.zhihu.com/p/43119391 "十个技巧让你成为更加优秀的 Swift 工程师") -- 来自知乎：Summer

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：学习 Swift 不光要能写 Swift 代码，更要优雅地使用 Swift，这也是本期博客主题的目的。这篇文章介绍了巧用扩展、泛型、计算属性等优化代码，在初学者看来是比较有意思的。

3、[写更好的 Swift 代码：技巧拾遗](https://juejin.cn/post/7012541709561102367 "写更好的 Swift 代码：技巧拾遗") -- 来自掘金：OldBirds

[@东坡肘子](https://www.fatbobman.com)：作者在文章中介绍了几个很实用的 Swift 使用技巧，包括：通过前缀避免命名冲突、快速交换值、@discardableresult、访问控制等，对日常的开发很有帮助。

4、[Swift：where关键词使用](https://juejin.cn/post/7017605307593392159 "Swift：where关键词使用") -- 来自掘金：season_zhu

[@东坡肘子](https://www.fatbobman.com)：本文介绍了 where 在 Swift 中的几个使用场景，除了应用于 for 循环外，还包括泛型约束、指明类型等。有助于更好的理解在不同上下文中的 where 用法。

5、[Swift - 使用Color Literal实现代码中颜色的智能提示（Xcode自带功能）](https://www.hangge.com/blog/cache/detail_1902.html "Swift - 使用Color Literal实现代码中颜色的智能提示（Xcode自带功能）") -- 来自航歌

[@我是熊大](https://github.com/Tliens)：Color Literal 让颜色赋值可视化。

6、[【译】使用Swift自定义运算符重载](https://juejin.cn/post/6844903926232252424 "【译】使用Swift自定义运算符重载") -- 来自掘金：shankss

[@我是熊大](https://github.com/Tliens)：有没有想过 “+”，“-”，“??” 底层是怎么实现的？想不想自己也实现一个特有的运算符，如：“-->”，这篇文章带你一起探究。

***

### JSON&Model 转换

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)、[东坡肘子](https://www.fatbobman.com)

1、[或许你并不需要重写 init(from:) 方法](https://kemchenj.github.io/2018-07-09/ "或许你并不需要重写 init(from:) 方法") -- 来自：kemchenj

[@东坡肘子](https://www.fatbobman.com)：Codable 作为 Swift 的特性之一是很注重安全，也很严谨的，这就导致了它在实际使用时总会有这样那样的磕磕绊绊，我们不得不重写 `init` 方法去让它跟外部环境融洽地共存。本文介绍了一种通过重载 `decodeIfPresent` 方法以实现应对特殊类型的思路。从某种程度上来说，作者认为这甚至是比 Objective-C 的消息机制更加灵活的一种函数声明机制，而且它的影响范围是有限的，不容易对外部模块造成破坏（别声明为 open 或者 public 就没问题）。

2、[使用 Property Wrapper 为 Codable 解码设定默认值](https://onevcat.com/2020/11/codable-default/ "使用 Property Wrapper 为 Codable 解码设定默认值") -- 来自：onevcat

[@东坡肘子](https://www.fatbobman.com)：本文介绍了一个使用 Swift Codable 解码时难以设置默认值问题，并利用 Property Wrapper 给出了一种相对优雅的解决方式，来在 key 不存在时或者解码失败时，为某个属性设置默认值。这为编解码系统提供了更好的稳定性和可扩展性。最后，对 enum 类型在某些情况下是否胜任进行了简单讨论。

3、[2021 年了，Swift 的 JSON-Model 转换还能有什么新花样](https://zhuanlan.zhihu.com/p/351928579?ivk_sa=1024320u "2021 年了，Swift 的 JSON-Model 转换还能有什么新花样") -- 来自知乎：非著名程序员，作者 明林清

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：本文主要介绍 `ExCodable` 的特性和使用方法。在文章开头先介绍了常见的 JSON 转模型的几种方式，并对这些方式各自的优缺点进行了总结，随后引出 `ExCodable` 的特性及使用方法。

4、[json 解析有什么可说道的](https://mp.weixin.qq.com/s/_jFHgAP0vKx1Cv9XGkh_DA "json 解析有什么可说道的") -- 来自公众号：码农哈皮

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：文章开头先介绍了什么是 JSON。正文主要篇幅在介绍 SwiftyJSON 和 YYModel 的实现方案。文章最后引出了 HandyJSON，HandyJSON 是基于借助 `metadata` 结构来实现 JSON 转 Model 的。在这里额外提一句，如何推断 `metadata` 的结构，可以参考 [GenMeta.cpp](https://github.com/apple/swift/blob/main/lib/IRGen/GenMeta.cpp "GenMeta.cpp ") 中每个结构的 layout 函数。

5、[Swift中Json转Model的便捷方式](https://juejin.cn/post/7019910939340193805/ "Swift中Json转Model的便捷方式") -- 来自掘金：我是熊大

[@我是熊大](https://github.com/Tliens)：本文介绍 JSON、Model、Data、Dict 相互转换的小技巧和代码段，适合在实际工作中使用。

6、[Swift 码了个 JSON 解析器(一)](https://zhuanlan.zhihu.com/p/364032254 "Swift 码了个 JSON 解析器(一)") -- 来自知乎：OldBirds

[@我是熊大](https://github.com/Tliens)：正如作者所言，码了个 JSON 解析器，感兴趣的可以看一下。

***

### SIL

SIL：Swift Intermediate Language，SIL 是高级别的中间语言，SIL 由 **SILGen** 生成并由 **IRGen** 转为 LLVM IR ，SIL 会对 Swift 进行较高级别的语义分析和优化。我们看到的 @ 开头修饰的代码基本都属于 SIL 范畴。

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)、[东坡肘子](https://www.fatbobman.com)

1、[Swift的高级中间语言：SIL](https://www.jianshu.com/p/c2880460c6cd "Swift的高级中间语言：SIL") -- 来自简书：sea_biscute

[@东坡肘子](https://www.fatbobman.com)：在 LLVM 的官方文档中对 Swift 的编译器设计描述如下： Swift 编程语言是在 LLVM 上构建，并且使用 LLVM IR 和 LLVM 的后端去生成代码。但是 Swift 编译器还包含新的高级别的中间语言，称为 SIL。SIL 会对 Swift 进行较高级别的语义分析和优化。 本文将分析一下 SIL 设计的动机和 SIL 的应用，包括高级别的语义分析，诊断转换，去虚拟化，特化，引用计数优化，TBAA（Type Based Alias Analysis）等。并且会在某些流程中加入对 SIL 和 LLVM IR 对比。

2、[一文看破Swift枚举本质](https://mp.weixin.qq.com/s/Gx7L_Ev0DV19mLYMnH-R1Q "一文看破Swift枚举本质") -- 来自：狐友技术团队

[@东坡肘子](https://www.fatbobman.com)：SIL 在实际工作中的应用举例。通过分析内存布局、查看 SIL 源码等方式来探索一下枚举的底层到底是什么样子的。在 Swift 中枚举不仅仅只是一个用来区分类型的常量了，枚举的功能被大大的加强。枚举可以设置原始值，添加关联值，甚至可以添加计算属性（不能添加存储属性），定义方法，实现协议，其功能仅次于一个 Class 对象了，那么 Swift 的枚举到底是怎样实现这些功能的呢？

3、[Swift Intermediate Language 初探](https://zhuanlan.zhihu.com/p/101898915 "Swift Intermediate Language 初探") -- 来自简书：sea_biscute

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：文章简单介绍了 SIL 以及 SIL 在 LLVM 架构中的位置。正文部分作者通过 SIL 分析来解释 extension 中 protocol 函数和对象中的 protocol 函数调用选择的问题。

4、[Swift编译器中间码SIL](https://woshiccm.github.io/posts/Swift%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%AD%E9%97%B4%E7%A0%81SIL/ "Swift编译器中间码SIL") -- 来自博客：roy's blog

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：作者首先介绍了 SIL 的设计初衷以及与 LLVM IR 的区别。文中还介绍了 SSA（ static single-assignment）中“代”的概念以及 SSA 的益处。SIL 是命名函数的集合，SIL 源文件为 Module，通过 Module 可以遍历 Module 中的函数。

5、[Swift Intermediate Language —— A high level IR to complement LLVM](https://llvm.org/devmtg/2015-10/slides/GroffLattner-SILHighLevelIR.pdf "Swift Intermediate Language —— A high level IR to complement LLVM") -- 来自：Joe Groff 和 Chris Lattner

[@我是熊大](https://github.com/Tliens)：在 LLVM 开发人员会议上 Groff 和 Chris Lattner 通过简报的方式对 SIL 进行了详细的介绍。内容包括：为什么要使用 SIL、SIL 的设计逻辑、Swift 对 SIL 的使用等内容。尽管简报为英文，但主要以代码和图表为主，对了解 SIL 的设计动机和设计原理有很大的帮助。

***

### Swift 关键字

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)、[东坡肘子](https://www.fatbobman.com)

在还没有学习 Swift 时，听过好几次部门内关于 Swift 的分享。依稀记得在分享会上听到了各种各样的新颖的概念，见到一些在 OC 中没有见过的关键字。希望本次主题能为 OC 的同学扫清一些学习 Swift 的障碍。

1、[Swift-29个关键字，助力开发（万字长文）](https://juejin.cn/post/6844904112119611399 "Swift-29个关键字，助力开发（万字长文）") -- 来自掘金：SunshineBrother

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：推荐新手阅读，对 Swift 比较熟悉的同学可以简单浏览校验下是否有不清楚的概念。文中有对应的示例代码，帮助大家理解。

2、[Swift 的闭包为什么选用 in 关键字？](https://www.zhihu.com/question/53539254 "Swift 的闭包为什么选用 in 关键字？") -- 来自知乎

[@皮拉夫大王](https://www.jianshu.com/u/739b677928f7)：Swift 闭包为什么用 in 可能很多同学都没有思考过。这个问题比较有意思，信息量也不是很密集，也比较轻松。该话题有人列出了苹果工程师对此的解释。

3、[细说 Swift 4.2 新特性：Dynamic Member Lookup](https://juejin.cn/post/6844903621306351624 "细说 Swift 4.2 新特性：Dynamic Member Lookup") -- 来自掘金：没故事的卓同学

[@东坡肘子](https://www.fatbobman.com)：`@dynamicMemberLookup` 中文可以叫动态查找成员。在使用 `@dynamicMemberLookup` 标记了对象后（对象、结构体、枚举、protocol），实现了 `subscript(dynamicMember member: String)` 方法后我们就可以访问到对象不存在的属性。如果访问到的属性不存在，就会调用到实现的 `subscript(dynamicMember member: String)` 方法，key 作为 member 传入这个方法。

4、[解析 Swift 中的 @discardableResult](https://xie.infoq.cn/article/fef30fd533cdff4278f0a85ff "解析 Swift 中的 @discardableResult") -- 来自：SwiftMic

[@东坡肘子](https://www.fatbobman.com)：`@discardableResult` 属性可能很少被人熟知，但是对于想消除方法返回值未被使用的警告来说的话，该属性还是很有用的，只需要在对应方法前添加 `@discardableResult` 属性即可。但是，还是要考虑是否真的需要忽略该类警告，因为有些情况下及时处理返回结果可能是一种更好的解决方案。

5、[“懒”点儿好](https://swift.gg/2016/03/25/being-lazy/ "“懒”点儿好") -- 来自：SwiftGG

[@我是熊大](https://github.com/Tliens)：这是一个优化的小技巧--使用 lazy 关键字，可以用于属性、闭包初始化等场景；不仅如此，就连 let 修饰的常量，默认也是 lazy 的，还有其他相关的 lazy 小技巧，推荐阅读。

6、[访问控制](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/26_access_control "访问控制") -- 来自：SwiftGG

[@我是熊大](https://github.com/Tliens)：在 Swift 中，类、结构体、协议、属性、方法默认访问级别都是 internal，此外还有更多的访问级别需要我们了解，尤其是在做组件、模块时；学好关键字助你设计更好的代码。

***

### Vision

Vision 是苹果在 WWDC 2017 推出的图像识别框架。与 Core Image、AV Capture 相比，Vision 在耗电量、耗时、精确度上表现优异。

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)、[东坡肘子](https://www.fatbobman.com)

1、[使用 Vision 框架对图像进行分类](https://developer.apple.com/documentation/vision/classifying_images_with_vision_and_core_ml "使用 Vision 框架裁剪和缩放照片") -- 来自：Apple

[@我是熊大](https://github.com/Tliens)：本文演示了如何使用 Vision 和 Core ML 对图像进行识别并分类，附 Apple 官方 Demo。

2、[识别视频流中的对象](https://developer.apple.com/documentation/vision/recognizing_objects_in_live_capture "识别视频流中的对象") -- 来自：Apple

[@我是熊大](https://github.com/Tliens)：直接识别来自相机中的视频流，实时识别物体，本文附 Apple 官方 Demo。

3、[Swift之Vision 图像识别框架](https://juejin.cn/post/6844903576821760014#heading-1 "Swift之Vision 图像识别框架") -- 来自掘金：RunTitan

[@皮拉夫大王](https://juejin.cn/user/281104094332653)：Vision 有很多应用场景，比如人脸检测、图像对比、二维码条形码检测、文字检测、目标跟踪等。每种使用场景文章都列举了代码样例。

5、[用苹果官方 API 实现 iOS 备忘录的扫描文稿功能](https://www.fatbobman.com/posts/docScaner/ "用苹果官方 API 实现 iOS 备忘录的扫描文稿功能") -- 来自：东坡肘子

[@东坡肘子](https://www.fatbobman.com/)：本文将介绍如何通过 VisionKit、Vision、NaturalLanguage、CoreSpotlight 等系统框架实现与备忘录扫描文稿类似的功能。

6、[理解 Vision 框架中的图片技术](https://juejin.cn/post/6844903869881778183 "理解 Vision 框架中的图片技术") -- 来自掘金：RickeyBoy

[@东坡肘子](https://www.fatbobman.com/)：本文主要介绍了 Vision 框架在图像技术方面的一些酷炫功能，并一定程度上阐述了其原理。

***

### Swift 三方仓库

整理编辑：[我是熊大](https://juejin.cn/user/1151943916921885)、[东坡肘子](https://www.fatbobman.com/)

1、[Alamofire的基本用法](https://juejin.cn/post/6875140053635432462 "Alamofire 的使用 - 基本用法") -- 来自掘金：Lebron

[@我是熊大](https://github.com/Tliens)：Alamofire 是 AFNetWorking 原作者写的，Swift 版本相比 AFN 更加完善，本文介绍了 Alamofire 基本用法，很全面，适合精读；作者还有一篇[高级用法](https://juejin.cn/post/6875140780680282125 "Alamofire 高级用法")，推荐阅读。

2、[Kingfisher源码解析](https://juejin.cn/post/6844904015738699790 "Kingfisher源码解析") -- 来自掘金：李坤

[@我是熊大](https://github.com/Tliens)：Kingfisher 对标 OC 中的 SDWebImage，作者是大名鼎鼎的王巍，本文是 Kingfisher 源码解析系列的总结，推荐阅读。

3、[iOS SnapKit架构之道](https://rimson.top/2019/09/04/ios-snapkit-1/ "iOS SnapKit架构之道") -- 来自博客：Rimson

[@我是熊大](https://github.com/Tliens)：SnapKit 在 Swift 中的页面布局的地位，相当于 OC 中的 Masonry，使用起来几乎一模一样，本文作者详细梳理了 Snapkit 布局的过程和原理。

4、[第三方图表库Charts使用详解](https://www.hangge.com/blog/cache/detail_2116.html "第三方图表库Charts使用详解") -- 来自航歌：hangge

[@东坡肘子](https://www.fatbobman.com/)：Charts 是一个功能强大的图表框架，使用 Swift 编写。是对 Android 上大名鼎鼎的图表库 MPAndroidChart 在苹果生态上的移植。作者 hangge 通过大量的范例代码对 Charts 的使用进行了相近地说明。

5、[访问 SwiftUI 内部的 UIKit 组件](https://mp.weixin.qq.com/s/xYKGs3FkrlI_9pq1cdnC5Q "访问 SwiftUI 内部的 UIKit 组件") -- 来自 Swift花园：猫克杯

[@东坡肘子](https://www.fatbobman.com/)：抛开 SwiftUI 尚不完备的工具不说，SwiftUI 的确因其构建 UI 的便捷性给开发者带来了兴奋。有一个令人欣慰的事实是，许多 SwiftUI 组件实际上是基于 UIKit 构建的。本文将带你探索一个令人惊讶的 SwiftUI 库，它叫 Introspect 。利用它，开发者能够访问 SwiftUI 组件底层的 UIKit 视图。

***

### Swift 三方仓库

整理编辑：[皮拉夫大王在此](https://www.jianshu.com/u/739b677928f7)、[我是熊大](https://juejin.cn/user/1151943916921885)、[东坡肘子](https://www.fatbobman.com)

1、[第三方日期处理库SwiftDate使用详解](https://www.hangge.com/blog/cache/detail_2222.html "@hangge｜第三方日期处理库SwiftDate使用详解") -- 来自航歌：hangge

[@东坡肘子](https://www.fatbobman.com/)：SwiftDate 是在所有苹果平台，甚至在 Linux 和 Swift 服务器端框架（如 Vapor 或 Kitura ）上操作和显示日期和时区的权威工具链。在 CocoaPods 上有超过 300 万的下载量。SwiftDate 功能强大，无论是简单的日期操作，还是复杂的业务逻辑都能满足。本文将对 SwiftDate 的使用方法做详尽说明。

2、[搞事情之 Vapor 初探](https://juejin.cn/post/6844903834659667981 "@PJHubs｜搞事情之 Vapor 初探") -- 来自掘金：PJHubs

[@东坡肘子](https://www.fatbobman.com/)：Vapor 是一个基于 Swift 语言的开源 Web 框架，可用于创建 RESTful API、网站和使用 WebSockets 的实时应用。在核心框架之外，Vapor 还提供了 ORM 、模板语言，以及用户身份验证和授权模块。本文主要记录了第一次上手 Vapor 所遇到的问题、思考和总结。

3、[用 Publish 创建博客](https://www.fatbobman.com/tags/publish/ "@东坡肘子｜用 Publish 创建博客") -- 来自肘子的Swift记事本：东坡肘子

[@东坡肘子](https://www.fatbobman.com/)：Publish 是一款专门为 Swift 开发者打造的静态网站生成器。它使用 Swift 语言构建整个网站，并支持主题、插件和其他大量的定制选项。本系列文章将通过三个篇幅分别介绍 Publish 的基本用法、主题定制以及插件开发。

4、[Using Realm and Charts with Swift 3 in iOS 10](https://medium.com/@skipadu/using-realm-and-charts-with-swift-3-in-ios-10-40c42e3838c0#.2gyymwfh8 "@Sami Korpela｜Using Realm and Charts with Swift 3 in iOS 10") -- 来自：Sami Korpela

[@我是熊大](https://github.com/Tliens)：一个十分强大并且是纯 Swift 的图表相关的开源框架 -- Charts。本文作者利用 Swift 中的轻量级数据库 Realm 和 Charts，构建了一个 Demo。篇幅较长，适合新手，但美中不足的是：Demo 基于 Swift 3。此外我早期写过一篇关于 Realm 的实践代码的文章：[如何降低Realm数据库的崩溃](https://juejin.cn/post/6844904143501557773 "@我是熊大｜如何降低Realm数据库的崩溃")，有兴趣可以看一下。

5、[今天我们来聊一聊WebSocket（iOS/Golang）](https://juejin.cn/post/6844904062408720391 "@齐舞647｜今天我们来聊一聊WebSocket（iOS/Golang）") -- 来自掘金：齐舞647

[@我是熊大](https://github.com/Tliens)：Starscream swift 中的 7k+ star 的 socket 开源库，本文作者利用 GO 和 Starscream，模拟了客户端和服务端 websocket 的交互过程，建议对 Socket 感兴趣的阅读。

6、[Hero Usage Guide](https://github.com/HeroTransitions/Hero/wiki/Usage-Guide "Hero Usage Guide") -- 来自：Hero官方

[@我是熊大](https://github.com/Tliens)：Hero 是我用过的最好的转场动画，没有之一，20k+ star 的成绩也表明了它在转场动画的地位；Hero 应该能满足绝大部分需求，这是它的官方使用手册。

***

### Swift 字符串

整理编辑：[东坡肘子](https://www.fatbobman.com)、[我是熊大](https://juejin.cn/user/1151943916921885)

1、[Swift 字符串性能问题](https://blog.jerrychu.top/2020/11/29/Swift字符串/ "@JerryChu：Swift 字符串性能问题") -- 来自：JerryChu

[@东坡肘子](https://www.fatbobman.com/)：本文的作者在处理一道 LeetCode 算法题时碰到了 Swift 字符串遍历超时的状况，通过分析 Array 同 String 之间遍历机制的不同，最终获得了优化 String 遍历效率的方法。

2、[Swift 的字符串为什么这么难用？](https://juejin.cn/post/6844903962450067469 "@四娘：Swift 的字符串为什么这么难用？") -- 来自掘金：四娘

[@东坡肘子](https://www.fatbobman.com/)：在其它语言里一个语句就能解决的字符串操作在 Swift 中需要多个，但这些其实都是 Swift 有意而为之的设计。本文通过对 SE-0265 Offset-Based Access to Indices, Elements, and Slices 提案的讲解，让开发者了解 Swift 字符串背后的部分设计思路。

3、[WWDC 2021 新 Formatter API：新老比较及如何自定义](https://www.fatbobman.com/posts/newFormatter/ "@东坡肘子：WWDC 2021 新 Formatter API：新老比较及如何自定义") -- 来自：东坡肘子

[@东坡肘子](https://www.fatbobman.com/)：在 Swift 中开发者通过使用 Formatter ，可以让很多常用类型的数据都转换成可格式化字符串。在 WWDC 2021 中，苹果推出了使用 Swift 编写的全新 Formatter API。本文通过介绍如何创建符合新 API 的 Formatter，让读者从另一个角度了解新 Formatter API 的设计机制；并对新旧两款 API 进行比较。

4、[Swift 正则表达式完整教程](https://juejin.cn/post/6844903894066151431 "@SunshineBrother：Swift 正则表达式完整教程") -- 来自掘金：SunshineBrother

[@我是熊大](https://github.com/Tliens)：如何在 Swift 中使用正则表达式，本文做了详细描述，操作字符串时应该会用得到。

5、[SwiftString](https://github.com/amayne/SwiftString "GitHub：SwiftString") -- 来自：GitHub

[@我是熊大](https://github.com/Tliens)：SwiftString 是一个轻量级的字符串扩展，功能丰富且强大，GitHub star 1.6k+。

***

### 音视频仓库

整理编辑：[我是熊大](https://juejin.cn/user/1151943916921885)、[东坡肘子](https://www.fatbobman.com)

1、[适配 SwiftUI 的苹果语言识别封装库 —— SwiftSpeech](https://github.com/Cay-Zhang/SwiftSpeech "@cayZ：适配 SwiftUI 的苹果语言识别封装库 —— SwiftSpeech") -- 来自：cayZ

[@东坡肘子](https://www.fatbobman.com/)：SwiftSpeech 是苹果语音框架的一个封装器，与 SwiftUI 和 Combine 深度集成。只需几行代码就能实现 UI 控制 + 语音识别功能。SwiftSpeech 的作者是一位国人，提供的范例代码很有中国特色。

2、[适用于苹果生态的音频合成、处理分析平台 —— AudioKit](https://github.com/AudioKit/AudioKit "@AudioKit：适用于苹果生态的音频合成、处理分析平台 —— AudioKit") -- 来自：AudioKit

[@东坡肘子](https://www.fatbobman.com/)：AudioKit 是一个由代码库、包、库、算法、应用程序、playgorunds、测试和脚本组成的整个音频开发生态系统，由音频程序员、应用程序开发人员、工程师、研究人员、科学家、音乐家、游戏玩家和编程新手组成的社区建立和使用。AudioKit 提供了丰富的文档和范例，拥有十分活跃的社区。

3、[Swift 编写的相机系统 —— NextLevel](https://github.com/NextLevel/NextLevel "@NextLevel：Swift 编写的相机系统 —— NextLevel") -- 来自：NextLevel

[@东坡肘子](https://www.fatbobman.com/)：NextLevel 最初是一个周末项目，现在已经发展成为一个由相机平台爱好者组成的开放社区。该软件为管理媒体录制、相机界面定制、手势交互定制和 iOS 上的图像流提供基础组件。同样的功能也可以在 Snapchat、Instagram 和 Vine 等应用中找到。NextLevel 提供了用于捕捉 ARKit 视频和照片的组件，并利用了 NextLevel 现有的记录功能和媒体管理。

4、[GPUImage2](https://github.com/BradLarson/GPUImage2 "GPUImage2") -- 来自：GitHub

[@我是熊大](https://github.com/Tliens)：早在 2016 年，GPUImage 就已经被大家知晓，各大图像处理软件，几乎都基于此开发，可以说是一个里程碑意义的开源库，后续作者又写了 Swift 版本 GPUImage2（OpenGL ES）、GPUImage3（Metal）。

5、[神笔马良——基于 Metal 的涂鸦框架](https://me.harley-xk.studio/posts/201805072231 "@Harley：神笔马良——基于 Metal 的涂鸦框架") -- 来自博客：Harley

[@我是熊大](https://github.com/Tliens)：MaLiang 作者是中国人，一个全栈工程师；MaLiang 可以用于开发画板类似的功能，同样也是基于 Metal 开发的，是一个有了 4 年沉淀的开源库，目前 star 1.2k+。

***

### SwiftUI

整理编辑：[东坡肘子](https://www.fatbobman.com)、[我是熊大](https://juejin.cn/user/1151943916921885)

1、[SwiftUI 视图的生命周期研究](https://www.fatbobman.com/posts/swiftUILifeCycle/ "@东坡肘子：SwiftUI 视图的生命周期研究") -- 来自：东坡肘子

[@东坡肘子](https://www.fatbobman.com/)：在 UIKit（AppKit）的世界中，通过框架提供的大量钩子（例如 viewDidLoad、viewWillLayoutSubviews 等），开发者可以将自己的意志注入视图控制器生命周期的各个节点之中，宛如神明。在 SwiftUI 中，系统收回了上述的权利，开发者基本丧失了对视图生命周期的掌控。不少 SwiftUI 开发者都碰到过视图生命周期的行为超出预期的状况（例如视图多次构造、onAppear 无从控制等）。本文将作者对 SwiftUI 视图、SwiftUI 视图生命周期的理解和研究做以介绍，供大家一起探讨。

2、[探究视图树](https://mp.weixin.qq.com/s/JMxJqCoho-LGJcLrNt9ibQ "@Javier：探究视图树") -- 来自：Javier

[@东坡肘子](https://www.fatbobman.com/)：大多 SwiftUI 的开发者都已经熟练掌握了如何从父视图向子视图传递数据的方法，但如何获取子视图的状态和变化对很多人仍然比较陌生。swiftui-lab 的 Javier 写了三篇文章详细介绍了如何通过 PreferenceKey、AnchorPreferences 等方式向上传递数据的手段。链接中提供的是 Swift 花园的中文译本。

3、[SwiftUI 中的 Text 插值和本地化](https://onevcat.com/2021/03/swiftui-text-1/ "@onevcat：SwiftUI 中的 Text 插值和本地化") -- 来自：onevcat

[@东坡肘子](https://www.fatbobman.com/)：Text 是 SwiftUI 中最简单和最常见的 View 了，相较 String，Text 提供了更加丰富的差值和本地化功能。本文不仅介绍了 Text 中关于差值和本地化的一些特色功能，并讲解了在 Text 中创建自定义差值的方法。

4、[TCA - SwiftUI 的救星？(一)](https://onevcat.com/2021/12/tca-1/ "@onevcat：TCA - SwiftUI 的救星？(一)") -- 来自博客：onevcat

[@我是熊大](https://github.com/Tliens)：SwiftUI 似乎可以真正走向前台，成为开发利器，本文是 TCA - SwiftUI 系列的第一篇文章。

5、[SwiftUI Tab Bar](https://www.objc.io/blog/2020/02/25/swiftui-tab-bar/ "SwiftUI Tab Bar") -- 来自博客：objc.io

[@我是熊大](https://github.com/Tliens)：当你信心满满的准备用 SwiftUI 开发 App 时，可能会被困在第一步：Tab Bar 样式怎么处理，本文将替你解惑。

***

### 数据库方案对比

整理编辑：[我是熊大](https://juejin.cn/user/1151943916921885)、[东坡肘子](https://www.fatbobman.com)

1、[数据库的设计：深入理解 Realm 的多线程处理机制](https://academy.realm.io/cn/posts/threading-deep-dive/ "数据库的设计：深入理解 Realm 的多线程处理机制") -- 来自：Realm

[@我是熊大](https://github.com/Tliens)：Realm 是一个跨平台的移动数据库引擎，性能优于 Core Data 和 FMDB；接口十分人性化，使用很方便。本文能快速加深你对 Realm 的理解，并学习到更多有用的技巧，篇幅较长，耐心读下来，定会有所收获。每当我在 Realm 遇到问题时，本文几乎都能为我解惑。

2、[如何降低Realm数据库的崩溃](https://juejin.cn/post/6844904143501557773 "如何降低Realm数据库的崩溃") -- 来自掘金：我是熊大

[@我是熊大](https://github.com/Tliens)：Realm 的崩溃，猝不及防，不仅仅是 Realm，任何数据库导致的奔溃总是个难题，总有那么零星几个让人没有头绪的 bug，本文总结了我在实际工作中遇到的问题和解决办法。

3、[MMKV--基于 mmap 的 iOS 高性能通用 key-value 组件](https://cloud.tencent.com/developer/article/1066229 "MMKV--基于 mmap 的 iOS 高性能通用 key-value 组件") -- 来自掘金：我是熊大

[@我是熊大](https://github.com/Tliens)：在开发中是否真的需要沉重的数据库？还是需要一个好用的 NSUserDefaults。如果 app 中只是简单的存储，那么基于 mmap 内存映射的 MMKV 可能更适合你，他比 NSUserDefaults 快 100 倍。

4、[iOS 数据库比较：SQLite vs. Core Data vs. Realm](https://www.oschina.net/translate/ios-databases-sqllite-vs-core-data-vs-realm?cmp "iOS 数据库比较：SQLite vs. Core Data vs. Realm") -- 来自 OSCHINA：由 我是菜鸟我骄傲、theDoctor 翻译

[@东坡肘子](https://www.fatbobman.com/)：在 iOS 中，除了官方提供的 Core Data 外，还有很多其他的持久化方案可供选择。每种方案都有其各自的特点及适用场景。本文对 Core Data、SQLite 以及 Realm 进行了横向比较，并讨论了从 SQLite 或 Core Data 转换到 Realm 的路径及注意事项。

5、[Core Data with CloudKit](https://www.fatbobman.com/posts/coreDataWithCloudKit-1/ "Core Data with CloudKit") -- 来自：东坡肘子

[@东坡肘子](https://www.fatbobman.com/)：Core Data with CloudKit 是苹果为 Core Data 推出的网络同步解决方案，通过将 Core Data 同 CloudKit 进行结合，仅需使用少量代码，便可实现在苹果生态内跨设备、跨平台的数据实时同步。本系列文章一共 6 篇，详细介绍了有关如何进行私有数据库同步、公共数据库同步以及在不同用户间共享数据等内容。

***

### 包管理工具

整理编辑：[东坡肘子](https://www.fatbobman.com)

1、[iOS包依赖管理工具](https://juejin.cn/post/6932739864613879821 "iOS包依赖管理工具") -- 来自掘金：小小青叶

[@东坡肘子](https://www.fatbobman.com/)：本系列一共六篇文章，不仅从原理、使用、创建自定义库等方面，对 CocoaPods 和 Swift Package Manager 进行了介绍，并且对两种包管理工具进行了比较。

2、[CocoaPods Podspec 解析原理](http://chuquan.me/2022/01/03/podspec-analyze-principle/ "CocoaPods Podspec 解析原理") -- 来自楚权的世界：楚权

[@东坡肘子](https://www.fatbobman.com/)：在 CocoaPods 中，podspec 文件主要用于描述一个 pod 库的基本信息，包括：名称、版本、源、依赖等等。本文介绍了如何通过 DSL 方法将配置的属性保存在一个对象的哈希表中，通过构建一棵保存所有配置信息的树从而建立相互之间的依赖关系。

3、[关于 Swift Package Manager 的一些经验分享](https://juejin.cn/post/7007987863954391054 "关于 Swift Package Manager 的一些经验分享") -- 来自：字节跳动技术团队

[@东坡肘子](https://www.fatbobman.com/)：Swift Package Manager 是 Apple 为了弥补当前 iOS 开发中缺少官方组件库管理工具的产物。相较于其他组件管理控件，他的定义文件更加轻松易懂，使用起来也很 Magic，只需将源码放入对应的文件夹内，Xcode 就会自动生成工程文件，并生成编译目标产物所需要的相关配置。同时，SPM 与 Cocoapods 相互兼容，可以在特性上提供互补。本文除了介绍 Swift Package Manager 的现状、常见使用方法外，还阐述了作者对于 SPM 未来的一些思考。

4、[解决swift package manager fetch慢的问题](https://www.jianshu.com/p/953220424556 "解决swift package manager fetch慢的问题") -- 来自简书：chocoford

[@东坡肘子](https://www.fatbobman.com/)：由于网络的某些限制，在 Xcode 中直接 fetch Github 上的 SPM 库并不容易。本文中给出了几种提高 fetch 成功率的解决方案。（编辑特别提示：Xcode 程序包中内置了终端、命令行工具等应用，任何在系统终端下的代理设定对其都不会产生作用。使用 SS + Proxifier 的方式可以实现让 Xcode 中的网络数据从指定代理通过）

5、[Swift Package Manager 添加资源文件](https://juejin.cn/post/6854573220784242702 "Swift Package Manager 添加资源文件") -- 来自掘金：moxacist

[@东坡肘子](https://www.fatbobman.com/)：从 swift-tool-version 5.3 版本开始，Swift Package Manager 提供了在包中添加资源文件的能力。本文是 WWDC 2020 —— 【Swift 软件包资源和本地化】 专题演讲的中文整理。

***

### 野指针

整理编辑：[皮拉夫大王在此](https://juejin.cn/user/281104094332653)

1、[大白健康系统--iOS APP运行时Crash自动修复系统](https://neyoufan.github.io/2017/01/13/ios/BayMax_HTSafetyGuard/ "大白健康系统--iOS APP运行时Crash自动修复系统")

[@皮拉夫大王](https://juejin.cn/user/281104094332653)：整个文章是非常经典的，作者介绍通过 method swizzling 替换 NSObject 的 `allocWithZone` 方法和 dealloc方法实现野指针拦截。

2、[JJException](https://github.com/jezzmemo/JJException "JJException")

[@皮拉夫大王](https://juejin.cn/user/281104094332653)：这个库需要自己指定探测哪些类对应的野指针。换句话说，就是我们自己指定 10 个类，那么这 10 个类的对象发生野指针时我们才能发现。如果在此之外，野指针监控不到。

3、[iOS 野指针定位:野指针嗅探器](https://www.jianshu.com/p/9fd4dc046046 "iOS 野指针定位:野指针嗅探器")
[@皮拉夫大王](https://juejin.cn/user/281104094332653)：文章介绍了 2 个方案：（1）在开发阶段破坏内存，使野指针必现崩溃（野指针可能由于内存释放但未被写入导致崩溃不必现）。在 free 时，并不释放内存，保留内存，判断是否为 objc 对象，如果是 objc 对象则将对象 setclass 为自定义类，借助消息转发得到堆栈和类信息。监听系统内存警告，收到警告后释放。（2）hook objc 的 dealloc 方法，在 dealloc 时判断是否需要开启野指针探测，如果不需要则直接释放，否则将对象修改 isa 后保留并加入到内存池中，再次调用对象时会触发消息转发拦截到堆栈及对象类名信息。

4、[iOS野指针定位总结](https://juejin.cn/post/6844903747538141191 "iOS野指针定位总结")

[@皮拉夫大王](https://juejin.cn/user/281104094332653)：文章介绍方案如下：分类覆盖 dealloc 函数，并在 dealloc 中重新设置 isa 并不释放 obj，其中重新指向的 isa 是动态创建的。也就是说 dealloc 是 10000 个类，也会同步动态创建 10000 个类。

5、[浅谈 iOS 中的 Crash 捕获与防护](http://shevakuilin.com/ios-crashprotection/ "浅谈 iOS 中的 Crash 捕获与防护")

[@皮拉夫大王](https://juejin.cn/user/281104094332653)：推荐阅读的文章，文章不仅仅介绍了野指针相关内容，还介绍了崩溃相关的基础知识。

6、[xiejunyi'Blog](https://junyixie.github.io/categories/APM/ "xiejunyi'Blog")

[@皮拉夫大王](https://juejin.cn/user/281104094332653)：坦白讲我并没有看完的文章，在做技术调研时发现的博客，文章内容比较深入并且能看出作者是有大量实战经验的开发者，因此推荐给大家。

***

### 年度总结

整理编辑：[我是熊大](https://juejin.cn/user/1151943916921885)

1、[2021 年终总结](https://onevcat.com/2021/12/2021-final/ "2021 年终总结") -- 来自博客：王巍 (onevcat)

[@我是熊大](https://github.com/Tliens)：王巍，拥有知名开源库 Kingfisher，创办了网站 [ObjC CN](https://objccn.io/)，是 iOS 开发者重点关注对象。

2、[大厂逃离后上岸人员的年终总结](https://juejin.cn/post/7047809990916046862 "大厂逃离后上岸人员的年终总结") -- 来自掘金：东方赞

[@我是熊大](https://github.com/Tliens)：工作不卷，生活要开心，收入稳中有升。

3、[下一个五年计划起航 ！](https://halfrost.com/halfrost_2020/ "下一个五年计划起航 ！") -- 来自博客：halfrost

[@我是熊大](https://github.com/Tliens)：霜神是前阿里巴巴资深后端工程师，iOS 开发届的大佬级别人物，这是 2020 的年终总结，来的更晚一些。

4、[【年度总结】2021年度总结](https://blog.yuusann.com/corpus/article/21021 "【年度总结】2021年度总结") -- 来自博客：郑宇琦

[@我是熊大](https://github.com/Tliens)：郑宇琦，LinkedIn 高级研发工程师，曾就职于百度，作者过去一年的经历十分丰富，生活不止有 coding。

5、[2020年我阅读了87本书，推荐这12本好书给你](https://mp.weixin.qq.com/s/f6_Sa_C4uU983UBaiMtJdQ "2020年我阅读了87本书，推荐这12本好书给你") -- 来自公众号： 千古壹号

[@我是熊大](https://github.com/Tliens)：作者是京东的一位前端开发，读书爱好者，一年的读书清单有 87 本之多。

## 开发概念汇总

来源于我在开发交流群里的每日分享一个编程概念的内容整理，这些内容多参考主流网站介绍外加一些自己的理解。因为概念内容跨度较广，很多也是我不熟悉的领域，如果有解释不对的地方，欢迎大家指正。

### 什么是Makefile

一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，而编译通常是一个文件一个文件进行的，对于多文件的情况，又该如何编译呢？

这就是makefile的作用，它就像一个shell脚本（里面也可以执行系统的shell命令），定义了一系列的规则，用于指定哪些文件需要编译，编译顺序，库文件的引用，及一些更复杂的编译操作。

makefile只是定义编译规则，执行这些规则的指令是make命令。

makefile和make常用于Linux及类Unix环境下。

### 什么是CMake

Make工具有很多种，比较出名的有GNU Make（昨天介绍的Make命令通常指GNU Make），QT 的qmake，微软的MS nmake，BSD Make（pmake）等等。

这些 Make 工具遵循着不同的规范和标准，所要求的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。

这种环境下就诞生了CMake，其通过CMakeList.txt文件来定制整个编译流程，然后根据目标用户的平台进一步生成所需的Makefile和工程文件。达到「Write once, run everywhere」的效果。

Swift的编译过程即是通过CMake定制的，我们可以在源码里发现多个CMakeList.txt文件。

https://github.com/apple/swift/blob/main/CMakeLists.txt

### 什么是xcodebuild

xcodebuild类似GNU里的make，它是一套完整的编译工具，其包括在命令行工具包（Command Line Tools）中。苹果做了很多简化编译的操作，使得开发者不需要像使用make一样编写makefile，仅需根据实际情况指定workspace、project、target、scheme（这几项概念要分清分别指什么东西）即可完成工程的编译。使用`man xcodebuild`可以查看xcodebuild所支持的功能以及使用说明。

其主要有以下功能：

1、build：构建（编译），生成build目录，将构建过程中的文件存放在这个目录下。

2、clean：清除build目录下的文件

3、test：测试某个scheme，scheme必须指定 

4、archive：执行archive，导出ipa包

5、analyze：执行analyze操作

### 什么是xcrun

xcrun 是 Command Line Tools中的一员。它的作用类似RubyGem里的bundle，用于控制执行环境。

xcrun会根据当前的Xcode版本环境执行命令，该版本是通过`xcode-select`设置的，如果系统中安装了多个版本的Xcode，推荐使用xcrun。

xcrun的使用是直接在其后增加命令，比如：`xcrun xcodebuild`，`xcrun altool`。当然xcodebuild和altool也是可以单独运行的，只不过对于多Xcode的环境他们的执行环境究竟使用的哪个版本无法保证。

### 什么是launchd

launchd是一套统一的开源服务管理框架，它用于启动、停止以及管理后台程序、应用程序、进程和脚本。其由苹果公司的Dave Zarzycki编写，在OS X Tiger系统中首次引入并获得Apache授权许可证。

launchd是macOS第一个启动的进程，它的pid为1，整个系统的其他进程都是由它创建的。

当launchd启动后，它会扫描`/System/Library/LaunchDaemons`和`/Library/LaunchDaemons`里的plist文件，并加载他们。

当你输入密码，登录系统之后，launchd会扫描`/System/Library/LaunchAgents`和`/Library/LaunchAgents、~/Library/LaunchAgents`里的plist文件，并加载。

这些plist文件代表启动任务，也叫`Job`，它里面配置了启动任务启动形式的描述信息。

***

### 什么是Clang

![](https://cdn.zhangferry.com/Images/clang.png)

Clang 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它的目标是提供一个GNU编译器套装（GCC）的替代品，支持了GNU编译器大多数的编译设置以及非官方语言的扩展。作者是克里斯·拉特纳（Chris Lattner）。

clang项目包括clang前端和clang静态分析器。编译器前端的含义是clang不能直接将源码编译成机器码，clange能输出源码的抽象语法树，并将代码编译成LLVM bitcode。

Clang本身性能优异，其生成的AST所耗用掉的内存仅仅是GCC的20%左右，Clang编译Objective-C代码时速度为GCC的3倍，还能针对用户发生的编译错误准确地给出建议。

### 什么是LLVM

LLVM（Low Level Virtual Machine）是一个自由软件项目，它是一种编译器基础设施，以C++写成，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。

LLVM有两层含义，广义的LLVM是指一个完整的编译器架构，包括前端、后端、优化器等。

狭义的LLVM仅指编译器后端功能的一些列模块和库，由Clange编译出的中间件经过LLVM后端处理变成对应机器码。

![](https://cdn.zhangferry.com/Images/llvm.png)

### 什么是ld

链接器（Linker）是一个程序，它可以将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个可执行文件。

ld是GNU的链接器，llvm4中有了自己的链接器lld，但是lld在macOS上运行还有问题 (http://lists.llvm.org/pipermail/cfe-dev/2019-March/061666.html)，所以当前Xcode使用的链接器仍是ld。

Build Setting里的Other Linker Flags就是制定ld命令的参数。

在Xcode中，它有三个常用的参数：

`-Objc`:链接器就会把静态库中所有的 Objective-C Class 和 Category 都加载到最后的可执行文件中

`-all_load`:会让链接器把所有找到的目标文件都加载到可执行文件中，但有可能会遇到`duplicate symbol`错误

`-fore_load`:需要指定加载库文件的路径，然后将目标文件全部加载到可执行文件中。

### 什么是dyld

dyld（the dynamic link editor）是苹果的动态链接器，负责程序的链接及加载工作，是苹果操作系统的重要组成部分。

dyld跟ld不同点在于它主要是用于加载系统动态库的，在MachO内记录了所依赖的动态库，像是Foundation、UIKit等，应用启动时由dyld进行加载。首次加载会将动态库放至共享缓存，之后需要加载的应用就可以直接访问共享缓存加载这些动态库了，之后链接至主程序。

dyld属于开源项目，地址:https://opensource.apple.com/tarballs/dyld/

### 什么是bitcode

bitcode是编译后的程序的中间表现，在Xcode中bitcode对应的是一个配置，意为是否开启bitcode。

包含bitcode并上传到App Store Connect的Apps会在App Store Connect上编译和链接。包含bitcode可以在不提交新版本App的情况下，允许Apple在将来的时候再次优化你的App 二进制文件。 对于iOS Apps，Enable bitcode 默认为YES，是可选的（可以改为NO）。对于WatchOS和tvOS，bitcode是强制的。如果你的App支持bitcode，App Bundle（项目中所有的target）中的所有的Apps和frameworks都需要包含bitcode。

苹果推荐iOS项目开启bitcode，且强制watchOS必须开启bitcode。

因为包含bitcode的项目会在App Store Connect重新编译，所以其符号表文件依赖编译后的结果，这时就需要从App store connect下载对应dSYM文件。

### 什么是linkmap

我们编写的源码需要经过编译、链接，最终生成一个可执行文件。在编译阶段，每个类会生成对应的`.o`文件（目标文件）。在链接阶段，会把.o文件和动态库链接在一起。

linkmap（Link Map File）指的就是记录链接相关信息的纯文本文件，包含可执行文件的路径、CPU架构、目标文件、符号等信息。其可用于分析iOS编译后各个模块的大小，网上也有一些现成的工具帮助我们直接分析该文件。

在Build Setting里搜map，可以看到`write link map file`选项，里面设置了linkmap文件的导出路径。

***

### 什么是shell

shell有两层含义，首先它表示一个应用程序，它连接了用户和系统内核，让用户能够更加高效、安全、低成本地使用系统内核，这就是 Shell 的本质。shell本身并不是shell内核，而是在内核的基础上编写的一个应用程序。

Linux上的shell程序有bash，zsh，Windows也有shell程序叫PowerShell。

第二层含义是脚本语言（Script），它是同JavaScript，Python，Ruby一样的脚本语言；Shell有一套自己的语法，你可以利用它的规则进行编程，完成很多复杂的任务。Shell脚本适合处理系统底层的操作，像Python等脚本语言也都支持直接执行shell命令。

这里的Shell脚本语言是指能够被bash或者zsh解释的脚本，shell脚本不能直接被windows识别，通常需要安装bash程序辅助识别。

在iOS开发期间，shell作为脚本常用于以下场景：

1、在Xcode中我们可以在Build Phase中添加脚本完成一些编译时工作。

2、配置打包脚本，CI/CD等

### 什么是bash

Bash，Unix shell的一种，1989年发布第一个正式版本，原先是计划用在GNU操作系统上，但能运行于大多数类Unix系统的操作系统之上，包括Linux与Mac OS X v10.4起至macOS Mojave都将它作为默认shell，而自macOS Catalina，默认Shell以zsh取代。

Bash是一个满足POSIX规范的shell，支持文件名替换（通配符匹配）、管道、here文档、命令替换、变量，以及条件判断和循环遍历的结构控制语句，同时它也做了很多扩展。

通常shell脚本的第一行会写`#!/bin/bash`，即代表使用bash解释该脚本。

### 什么是zsh

zsh是一款可用作交互式登录的shell命令解释器，zsh对Bourne shell做了大量改进，同时加入了bash、ksh的某些功能。从macOS Catalina起系统默认shell从bash改为了zsh。

用户社区网站Oh My Zsh专门收集zsh插件及主题，使得zsh使用起来更加便利也更受大家欢迎。

> Oh My Zsh will not make you a 10x developer...but you may feel like one.

截止目前Oh My Zsh有1700+贡献者，包含200+插件和超过140个主题。

ohmyzsh地址：https://github.com/ohmyzsh/ohmyzsh

### 包管理器是什么

包管理器又称软件包管理系统，它是在电脑中安装、配置、卸载、升级，有时还包含搜索、发布的工具组合。

**Homebrew**是一款Mac OS平台下的包管理器，拥有安装、卸载、更新、查看、搜索等很多实用的功能。

**apt-get**和**yum**跟Homebrew类似，只不过他们适用的平台是Linux，二者一般会被分别安装到Debian、Ubuntu和RedHat、CentOS中。

软件包管理器，适用于特定开发语言，这类软件包本身的安装需要依赖特定语言环境。

**NPM**（node package manager)，通常称为node包管理器，主要功能就是管理node包，使用Node.js开发的多数主流软件都可以通过npm下载。

**RubyGems**是Ruby的一个包管理器，提供了分发Ruby程序和库的标准格式“gem”，旨在方便地管理gem安装的工具，以及用于分发gem的服务器。使用Ruby开发的软件一般都通过gem进行管理。

**pip** 是通用的 Python 包管理工具，python3对应的是pip3。使用Python开发的软件多使用pip进行管理。

### 什么是ttys000

每次打开一个新的终端窗口，第一行显示的内容就是`Last login: Tue Dec 15 19:23:41 on ttys000`，如果再开一个窗口（包括新的tab），除了时间的变化，还有就是最后的那个名称，会变成ttys001，它会随着窗口打开数量不断增加。

这个ttys000是窗体的名称，它来源于UNIX中的tty命令。终端中输入tty，会返回当前的终端名称：`/dev/ttys000`。dev是Linux系统的设备特殊文件目录，该目录不可见。

另外在窗体中输入`logout`可以关闭当前终端窗口。

### 什么是Command Line Tools

Command Line Tools 是 一个运行在macos上的命令行工具集，它的安装命令是：`xcode-select --install`。

它是独立于xcode的，名字带有xcode只是因为它包含编译iOS项目的命令行工具。

它安装的内容除了clang、llvm等常见的工具外，还包括gcc、git等工具。

该工具集的安装路径是：`/Library/Developer/CommandLineTools/usr/bin/`

***

本期概念围绕几个操作系统开展，系统能帮助大家了解各个操作系统之间的关系。

### 什么是GNU

![](https://cdn.zhangferry.com/Images/20210124145056.png)

GNU是一个自由的操作系统，名字是一个递归 GNU’s Not Unix!的缩写。

它出现的原因是Unix被发明后，开始收费和商业闭源，Richard Matthew Stallman觉得很不爽。于是发起了GNU计划：创造一个仿Unix并与之兼容的自由开源操作系统。

为此Stallman还创建了FSF（自由软件基金会）和GPL（GNU通用公共许可协议），在GNU项目里开发的软件都遵循GPL协议。

在打造操作系统的过程中，GNU开发出了编辑器Emacs，编译器（GCC），shell等很牛叉的东西，但唯独操作系统内核Hurd因为种种原因一直无法完成。

这时出现了Linux，它就是一个操作系统内核，不仅开源还被广泛追捧。Linux和GNU像是天生一对，一个万事具备只缺内核，一个只专注做内核，于是一拍即合，很多Linux发行版开始接入GNU的组件，Linux也遵循了GPL协议。

所以Stallman主张Linux使用了很多GNU组件应该叫GNU/Linux，但是并没有得到Linux设计的一致认同，所以该名称仍有争议。

但Hurd的开发并没有因此结束，目前还在进行中。

### 什么是GCC

早期 GCC 的全拼为 GNU C Compiler，即 GUN 计划诞生的 C 语言编译器，显然最初 GCC 的定位确实只用于编译 C 语言。但经过这些年不断的迭代，GCC 的功能得到了很大的扩展，它不仅可以用来编译 C 语言程序，还可以处理 C++、Go、Objective -C 等多种编译语言编写的程序。与此同时，由于之前的 GNU C Compiler 已经无法完美诠释 GCC 的含义，所以其英文全称被重新定义为  GNU Compiler Collection，即 GNU 编译器套件。

GCC 编译器从而停止过改进。截止到今日（2020 年 5 月），GCC 已经从最初的 1.0 版本发展到了 10.1 版本，期间历经了上百个版本的迭代。作为一款最受欢迎的编译器，GCC 被移植到数以千计的硬件/软件平台上，几乎所有的 Linux 发行版也都默认安装有 GCC 编译器。

补充一句，早期OC项目都是通过GCC编译的，因为不满足于GCC的性能，Chris Lattner开发了Clang。

### 什么是XNU

XNU是一个由苹果电脑开发用于macOS操作系统的操作系统内核。它是Darwin操作系统的一部分，跟随着Darwin一同作为自由及开放源代码软件被发布。它还是iOS、tvOS和watchOS操作系统的内核。XNU是X is Not Unix的缩写。这一点跟GNU一样。

XNU最早是NeXT公司为了NeXTSTEP操作系统而发展的，在苹果电脑收购NeXT公司之后，XNU的Mach微内核被升级到Mach 3.0。

需要注意区分的概念是操作系统内核，操作系统，桌面操作系统。

Mach是一个微内核

XNU是一个混合操作系统内核，包含Mach

Darwin是以XNU为内核发布的开源操作系统

macOS是以Darwin为核心的桌面操作系统

Darwin地址：https://github.com/apple/darwin-xnu

### 什么是FreeBSD

![](https://cdn.zhangferry.com/Images/20210124145432.png)

在此之前先说下BDS（Berkeley Software Distribution 伯克利软件套装），它是Unix的衍生系统，在1977至1995年由伯克利大学分校开发和发布，其是去除SyStem V 删除了AT&T专利代码的。

随着该系统的发展，还提出了新的许可协议：BSD License，它在软件使用上提供了最小限度的限制，它允许遵循该协议的软件被二次开发，且开发之后的版本可以闭源。

所以基于BSD发展出了很多类Unix系统，被称为BSD家族，其中最著名的当属FreeBSD。直到现在FreeBSD仍然在很多网站的服务器上运行着。

乔帮主在NextStep时开发了基于FreeBSD的后端Darwin，回归Apple就给带过去了，而这个就是MacOS的内核，之后的iOS，watchOS也都是基于Darwin构建的。

索尼用FreeBSD创造了PS3，PS4。

任天堂用FreeBSD创造了Nintendo Swiftch。

BSD的发展历史：

![](https://cdn.zhangferry.com/Images/20210124145540.png)

### 什么是POSIX

POSIX是Portable Operation System Interface的缩写，即可移植操作系统接口，它是由IEEEE为了在Unix上运行软件提出的一系列标准，X表明其对Unix API的传承。

类Unix系统像Linux、MacOS中均实现了对POSIX接口的兼容，其中我们在多线程使用过程中创建的pthread（前面的p即POSIX），就是基于POSIX里的线程标准设计的。

***

### 什么是DevOps

DevOps[/de'vɒps/]是Development（开发） + Operations（运维）的组合，其实它还包含了测试的环节。DevOps是一组过程，方法和系统的统称，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。

DevOps 希望做到的是软件产品交付过程中IT工具链的打通，使得各个团队减少时间损耗，更加高效地协同工作。

DevOps 通常需要很多工具的介入，Jira、GitLab、Jenkins、Docker、fastlane等。它是CI/CD的延伸，CI/CD是实现DevOps的基础核心。DevOps的实践可以用于增强敏捷开发。

![](https://cdn.zhangferry.com/Images/devops.png)

### 什么是敏捷开发

敏捷开发（Agile software development）是一种应对快速变化的需求的一种软件开发能力。相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。

其描述的是整体软件开发的过程，包含以下几个关键点：

• 迭代、渐进和进化：周期控制在一到四周，迭代的目标要达到一个可用的发行版

• 工作软件是进化的主要手段：合适的工程管理软件Jira、Tower等

• 高效率的面对面沟通：明确一个产品负责人；消息发布，包含最新产品信息，通常依托于大屏显示器，路人可以看到

• 非常短的反馈回路和适应周期：每日立会

• 质量焦点：推荐使用TDD方式开发，使用CI提速开发流程

### 什么是Scrum

Scrum是敏捷开发中的一种方法学。它是用于开发、交付和持续支持复杂产品的一个框架，是一个增量的、迭代的开发过程。

在这个框架中，整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个Sprint，每个Sprint的建议长度是一至四周。在Scrum中，使用产品Backlog来管理产品的需求，产品backlog是一个按照商业价值排序的需求列表，列表条目的体现形式通常为用户故事。Scrum团队总是先开发对客户具有较高价值的需求。在Sprint中，Scrum团队从产品Backlog中挑选最高优先级的需求进行开发。挑选的需求在Sprint计划会议上经过讨论、分析和估算得到相应的任务列表，我们称它为Sprint backlog。在每个迭代结束时，Scrum团队将递交潜在可交付的产品增量。 Scrum起源于软件开发项目，但它适用于任何复杂的或是创新性的项目。Scrum 目前已被用于开发软件、硬件、嵌入式软件、交互功能网络、自动驾驶、学校、政府、市场、管理组织运营，以及几乎我们（作为个体和群体）日常生活中所使用的一切。

Scrum中有三个重要角色：

1. Scrum Master是Scrum教练和团队带头人，确保团队合理的运作Scrum，并帮助团队扫除实施中的障碍；
2. 产品负责人，确定产品的方向和愿景，定义产品发布的内容、优先级及交付时间，为产品投资报酬率负责；
3. 开发团队，一个跨职能的小团队，人数5-9人，团队拥有交付可用软件需要的各种技能。

![](https://cdn.zhangferry.com/Images/scrumcn.png)

### 什么是极限编程

极限编程（英语：Extreme programming，缩写为XP），是一种软件工程方法学，是敏捷软件开发中应用最为广泛和最富有成效的几种方法学之一。如同其他敏捷方法学，极限编程和传统方法学的本质不同在于它更强调可适应性而不是可预测性。

极限编程的支持者认为软件需求的不断变化是很自然的现象，是软件项目开发中不可避免的、也是应该欣然接受的现象；他们相信，和传统的在项目起始阶段定义好所有需求再费尽心思的控制变化的方法相比，有能力在项目周期的任何阶段去适应变化，将是更加现实更加有效的方法。

极限编程包含几个重要的实践：结对编程、编码规范、TDD、重构、持续集成等。

极限编程有5个重要原则：快速反馈、假设简单、增量变化、拥抱变化、高质量工作。

### 什么是结对编程

结对编程（英语：Pair programming）是一种敏捷软件开发的方法，两个程序员在一个计算机上共同工作。一个人输入代码，而另一个人审查他输入的每一行代码。输入代码的人称作驾驶员，审查代码的人称作观察员（或导航员）。两个程序员经常互换角色。

结对编程的理想情况是：在结对编程中，观察员同时考虑工作的战略性方向，提出改进的意见，或将来可能出现的问题以便处理。这样使得驾驶者可以集中全部注意力在完成当前任务的“战术”方面。观察员当作安全网和指南。

但为什么结对编程没有流行开来？这是因为它的优点不好发挥，缺点有着诸多不可控因素。

结对编程中希望达成的：驾驶者可以集中全部注意力在完成当前任务的“战术”方面，观察员当作安全网和指南，这需要很高的配合度才能达成。而合作所产生的交流成本和个性差异也不可忽略。

我想到的结对编程可以发挥的场景有这么两个：

1、对于一些复杂问题的攻坚，两人合作，利用不同思路可能快速解决问题。

2、适合帮助开发者快速熟悉自己所不熟悉的领域，类似老人带新人的模式，它有利于知识的分享和传递。

参考资料：https://blog.csdn.net/csdnnews/article/details/105259918

### 什么是元编程

元编程（Metaprogramming）是计算机编程里一个非常重要、有趣的概念，维基百科中的定义是将元编程描述成一种计算机程序可以将代码看待成数据的能力。简单理解就是，其表达的是一种使用代码生成代码的能力。

现代的编程语言大都会为我们提供不同的元编程能力，从总体来看，根据『生成代码』的时机不同，我们将元编程能力分为两种类型，其中一种是编译期间的元编程，例如：宏和模板；另一种是运行期间的元编程，也就是运行时，它赋予了编程语言在运行期间修改行为的能力，当然也有一些特性既可以在编译期实现，也可以在运行期间实现。

元编程可用于解决通用型的问题，减少样板代码，比如常见的字典和模型的互转问题，它存在很多固定样式，我们期望编写一个方法让它实现自动匹配，即编写一个可以自调整的方法，这个行为就是元编程，而用到的方案是反射。

跟元编程相关的还有一个概念是元类（Metaclass），它是代表构建类对象的类，在这些语言中例如OC，Ruby，Java，Python等都有元类的概念。

还有个为了保持继承关系闭环的概念叫根元类（Root metaclass），这个在OC和Ruby中都要对应概念。

扩展文章：https://onevcat.com/2018/03/swift-meta/

***

### 什么是关系型数据库

关系型数据库，是指采用了关系模型来组织数据的数据库。

关系模型是在1970年由IBM的研究员E.F.Codd博士首先提出的，在之后的几十年中，关系模型的概念得到了充分的发展并逐渐成为主流数据库结构的主流模型。

简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。

关系型数据库的代表是：SQL Server、Oracle、Mysql

他们的优点是容易理解，二维表结构也更贴近现实世界，使用起来也很方便，使用通用的SQL语句就可以完成增删改查等操作。关系型数据库另一个比较大的优势是它的完整可靠，大大降低了数据冗余和数据不一致的概率。

但很多事物都用两面性，关系数据库也不例外，它在处理高并发，通常每秒在上万次的读写请求时，硬盘I/O就会面临很大的瓶颈问题。

### 什么是非关系型数据库

非关系型数据库也叫NoSQL，用于区别依赖SQL语句的关系数据库，NoSQL还有另一层解读：Not only SQL。

非关系型数据库主要是用于解决关系型数据库面临的高并发读写瓶颈，这个类型数据库种类繁多，但都有一个共同点，就是去掉关系数据库的关系型特性，使得数据库的扩展更加容易。

但它也有一定的缺点就是无事务处理，数据结构相对复杂，处理复杂查询时相对欠缺。

非关系数型数据库分为4大类：

文档型：常用于Web应用，典型的有MongoDB、CouchDB

Key-Value型：处理大量数据的高访问负载，内容缓存，典型的有Redis、Oracle BDB

列式数据库：处理分布式的文件系统，典型的有Cassandra、HBase

图形数据库：用于社交网络，推荐系统，典型的有Neo4J、InfoGrid

SQL和NoSQL没有孰强孰弱，NoSQL也并不会代替SQL，只有结合自身的业务特点才能发挥出这两类数据库的优势。

### 什么是ACID

ACID是指数据库管理系统在写入或者更新资料时，为保证事务可靠性，所必须具有的四个特性。
A（atomicity）指原子型：一个事务里的所有操作，要么全部完成，要么全部不完成，不存在中间状态，如果中间过程出错，就回滚到事务开始前的状态。

C（consistency）一致性：在事务开始之前和结束之后，数据库完整性没有被破坏。

I（isolation）隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。

D（durability）持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
通常关系型数据库都是遵守这四个特性的，而非关系型数据库通常是打破了四个特性的某几条用于实现高并发、易扩展的能力。

### 什么是数据库范式

简单的说，范式是为了消除重复数据减少冗余数据，从而让数据库内的数据更好的组织，让磁盘空间得到更有效利用的一种标准化规范，满足高等级的范式的先决条件是满足低等级范式。(比如满足2nf一定满足1nf)。

范式只是针对关系型数据库的规范，当前有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF），第四范式（4NF）和第五范式（5NF）又被称为完美范式。这里的NF是Normal form的缩写，翻译为范式。

1NF就是每一个属性都不可再分。不符合第一范式则不能称为关系数据库。

2NF要求数据库表中的每个实例或记录必须可以被唯一地区分。

3NF要求一个关系中不包含已在其它关系已包含的非主关键字信息。

BCNF是在3NF基础上，任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）

4NF是消除表中的多值依赖，也就是说可以减少维护数据一致性的工作。

如果它在4NF 中并且不包含任何连接依赖关系并且连接应该是无损的，则关系在5NF 中。

使用的范式越高则表越多，表多就会带来更高的查询复杂度，使用何种范式需跟实际情况而定，通常满足BCNF即可。

### 什么是ER图

ER图是 Entity Relationship Diagram 的简写，也叫实体关系图，它主要应用于数据库设计的概念设计阶段，用于描述数据之间的关系。

它有三种主要元素：

1、实体：表示数据对象，使用矩形表示

2、属性：表示对象具有的属性，使用椭圆表示

3、联系：表示实体之间的关系，使用菱形表示，关联关系有三种：1:1 表示一对一，1：N表示一对多，M : N表示多对多。

使用直线将联系的各方进行连接。

![](https://cdn.zhangferry.com/Images/20210314140748.png)

横线表示键，双矩形表示弱实体，成绩单依赖于学生而不可单独存在。

### 什么是数据库索引

索引是对数据库表中一列或者多列的值进行排序的一种数据接口。使用索引可以加快数据的查找，但设置索引也是有一定代价的，它会增加数据库存储空间，增加插入，删除，修改数据的时间。

数据库索引能够提高查找效率的原因是索引的组织形式使用B+树（也可能是别的平衡树），B+树是一种多叉平衡树，查找数据时可以利用类似二分查找的原则进行查找，对于大量的数据的查找，它可以显著提高查找效率。

因为使用平衡树的缘故对于删除和新增数据都可能打破原有树的平衡，就需要重新组织数据结构，维持平衡，这就是增加索引耗时的原因。

对于非聚集索引（非主键字段索引），字段数据会被复制一份出来，用于生成索引，所以会增加存储空间。对非聚集索引的查找是先查找到指定值，然后通过附加的主键值，再使用主键值通过聚集索引查找到需要的数据。

参考：[B+树详解](https://ivanzz1001.github.io/records/post/data-structure/2018/06/16/ds-bplustree#1-b%E6%A0%9 "B+树详解") 

***

### 什么是SSH

SSH是一个网络安全协议，用于计算机之间的加密登录（非对称加密），每台Linux上都安装有SSH。它工作在传输层，能防止中间人攻击，DNS欺骗。它的用法是

```shell
$ ssh user@host
```

host可以是ip地址或者域名，还可以通过-p指定端口号。

ssh登录流程为：

1、远程主机收到用户的登录请求，把自己的公钥发给用户。

2、用户使用这个公钥，将登录密码加密后，发送回来。

3、远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。

如果不想每次登录时都输密码，可以将本地的公钥发送到远程主机，这样登录过程就变成了：

1、每次远程主机发送一个随机字符串

2、用户用自己的私钥加密

3、远程主机利用公钥解密，如果成功就就同意用户登录。

### 什么是Nginx

![](https://cdn.zhangferry.com/Images/nginx.png)

Nginx是一款轻量级的Web服务器、反向代理服务器，由于其开源、内存占用少，启动快，高并发能力强，在互联网项目中广泛应用；同时它还是一个IMAP、POP3、SMTP代理服务器，还可以作为反向代理进行负载均衡的实现。

应用场景：在博客站点中，它担任HTTP服务器的作用，通过HTTP协议将服务器上的静态文件（HTML、图片）展现给客户端。

### 什么是负载均衡

负载均衡是一种提高网络可用性的解决方案。当没有负载均衡时，当前服务器宕机或访问量超过服务器上限都会导致网站瘫痪无法访问。负载均衡的解决方案是，设立多台服务器，在访问服务器之前首先经过负载均衡器，由负载均衡器进行分配当前请求应该访问哪一个服务器。既提高了网站瘫痪的容错率又分摊了单个服务器的压力。

负载均衡的实现关键点是如何分配服务器。前置条件是定期检测服务器健康状态，维护一个健康服务器池，然后用一定的算法进行服务器分配，有三种常见分配算法：

轮询：按健康服务器表逐一分配

最小链接：优先选择连接数最少的服务器

Source：根据来源ip地址选择服务器，保证特定用户连接同一服务器

Nginx可以用于实现负载均衡，也提供了以上几种分配算法实现。

### 什么是Apache

![](https://cdn.zhangferry.com/Images/apache.png)

Apache有多个含义：

一是Apache基金会，它是专门为支持开源软件项目而创办的一个非营利性组织，它所发行的软件都遵循Apache协议。

二是Apache服务器，即httpd，它是Apache团队最早开发的项目，由于它的跨平台和安全性的特点，它成为了世界上最流行的Web服务器软件之一。Apache作为服务器跟Nginx是一样的东西，他们都只支持静态网页，Nginx更轻量，Apache则更稳定。

三是Apache协议（Apache Licence），Apache协议的目的是为了鼓励代码共享，并达到尊重原作者的著作权的作用。你可以使用遵循Apache协议的开源框架并投入商用，但要保留其原有协议声明，如果进行了修改也需要进行说明。

### 什么是Tomcat

![](https://cdn.zhangferry.com/Images/tomcat.png)

Tomcat是由Apache基金会推出的一款开源的可实现JavaWeb程序的Web服务器框架，它是配置JSP（Java Server Page）和JAVA系统必备的一款环境。

它与Apache服务器的区别在于，Apache只支持静态网页，比如博客网站，而Tomcat支持JSP，Servlet，可以实现动态的web应用，像是图书管管理系统。两者也可以结合，处理既有动态又有静态的网站。

### 什么是Docker

![](https://cdn.zhangferry.com/Images/20210326231951.png)

理解Docker之前需要知道容器的概念，容器就是一个封闭的开发环境，类似移动端的沙盒，每个沙盒都可以配置不同的程序，甚至相同程序的不同版本，我在沙盒做的操作不会影响别的沙盒程序。

虚拟机也是一种容器，我可以在不同虚拟机的配置里运行不同的程序，他们互不影响。但是虚拟机太占用系统资源了，不同虚拟机占用不同的内核资源，能否把其中一些共性的东西进行共享？当然是可以的，这就是Docker做的事情。

Docker是一家公司，它还做了一个好事情，就是供了很多配置好的镜像资源（一整套的环境搭建），存储在公共的镜像仓库，大大简化了应用的分发，部署流程。

***

### 什么是VPS

VPS是Virtual Private Server （虚拟专用服务器）的缩写，它可以将一台物理服务器分割成多个虚拟专享服务器，每个虚拟服务器相互隔离，都有各自的操作系统，磁盘空间及IP地址。使用时VPS就像一台真正的实体服务器，并可以根据用户喜好进行定制。

云服务器跟VPS的概念很像，很多时候他们被混用，但其实还是有区别的。云服务器是VPS的升级版，它不再局限于从一台服务器分离出多个虚拟服务器而是，依托于更先进的集群技术，在一组服务器上虚拟出独立服务器，集群中每个服务器都有云服务器的一个镜像，所以云服务器能保证虚拟服务器的安全与稳定。但如果是VPS，你使用的那台主机发生宕机，你的VPS就无法访问了。

### 什么是Ajax

![image.png](https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/1600421961892-7b7a6af6-c661-4886-a973-857376ff4b05.png)

Ajax是Asynchronous Javascript And XML 的缩写，即异步JavaScript和XML，它是一种提高web应用技术交互性的技术方案。

Ajax可以实现在浏览器和服务器之间的异步（不阻塞用户交互）数据传输，并在数据回传至浏览器时局部更新该内容（页面并没有刷新）。这样的好处是即提高了对用户动作的响应又避免了发送多余无用的信息。

第一个著名的Ajax应用是Gmail。

### 什么是UTF-8

UTF-8（8-bit Unicode Transformation Format）是一种Unicode编码形式。Unicode编码是ISO组织制定的包含全球所有文字，符号的编码规范，它规定所有的字符都使用两个字节表示。这样虽然可以包含全球所有文字，但对于仅处于低字节的英文字符也使用两个字节表示，其实是造成了一定程度的空间浪费，于是就有了UTF-8的编码形式。它是动态的使用1-4个字符表示Unicode编码内容的，英文字符占一个字节，此时同ASCII码，中文字符占三个字节。

UTF-8的编码规则总结如下：

```
Unicode符号范围      |        UTF-8编码方式
(十六进制)           |            （二进制）
--------------------+-------------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```

这里再强调一下Unicode和UTF-8的区别：**前者是字符集，后者是编码规则**。

UTF-8编码使用非常广泛，在Cocoa编程环境中其作为官方推荐编码方式，在网页端的展示，UTF-8的应用范围也达到了95%左右。

另外两种编码规则UTF-16和UTF-32的最短长度分别为16位和32位，也会造成一部分的字节浪费，所以都没有UTF-8使用更广。

### 什么是响应式

响应式编程（英语：Reactive programming）是一种专注于数据流和变化传递的异步编程范式。面向对象、面向流程都是一种编程范式，他们的区别在于，响应式编程提高了代码的抽象层级，所以你可以只需关注定义了业务逻辑的那些相互依赖的事件，而非纠缠于大量的实现细节。

很多语言都与对应的响应式实现框架，OC：ReactiveCocoa，Swift：RxSwift/Combine，JavaScript：RxJS，Java：RxJava

响应式的关键在于这几点：

数据流：任何东西都可以看做数据流，一次网络请求、一次Click事件、用户输入、变量等。

变化传递：以上这些数据流单独或者组合作用产生了变化，对别的流有了影响，即为变化传递。

异步编程：非阻塞式的，数据流之间互不干涉。

应用示例：假设一个拥有计时器的场景，当用户关闭该页面和退到后台时暂停定时器，当应用回到前台时开启定时器，另外需要有一个地方展示定时器时间。
以下是用RxSwift实现的代码逻辑：

![image.png](https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/1600940093178-769ca39a-5d60-425b-907c-8585a5afd8b0.png)

### 什么是Catalyst

![image.png](https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/1600940194203-0c5d3a70-3794-4731-af22-5b41514c3318.png)

背景：苹果生态中，长期以来，移端和电脑端的App并不通用，开发者必须写两次代码，设计两套UI界面，才能分别为两个平台制作对应的App。这也直接导致了iOS应用百花齐放，macOS应用却凄凄惨惨戚戚。

Mac Catalyst 正是解决这一问题的技术方案，苹果在19年WWDC上发布它，开发者可以将iPad 应用移植到macOS上，之后也会支持iOS应用的移植。它的意义在于我们可以直接使用UIKit开发macOS应用，BigSur上的短信和地图均使用Mac Catalyst重写过。`Write once，run anywhere`是苹果的最终目标。

Mac Catalyst已被集成进了Xcode（11.0版本及之后），在平台选择选项框中找到mac选项，选中即可，Catalyst功能只有在Catalina及之后的系统版本才能使用。

### 什么是DSL

DSL（Domain Specific Language）即特定领域语言，与DSL相对的就是GPL，这里的 GPL 并不是我们知道的开源许可证，而是 General Purpose Language 的简称，即通用编程语言，也就是我们非常熟悉的 Objective-C、Swift、Python 以及 C 语言等等。

DSL是为了解决某一类任务而专门设计的计算机语言，其通过在表达能力上做的妥协换取在某一领域内的高效。

DSL包含外部DSL和内部DSL，外部DSL包括：Regex、SQL、HTML&CSS

内部DSL包括：基于Ruby构建的项目配置，Podfile、Gemfile、Fastfile文件里的语法

参考资料：https://draveness.me/dsl/

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645)，[zhangferry](https://zhangferry.com)

### 什么是 Homebrew

[Homebrew](https://brew.sh/index_zh-cn "Homebrew") 是一款 Mac OS 平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。

安装方法：

```bash
$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

国内镜像：

```bash
$ /bin/bash -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"
```

### 什么是 Ruby

![](https://cdn.zhangferry.com/Images/ruby_image.png)

Ruby 是一种开源的面向对象程序设计的服务器端脚本语言，在 20 世纪 90 年代中期由日本的松本行弘设计并开发。在 Ruby 社区，松本也被称为马茨（Matz）。 

Ruby的设计和Objective-C有些类似，都是受Smalltalk的影响。而这也一定程度促进了iOS开发工具较为广泛的使用Ruby写成。

较为知名的几个由Ruby写成的iOS开发工具有：CocoaPods、Fastlane、xcpretty。那这些库为啥使用Ruby开来发呢？

来自CocoaPods的主要作者Eloy Duran的说法：

> Ruby和Objective-C具有很多来自Smalltalk的特性，有一定相似性；使用Ruby可以在Bundler和RubyGem之间分享代码；早期阶段MacRuby提供了很多解析Xcode projects的方法；作为CLI工具，Ruby具有强大的字符串处理能力。

来自Fastlane工具链的作者之一Felix的说法：

> 已经有部分iOS工具选择了Ruby，像是CocoaPods以及给Fastlane的开发带来灵感的nomad-cli。使用Ruby将会更容易与这些工具进行对接。

[参考来源：A History of Ruby inside iOS Development](https://medium.com/xcblog/a-history-of-ruby-inside-ios-development-427b5a09f91e "A History of Ruby inside iOS Development")

### 什么是 Rails

![](https://cdn.zhangferry.com/Images/20210419223057.png)

Rails（也叫Ruby on Rails）框架首次提出是在 2004 年 7 月，它的研发者是 26 岁的丹麦人 David Heinemeier Hansson。Rails 是使用 Ruby 语言编写的 Web 应用开发框架，目的是通过解决快速开发中的共通问题，简化 Web 应用的开发。与其他编程语言和框架相比，使用 Rails 只需编写更少代码就能实现更多功能。有经验的 Rails 程序员常说，Rails 让 Web 应用开发变得更有趣。

Rails的两大哲学是：不要自我重复（DRY），多约定，少配置。

松本行弘说过：Ruby能拥有现在的人气，基本上都是Ruby on Rails所作出的贡献。

### 什么是 rbenv

![](https://cdn.zhangferry.com/Images/rbenv_image.png)

[rbenv](https://github.com/rbenv/rbenv "rbenv") 和 RVM 都是目前流行的 Ruby 环境管理工具，它们都能提供不同版本的 Ruby 环境管理和切换。

进行 Ruby 版本管理的时候更推荐 rbenv 的方式，你也可以参考 rbenv 官方的 [Why choose rbenv over RVM?](https://github.com/rbenv/rbenv/wiki/Why-rbenv%3F "Why choose rbenv over RVM?")，当前 rbenv 有两种安装方式：

**手动安装**

```bash
git clone https://github.com/rbenv/rbenv.git ~/.rbenv
# 用来编译安装 ruby
git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build
# 用来管理 gemset, 可选, 因为有 bundler 也没什么必要
git clone git://github.com/jamis/rbenv-gemset.git  ~/.rbenv/plugins/rbenv-gemset
# 通过 rbenv update 命令来更新 rbenv 以及所有插件, 推荐
git clone git://github.com/rkh/rbenv-update.git ~/.rbenv/plugins/rbenv-update
# 使用 Ruby China 的镜像安装 Ruby, 国内用户推荐
git clone git://github.com/AndorChen/rbenv-china-mirror.git ~/.rbenv/plugins/rbenv-china-mirror
```

**homebrew安装**

```bash
$ brew install rbenv
```

**配置**

安装完成后，把以下的设置信息放到你的 Shell 配置文件里面，以保证每次打开终端的时候都会初始化 rbenv。

```bash
export PATH="$HOME/.rbenv/bin:$PATH" 
eval "$(rbenv init -)"
# 下面这句选填
export RUBY_BUILD_MIRROR_URL=https://cache.ruby-china.com
```

配置Ruby 环境，需重开一个终端。

```bash
$ rbenv install --list               # 列出所有 ruby 版本
$ rbenv install 2.7.3              # 安装 2.7.3版本
$ rbenv versions               # 列出安装的版本
$ rbenv version                # 列出正在使用的版本
# 下面三个命令可以根据需求使用
$ rbenv global 2.7.3               # 默认使用 1.9.3-p392
$ rbenv shell 2.7.3       # 当前的 shell 使用 2.7.3, 会设置一个`RBENV_VERSION` 环境变量
$ rbenv local 2.7.3                       # 当前目录使用 2.7.3, 会生成一个 `.rbenv-version` 文件
```

### 什么是 RubyGems

> The RubyGems software allows you to easily download, install, and use ruby software packages on your system. The software package is called a “gem” which contains a packaged Ruby application or library.

RubyGems 是 Ruby 的一个依赖包管理工具，管理着 Gem。用 Ruby 编写的工具或依赖包都称为 Gem。

RubyGems 还提供了 Ruby 组件的托管服务，可以集中式的查找和安装 library 和 apps。当我们使用 gem install 命令安装 Gem 时，会通过 rubygems.org 来查询对应的 Gem Package。而 iOS 日常中的很多工具都是 Gem 提供的，例如 Bundler，fastlane，jazzy，CocoaPods 等。

在默认情况下 Gems 总是下载 library 的最新版本，这无法确保所安装的 library 版本符合我们预期。因此还需要 Gem Bundler 配合。

[参考：版本管理工具及 Ruby 工具链环境](https://mp.weixin.qq.com/s/s2yJEb2P0_Kk-rIpYBi_9A)

### 什么是 Bundler

![](https://cdn.zhangferry.com/Images/20210419225753.png)

[Bundler](https://www.bundler.cn/ "Bundler") 是一个管理 Gem 依赖的 Gem，用来检查和安装指定 Gem 的特定版本，它可以隔离不同项目中 Gem 的版本和依赖环境的差异。

你可以执行 `gem install bundler` 命令安装 Bundler，接着执行 `bundle init` 就可以生成一个 Gemfile 文件，你可以在该文件中指定 CocoaPods 和 fastlane 等依赖包的特定版本号，比如：

```
source "https://rubygems.org"
gem "cocoapods", "1.10.0"
gem "fastlane", "> 2.174.0"
```

然后执行 `bundle install` 来安装 Gem。 Bundler 会自动生成一个 Gemfile.lock 文件来锁定所安装的 Gem 的版本。

这一步只是安装指定版本的 Gem，使用的时候我们需要在 Gem 命令前增加 `bundle exec`，以保证我们使用的是项目级别的 Gem 版本（也就是 Gemfile.lock 文件中锁定的 Gem 版本），而不是操作系统级别的 Gem 版本。

```bash
$ bundle exec pod install
$ bundle exec fastlane beta
```

[参考：iOS开发进阶](https://t1.lagounews.com/kR50RoRgcj04C)

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645)，[zhangferry](https://zhangferry.com)

本期选题来源于林永坚的 [iOS开发进阶](https://t8.lagounews.com/dR5FRrRtcO4F8) 课程里的「跨平台架构：如何设计 BFF 架构系统？」这一节内容。如有表述不准确的地方，欢迎指出，定会及时改正。

### 什么是 RESTful

RESTful 里的 REST 是 Representational State Transfer 的缩写，翻译过来就是：表现层状态转化。它是一种互联网软件架构，处理的问题是如何开发在互联网环境中使用的软件。

从含义入手：表现层状态转化。表现层是互联网资源呈现的形式，例如 HTML，JSON 等，转化就是资源等数据的变化，查询数据，更新数据。

RESTful 架构一般满足以下三点即可：

1、一个 URI 代表一种资源

2、客户端和服务器之间，传递这种资源的某种表现层

3、客户端通过 4 个 HTTP 动词，对服务器端资源进行操作，实现“表现层状态转化“。

参考：[理解 RESTful 架构 - 阮一峰](https://www.ruanyifeng.com/blog/2011/09/restful.html "理解 RESTful 架构")

### 什么是 SOAP

SOAP，全称是 Simple Object Access Protocol，即简单对象访问协议。从 W3C SOAP 1.2 版开始，SOAP 这一缩写不再代表 Simple Object Access Protocol，而是仅仅作为协议名称而已。

SOAP 是一种相对古老（比 REST 还要早）的网络通信协议，它主要是基于 XML 进行传输的。SOAP 和 REST 是早期互联网应用常用的两种方案。

对于应用程序开发来说，使程序之间进行因特网通信是很重要的。目前的应用程序通过使用远程过程调用（RPC）在诸如 DCOM 与 CORBA 等对象之间进行通信，但是 HTTP 不是为此设计的。RPC 会产生兼容性以及安全问题；防火墙和代理服务器通常会阻止此类流量。通过 HTTP 在应用程序间通信是更好的方法，因为 HTTP 得到了所有的因特网浏览器及服务器的支持。SOAP 就是被创造出来完成这个任务的。SOAP 提供了一种标准的方法，使得运行在不同的操作系统并使用不同的技术和编程语言的应用程序可以互相进行通信。

参考：[SOAP 简介 - 菜鸟](https://www.runoob.com/soap/soap-intro.html "SOAP 简介 - 菜鸟")

### 什么是 BFF

BFF，全称是 Backend For Frontend，即服务于前端的后端，它是一种解决 REST 接口数据冗余的架构模型。

在 REST 模型下每个接口都对于一个服务器请求，当出现多个端，接口越来越多的情况该架构会面临很多问题。而BFF 就是用于解决这类问题出现的。

你可以把 BFF 当作一个中间层，而引入 BBF 后，前端只需要向 BFF 发送一个请求，由 BFF 与后端进行交互，然后将返回值整合后返回给前端，降低前端与后端之间的耦合，方便前端接入。除了整合数据外，你还可以在 BFF 层对数据进行裁剪过滤，或者其他业务逻辑处理，而不用在多个前端中做相同的工作。当后端发生变化时，你只需要在 BFF 层做相应的修改，而不用修改多个前端，这极大地减少了的工作量。

随着业务的发展，单个 BFF 为了适配多端的差异可能会变得越来越臃肿，可维护性降低，开发成本也会越来越高。这时候就得考虑为对 BFF 层进行拆分，给每种用户体验不同的前端分别对应一个 BFF，比如 PC BFF、移动端 BFF（或者再细拆为 iOS BFF 和 Android BFF） 等等，所以 BFF 也称为面向特定用户体验的适配层。

![BFF](https://cdn.zhangferry.com/Images/20210430111611.png)

参考：[BFF —— Backend For Frontend](https://www.jianshu.com/p/eb1875c62ad3 "BFF —— Backend For Frontend")

### 什么是 GraphQL

GraphQL（展开为 Graph Query Language）是 Facebook 开发的应用层查询语言，于 2015 年开源。注意这里是查询语言，跟 SQL 的 Structured Query Language 类似，也是一种 DSL。

>  GraphQL 的本质是程序员想对 JSON 使用 SQL。 —— 来自阮一峰的翻译

它是一种 BFF 的实现方案。REST 数据是通过一个个 URI 定位到的，而 GraphQL 的模型更像是对象模型。GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。

![](https://cdn.zhangferry.com/Images/33034116-558F-40ED-B191-31D9E28715F2.png)

这里 GraphQL 起的是一个 API 网关的作用。

参考：[GraphQL](https://graphql.cn/ "GraphQL")

### 什么是 RPC

RPC，全称是 Remote Procedure Call，即远程过程调用。RPC 是一种进程间通信方式，它允许客户端应用直接调用另一台远程不同计算机上的服务端应用的方法，而不需要了解远程调用的实际通信细节实现。RPC 会做好数据的序列化和传输，使得远程调用就像本地调用一样方便，让创建分布式应用和服务变得更加简单。促使 RPC 诞生的领域既是分布式。

RPC 的工作流程大致是：客户端应用以本地调用的方式发起远程调用，将参数以及附加信息序列化为能够进行网络传输的消息体，并将消息发送给服务端。服务端对收到的消息进行反序列化后执行请求，然后将结果序列化为消息并返回给客户端。最后客户端接收到消息并反序列化得到数据。

![RPC](https://cdn.zhangferry.com/Images/20210501090439.png)

> RPC 框架可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。 —— 来自王争的《设计模式之美》

常见的 RPC 框架有：gRPC、Dubbo、rpcx、Motan、thrift、brpc、Tars 等等。

### 什么是 gRPC

gRPC 是 Google 开发的一个高性能、通用的开源 RPC 框架。它使用 HTTP/2 作为传输协议，protocol buffers 作为底层传输格式（默认），protocol buffers 还可以作为接口描述语言。

在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。

![gRPC](https://cdn.zhangferry.com/Images/20210501090350.png)

gRPC 客户端和服务端可以在多种环境中运行和交互 -- 从 Google 内部的服务器到你自己的笔记本，并且可以用任何 gRPC 支持的语言来编写。所以，你可以很容易地用 Java 创建一个 gRPC 服务端，用 Go、Python、Ruby 来创建客户端。此外，Google 最新 API 将有 gRPC 版本的接口，使你很容易地将 Google 的功能集成到你的应用里。

Facebook 的调试工具 [idb](https://fbidb.io/)（作为 WebDriverAgent 的替代者）里的 `idb_companion` 就是一个 gRPC 服务器。

参考：[what-is-grpc](https://grpc.io/docs/what-is-grpc/introduction/ "what-is-grpc")

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645)，[zhangferry](https://zhangferry.com)

该期主题来源于对 [xuan总](https://github.com/crisxuan) 的那篇 [程序必知的硬核知识大全](https://github.com/zhangferry/iOSWeeklyLearning/tree/main/Resources/Books) 的部分总结，引用图片也来源于此，该文档已经过其本人授权放到了周报仓库里，有兴趣的读者可以去下载全文阅读。

### 什么是 CPU

中央处理器（Central Processing Unit，简称 CPU）作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。CPU 与计算机的关系就相当于大脑和人的关系。它是一种小型的计算机芯片，嵌入在电脑的主板上。通过在单个计算机芯片上放置数十亿个微型晶体管来构建 CPU。这些晶体管使它能够执行运行存储在系统内存中的程序所需的计算，也就是说 CPU 决定了你电脑的计算能力。

CPU 的功能主要是解释计算机指令以及处理计算机软件中的数据。几乎所有的冯·诺依曼型计算机的 CPU 的工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数、结果写回。

在指令执行完毕后、结果数据写回之后，若无意外事件（如结果溢出等）发生，计算机就接着从程序计数器中取得下一条指令的地址，开始新一轮的循环。许多新型 CPU 可以同时取出、译码和执行多条指令，体现并行处理的特性。

从功能来看，CPU 的内部由寄存器、控制器、运算器和时钟四部分组成，各部分之间通过电信号连通。对程序员来说，我们只需要了解寄存器就可以了。

* 寄存器负责暂存指令、数据和地址。
* 控制器负责把内存上的指令、数据读入寄存器，并根据指令的结果控制计算机。
* 运算器负责运算从内存中读入寄存器的数据。
* 时钟负责发出 CPU 开始计时的时钟信号。

CPU 相关内容还有两个我们经常遇到的概念：位数、架构。

当前常见的 CPU 位数是 32 位和 64 位，这里的位数是指 CPU 一次可以处理的数据位数，就效率上来说 64 位的 CPU 会比 32 位的 CPU 提高一倍。

架构指的是 CPU 的设计架构，目前主流的架构是 x86 和 ARM 两种。

* x86 是 Intel 芯片选用的架构，它包含 32 位和 64 位，通常 64 位的 x86 架构被表述为 x86_64。该架构芯片多用于 PC 机。
* ARM 架构是一个精简指令集（RISC）处理器架构家族，其多用于嵌入式操作系统及手机端。iPhone 上的 A 系列 CPU 就一直是 ARM 架构。ARM 的发展史从 ARMv1 一直到当前的 ARMv8。初代 iPhone 到 iPhone 3GS 之前使用的是 ARMv6；从 3GS 到 5s 之前使用的 ARMv7 架构，5s 开始使用的 ARMv8。但其实 ARMv8 这个叫法却很少出现，而更多的是 ARM64。这是因为从 v8 版本开始分 32 位和 64 位两种（在这之前没有 64 位），苹果使用的都是 64 位，所以就用 ARM64 代替了。

### 什么是寄存器

寄存器是 CPU 内的组成部分，是用来暂存指令、数据和地址的电脑存储器。

不同的类型的 CPU，其内部寄存器的种类，数量以及寄存器存储的数值范围是不同的。不过，可以根据功能将寄存器划分为下面几类：

* 累加寄存器：存储运行的数据和运算后的数据。
* 标志寄存器：用于反应处理器的状态和运算结果的某些特征以及控制指令的执行。
* 程序计数器：用来存储下一条指令所在单元的地址。
* 基址寄存器：存储数据内存的起始位置。
* 变址寄存器：存储基址寄存器的相对位置。
* 通用寄存器：存储任意数据。
* 指令寄存器：存储正在被运行的指令，CPU 内部使用，程序员无法对该寄存器进行读写。
* 栈寄存器：存储栈区域的起始位置。

其中，累加寄存器、标志寄存器、程序计数器、指令寄存器和栈寄存器都只有一个，其它寄存器一般有多个。

![](https://cdn.zhangferry.com/Images/20210515221243.png)

寄存器的命名是跟着 CPU 类型走的，ARM64 类型的 CPU 有 32 个寄存器，以下列出了部分寄存器的特殊作用：

| 寄存器                     | 作用                                 |
| ----------------------- | ---------------------------------- |
| x0、x1、x2、x3、x4、x5、x6、x7 | 保存函数参数及返回值                         |
| x29                     | lr（link register）寄存器，保存函数的返回地址     |
| x30                     | sp（stack pointer）寄存器，保存栈地址         |
| x31                     | pc（program counter）寄存器，指向下一条将执行的指令 |

### 什么是程序计数器

程序计数器（Program Counter，简称 PC）是一种寄存器，一个 CPU 内部仅有一个 PC。为了保证程序能够连续地执行下去，CPU 必须具有某些手段来确定下一条指令的地址。而 PC 正是起到这种作用，其用来存储下一条指令所在单元的地址，所以通常又称之为“指令计数器”。

PC 的初值为程序第一条指令的地址。程序开始执行，CPU 需要先根据 PC 中存储的指令地址来获取指令，然后将指令由内存取到指令寄存器（存储正在被运行的指令）中，然后解码和执行该指令，同时 CPU 会自动修改 PC 的值为下一条要执行的指令的地址。完成第一条指令的执行后，根据程序计数器取出第二条指令的地址，如此循环，执行每一条指令。

每执行一条指令后，PC 的值会立即指向下一条要执行的指令的地址。当顺序执行时，每执行一条指令，PC 的值就是简单的 +1。而条件分支和循环执行等转移指令会使 PC 的值指向任意的地址，这样程序就可以跳转到任意指令，或者返回到上一个地址来重复执行同一条指令。

![](https://cdn.zhangferry.com/Images/20210515222022.png)

### 什么是内存

内存是计算机中最重要的部件之一，它是程序与 CPU 进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，内存又被称为主存，其作用是存放 CPU 中的运算数据，以及与硬盘等外部存储设备交换的数据。只要计算机在运行中，CPU 就会把需要运算的数据调到内存中进行运算，当运算完成后 CPU 再将结果传送出来。

内存通过控制芯片与 CPU 进行相连，由可读写的元素构成，每个字节都带有一个地址编号，注意是一个字节，而不是一个位。CPU 通过地址从内存中读取数据和指令，也可以根据地址写入数据。注意一点：当计算机关机时，内存中的指令和数据也会被清除。

物理结构：内存的内部是由各种 IC 电路组成的，它的种类很庞大，但是其主要分为三种存储器。

* 随机存储器（RAM）：内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。
* 只读存储器（ROM）：ROM 一般只能用于数据的读取，不能写入数据，但是当机器停电时，这些数据不会丢失。
* 高速缓存（Cache）：Cache 也是我们经常见到的，它分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache）这些数据，它位于内存和 CPU 之间，是一个读写速度比内存更快的存储器。当 CPU 向内存中写入数据时，这些数据也会被写入高速缓存中。当 CPU 需要读取数据时，会之间从高速缓存中直接读取，当然，如需要的数据在 Cache 中没有，CPU 会再去读取内存中的数据。

### 什么是 IC

集成电路（Integrated Circuit，缩写为 IC）。顾名思义，就是把一定数量的常用电子元件，如电阻、电容、晶体管等，以及这些元件之间的连线，通过半导体工艺集成在一起的具有特定功能的电路。

内存和 CPU 使用 IC 电子元件作为基本单元。IC 电子元件有不同种形状，但是其内部的组成单位称为一个个的引脚。IC 元件两侧排列的四方形块就是引脚，IC 的所有引脚只有两种电压：0V 和 5V，该特性决定了计算机的信息处理只能用 0 和 1 表示，也就是二进制来处理。一个引脚可以表示一个 0 或 1，所以二进制的表示方式就变成 0、1、10、11、100、101 等，虽然二进制数并不是专门为引脚设计的，但是和 IC 引脚的特性非常吻合。

![](https://cdn.zhangferry.com/Images/20210515222223.png)

我们都知道内存是用来存储数据的，那么这个 IC 中能存储多少数据呢？D0 - D7 表示的是数据信号，也就是说一次可以输入输出 1 byte = 8 bit 数据。A0 - A9 是地址信号，共10个，表示可以指定 2^10 = 1024 个地址。每个地址都都可存放 1 byte 数据，所以这个 IC 的容量就是 1KB。

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645)，[zhangferry](https://zhangferry.com)

这期是对 [程序必知的硬核知识大全](https://github.com/zhangferry/iOSWeeklyLearning/blob/main/Resources/Books/xuan-computer-basic.pdf "程序必知的硬核知识大全") 的第二部分总结，有兴趣的读者可以下载全文阅读。

### 什么是二进制

计算机内部是由 IC 电子元件组成的，其中 CPU 和 内存 也是 IC 电子元件的一种。IC 内部由引脚组成，所有引脚只有两种电压：0V 和 5V，该特性决定了计算机的信息处理只能用 0 和 1 表示，也就是二进制来处理。二进制由几个重要的概念，这里简要介绍下：

**补数**

如果用8位表示一个有符号整数，最高位为符号位，1 的表示为`0000 0001`。那 -1 该如何表示呢？答案是：`1111 1111`。如果你首次看到这个表示法可能很奇怪，为什么不是`1000 0001`呢，其实它是基于加法运算推演出来的结果。我们用让计算机计算`1 - 1`，即`1 + (-1)`，即`0000 0001 + 1111 1111` 结果为 `1 0000 0000`，舍去溢出的高位 1，结果就是 0 。所以 -1 对应到二进制就成了`1111 1111`。从正数到负数的表示，产生了补数的概念，它的计算是这样的：

![](https://cdn.zhangferry.com/Images/20210522135424.png)

这个就是 1 到 -1 的计算方式。

**移位运算**

移位分两种，逻辑移位和算数移位，看下面示例：

![](https://cdn.zhangferry.com/Images/20210522223515.png)

逻辑移位会在空缺部分补 0，算数右移会在空缺部分补符号位。左移的话都是补 0，没有区别。

代码中通常使用的 `>>`、`<<`符号都是算数移位，因为右移一位会让数值缩小为原来的一半，所以某些二分查找的写法会使用该技巧。

### 什么是大端小端

计算机硬件主要有两种数据存储方式，大端字节序（Big-Endian）和小端字节序（Little-Endian），其实还有一个中端字节序（Middle- Endian），因为用的很少这里不再介绍。

大端和小端的差别是什么呢，看一个例子。比如 32bit 宽的数`0x12345678`在 小端模式内存中的存放方式（假设从地址0x4000开始存放）为：

| 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
| ---- | ------ | ------ | ------ | ------ |
| 存放内容 | 0x78   | 0x56   | 0x34   | 0x12   |

而在大端模式内存中的存放方式则为：

| 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
| ---- | ------ | ------ | ------ | ------ |
| 存放内容 | 0x12   | 0x34   | 0x56   | 0x78   |

他们的区别是，在低字节处，小端模式存储的是低位，而大端存储的是高位。因为我们的习惯是先看高位后看低位，所以大端更符合人们的直觉；但是处理器在处理数据时先从低位处理效率会更高一些。这就是存在大端小端两种模式的原因。

目前 iOS 和macOS应用都使用的小端模式，可以通过以下方法验证：

```objectivec
if (NSHostByteOrder() == NS_BigEndian) {
     NSLog(@"BigEndian");
} else if (NSHostByteOrder() == NS_LittleEndian) {
     NSLog(@"LittleEndian");
}
```

### 什么是缓存

内存的内部是由各种 IC 电路组成的，它的种类很庞大，但是其主要分为三种存储器：随机存储器（RAM）、只读存储器（ROM）和高速缓存（Cache）。高速缓存通常又会分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache），它位于内存和 CPU 之间，是一个读写速度比内存更快的存储器。以上分类从前往后速度越来越快。

![](https://cdn.zhangferry.com/Images/20210522223549.png)

为什么会有这么多缓存呢？主要是有两方面的考虑：速度和成本。读取速度越高的设备成本也会越高，为了在这两者之间进行平衡才加入了各个缓存。后者都可以作为前者的缓存，比如可以把主存作为硬盘的缓存，也可以把高速缓存作为主存的缓存。

以下是各种设备的读取速度对比：

![](https://cdn.zhangferry.com/Images/20210522143424.png)

缓存的使用逻辑大致是，没有对应数据时向上一级寻找，如果找到了就在当级缓存下来，下次再寻找相同的内容就可以直接从当级的缓存调用了。因为作为缓存的部分一般都比其上一级容量更小，所以缓存内容就不可能一直存在，需要按照一定规则进行移除，这就引出了LRU（Least Recently Used，最近最少使用）算法，它是将最近一段时间内最少被访问过的数据淘汰出缓存，提高缓存的利用率。

图片来源：[bowdoin.edu lec18.pdf](https://www.bowdoin.edu/~sbarker/teaching/courses/systems/18spring/lectures/lec18.pdf "bowdoin.edu lec18.pdf")

### 什么是压缩算法

压缩算法 (compaction algorithm) 指的就是数据压缩的算法，主要包括压缩和还原 (解压缩) 的两个步骤。其实就是在不改变原有文件属性的前提下，降低文件字节空间和占用空间的一种算法。 

根据压缩算法的定义，我们可将其分成不同的类型： 

**有损和无损** 

无损压缩：能够无失真地从压缩后的数据重构，准确地还原原始数据。可用于对数据的准确性要求严格的场合，如可执行文件和普通文件的压缩、磁盘的压缩，也可用于多媒体数据的压缩。该方法的压缩比较小。如差分编码、RLE、Huffman 编码、LZW 编码、算术编码。 

有损压缩：有失真，不能完全准确地恢复原始数据，重构的数据只是原始数据的一个近似。可用于对数据的准确性要求不高的场合，如多媒体数据的压缩。该方法的压缩比较大。例如预测编码、音感编码、分形压缩、小波压缩、JPEG/MPEG。 

**对称性** 

如果编解码算法的复杂性和所需时间差不多，则为对称的编码方法，多数压缩算法都是对称的。但也有不对称的，一般是编码难而解码容易，如 Huffman 编码和分形编码。但用于密码学的编码方法则相反，是编码容易，而解码则非常难。 

**帧间与帧内** 

在视频编码中会同时用到帧内与帧间的编码方法，帧内编码是指在一帧图像内独立完成的编码方法，同静态图像的编码，如 JPEG；而帧间编码则需要参照前后帧才能进行编解码，并在编码过程中考虑对帧之间的时间冗余的压缩，如 MPEG。 

**RLE编码**

RLE 是 run-length encoding的缩写，中文翻译为游程编码，是一种根据编码字符次数进行统计的无损压缩算法。举例来说，一组资料串"AAAABBBCCDEEEE"，由4个A、3个B、2个C、1个D、4个E组成，经过 RLE 可将资料压缩为4A3B2C1D4E（由14个单位转成10个单位）。

**哈弗曼编码**

哈夫曼编码是一种使用变长编码表对源符号进行编码的无损压缩编码方式。其特征是对于出现频率较高的字符使用较短的编码符号。对于 AAAAAABBCDDEEEEEF 这几个字符使用哈夫曼编码的结果如下：

![](https://cdn.zhangferry.com/Images/20210522213007.png)

***

整理编辑：[师大小海腾](https://juejin.cn/user/782508012091645)，[zhangferry](https://zhangferry.com)

### 什么是 BIOS

BIOS 全称为 Basic Input Output System，即基本输入输出系统。BIOS 是预先内置在计算机主机内部的程序，也是计算机开机后加载的第一个程序。BIOS 保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从 CMOS（是电脑主板上的一块可读写的 RAM 芯片）中读写系统设置的具体信息。

BIOS 除了键盘，磁盘，显卡等基本控制程序外，还有`引导程序`的功能。引导程序是存储在启动驱动器起始区域的小程序，操作系统的启动驱动器一般是硬盘。不过有时也可能是 CD-ROM 或软盘。

电脑开机后，BIOS 会确认硬件是否正常运行，没有异常的话就会直接启动引导程序，引导程序的功能就是把在硬盘等记录的 OS 加载到内存中运行，虽然启动应用是 OS 的功能，但 OS 不可以自己启动自己，而是通过引导程序来启动。

制作黑苹果的时候安装的 Clover 就是一个启动程序，它通过修改 BIOS 配置，让 BIOS 首先执行它，然后由它来引导至 MacOS 的启动。

![](https://cdn.zhangferry.com/Images/20210527232231.png)

严格意义来说 BIOS 是 IBM PC架构上的一种设计规范，Mac电脑，包括一些新型的主板都没有 BIOS 这一概念，取而代之的是 EFI/UEFI。

### 什么是汇编

汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。

汇编语言比机器语言的可读性要好，但跟高级语言比较而言，可读性还是较差。不过采用它编写的程序具有存储空间占用少、执行速度快的特点，这些是高级语言所无法取代的。在实际应用中，是否使用汇编语言，取决于具体应用要求、开发时间和质量等方面作权衡。汇编常用的指令如下：

| 操作码  | 操作数  | 功能               |
| ---- | ---- | ---------------- |
| mov  | A, B | 把B的值赋给A          |
| and  | A, B | 把A和B同时相加，并把结果赋给A |
| push | A    | 把A的值存储在栈中        |
| pop  | A    | 从栈中读出值，并将其赋值给A   |
| call | A    | 调用函数A            |
| ret  | 无    | 处理返回给调用源函数       |

### 什么是虚拟机

虚拟机（Virtual Machine）是指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的 CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。

虚拟机的主要用处有：

1. 演示环境，可以安装各种演示环境，便于做各种例子
2. 保证主机的快速运行，减少不必要的垃圾安装程序，偶尔使用的程序，或者测试用的程序在虚拟机上运行
3. 避免每次重新安装，银行等常用工具，不经常使用，而且要求保密比较好的，单独在一个环境下面运行
4. 想测试一下不熟悉或者有风险的应用，在虚拟机中随便安装和彻底删除
5. 体验不同版本的操作系统，如 Linux、Mac 等。

虚拟机目前可分为三类：

* 系统虚拟机，例如：VMware
* 程序虚拟机，例如：JVM（Java Virtual Machine）
* 操作系统层虚拟化，例如：Docker

### 什么是外围中断

IRQ（Interrupt Request）代表的就是中断请求。IRQ 是用来暂停当前正在运行的程序，并跳转到其他程序运行的必要机制。该机制被称为处理中断。中断处理在硬件控制中担当着重要的角色。因为如果没有中断处理，就有可能无法顺畅进行处理的情况。

从中断处理开始到请求中断的程序（中断处理程序）运行结束之前，被中断的程序（主程序）的处理是停止的。这种情况就类似于在处理文档的过程中有电话打进来，电话就相当于是中断处理。假如没有中断处理的发生，就必须等到文档处理完成后才能够接听电话。由此可见，中断处理有着巨大的价值，就像是接听完电话后会返回原来的文档作业一样，中断程序处理完成后，也会返回到主程序中继续。

![中断请求示意图](https://cdn.zhangferry.com/Images/20210526233248.png)

**实施中断请求的是连接外围设备的 I/O 控制器，负责实施中断处理的是 CPU。**

假如有多个外围设备进行中断请求的话， CPU 需要做出选择进行处理，为此，我们可以在 I/O 控制器和 CPU 中间加入名为中断控制器的 IC 来进行缓冲。中断控制器会把从多个外围设备发出的中断请求有序的传递给 CPU。中断控制器的功能相当于就是缓冲。下面是中断控制器功能的示意图

![中断控制器的功能](https://cdn.zhangferry.com/Images/20210526233322.png)

### 什么是 DMA

DMA 全称为 Direct Memory Access，即直接存储器访问。DMA 是一种内存访问机制，它是指在不通过 CPU 的情况下，外围设备直接和主存进行数据传输。磁盘等硬件设备都用到了 DMA 机制，通过 DMA，大量数据就可以在短时间内实现传输，之所以这么快，是因为 CPU 作为中介的时间被节省了，下面是 DMA 的传输过程

![使用 DMA 的外部设备和不使用 DMA 的外部设备](https://cdn.zhangferry.com/Images/20210527220519.png)

I/O 端口号、IRQ、DMA 通道可以说是识别外围设备的 3 点组合。不过，IRQ、DMA 通道并不是所有外围设备都具备的。计算机主机通过软件控制硬件时所需要的信息的最低限，是外围设备的 I/O 端口号。IRQ 只对需要中断处理的外围设备来说是必须的，DMA 通道则只对需要 DMA 机制的外围设备来说必须的。

***

从本期开始，编程概念模块将介绍前端相关的多个概念。本期带来的内容是对 `React`、`React Native`、`Vue` 的介绍。如有错误，欢迎指正。

### 关于前端

通常我们说的前端有两个含义，一个是特指 Web 前端，其跟移动端平级；另一个指大前端，其包含移动端。这里咱们取的含义是 Web 前端。

Web 前端的主要技术是围绕 HTML/CSS、 JavaScript 发展的。在过去的十年里，得益于 JS，网页变得更加动态化和强大，我们把很多的服务端代码放到了浏览器中，这样就产生了成千上万行的 JS 代码，它们链接了各式各样的 HTML 和 CSS 文件，但缺乏正规的组织形式，这就是为什么越来越多的开发者使用 JS 框架来组织代码，诸如 React、Vue、Angular 等。

### 什么是 React

![](https://cdn.zhangferry.com/Images/20210605211826.png)

内容整理：[zhangferry](https://zhangferry.com)

[React](https://reactjs.org/) 是由 Facebook 开发的用于构建用户界面的 JavaScript 库，其已开源在 Github，拥有 169k 的超高 star 数，在前端领域使用极广泛。

它有这三大特性：

* 声明式：React 使创建交互式 UI 变得轻而易举，为你应用的每一个状态设计简洁的视图，当数据变动时 React 能高效更新并渲染合适的组件。
* 组件化：构建管理自身状态的封装组件，然后对其组合成复杂的 UI。
* 一次学习，扩平台编写：无论你现在使用什么技术栈，在无需重写现有代码的前提下，都可以通过引入 React 来开发新功能。React 还可以使用 Node 进行服务器渲染，或使用 [React Native](https://reactnative.dev/) 开发原生移动应用。

我们来看一个官网的例子来简单了解下 React 的使用，我们的目的是要实现一个前端 Markdown 渲染的效果，上面是输入框，下面是渲染的 HTML 效果，这里使用一个名为 **remarkable** 的外部库，代码如下：

```java
// React.Component 就是内置组件，其有一系列组件
class MarkdownEditor extends React.Component {
  // 构造函数，类似init
  constructor(props) {
    super(props);
    // 外部库
    this.md = new Remarkable();
    // 绑定自身变化
    this.handleChange = this.handleChange.bind(this);
    // 默认内容
    this.state = { value: 'Hello, **world**!' };
  }
    // 监听输入框的变化
  handleChange(e) {
    this.setState({ value: e.target.value });
  }
    // 渲染出的html
  getRawMarkup() {
    return { __html: this.md.render(this.state.value) };
  }
    // 界面
  render() {
    return (
      <div className="MarkdownEditor">
        <h3>Input</h3>
        <label htmlFor="markdown-content">
          Enter some markdown
        </label>
        <textarea
          id="markdown-content"
          onChange={this.handleChange}
          defaultValue={this.state.value}
        />
        <h3>Output</h3>
        <div
          className="content"
          dangerouslySetInnerHTML={this.getRawMarkup()}
        />
      </div>
    );
  }
}
// 渲染
ReactDOM.render(
  <MarkdownEditor />,
  document.getElementById('markdown-example')
);
```

### 什么是 React Native

内容整理：[我是熊大](https://juejin.cn/user/1151943916921885/posts)

[React Native](https://reactnative.dev/) 是一个使用 `React` 和应用平台的原生功能来构建 Android 和 iOS 应用的开源框架，其已经不是一个 Web 前端框架，而是一个移动端框架。通过 React Native，可以使用 JavaScript 来访问移动平台的 API，以及使用 React 组件来描述 UI 的外观和行为：一系列可重用、可嵌套的代码。通过一张图简单了解下 React Native 在移动开发中的架构：

![](https://cdn.zhangferry.com/Images/20210605200722.png)

其具有这些特点：跨平台（JavaScript 框架）虚拟 DOM、热更新，iOS 审核有限制、对 Web 开发者友好，上手快，性能几乎和原生相当。

React Native 的不足：

- 由于 React Native 和原生交互依赖的只有一个 Bridge，而且 JS 和 Native 交互是异步的，所以对于需要和 Native 大量实时交互的功能可能会有性能上的不足，比如动画效率，性能是不如原生的。
- React Native 始终是依赖原生的能力，所以摆脱不了对原生的依赖，相对 Flutter 的自己来画 UI 来说，React Native 显得有些尴尬。

引入 React Native 是基于 JavaScript 实现的，所以要在 iOS 端使用它的话，我们就需要安装 `Node.js`，并利用 Node 工具安装 React Native。以下介绍一个简单步骤：

```bash
# 使用 Homebrew 来安装 Node
brew install node

# 安装 yarn
npm install -g yarn

# 创建项目
npx react-native init MoyuDemo

cd MoyuDemo

yarn ios
```

参考资料：[React Native 中文网](https://reactnative.cn/docs/getting-started "React Native 中文网")，[React Native 原理与实践](https://zhuanlan.zhihu.com/p/343519887 "React Native 原理与实践")

### 什么是 Vue

![](https://cdn.zhangferry.com/Images/20210605011045.png)

内容整理：[师大小海腾](https://juejin.cn/user/782508012091645)

[Vue](https://cn.vuejs.org/)（读音 /vjuː/）即 Vue.js。作者尤雨溪曾在知乎回答到，Vue 之所以叫 Vue，是因为它是个视图层库，而 vue 是 view 的法语。其是一套用于构建用户界面的**渐进式** JS 框架。

**渐进式的含义是它被设计为可以自底向上逐层应用。**

这是 Vue 与其他 JS 框架最大的不同。渐进式框架简单理解就是：你可以只用我的一部分，而非必须用我的全部；你可以仅将我作为应用的一部分嵌入，而非必须全部使用。Vue 支持你根据实际需求，在不同的阶段使用 Vue 中不同的功能，用最小最快的成本一步步搭建应用，不断渐进，而不是要求你一下子用上全家桶（vue-cli、vue-router、vuex 等）。

![](https://cdn.zhangferry.com/Images/20210605012155.png)

你可以看看：[Vue 作者尤雨溪：Vue 2.0，渐进式前端解决方案](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247485737&idx=1&sn=14fe8a5c72aaa98c11bf6fc57ae1b6c0&source=41#wechat_redirect "Vue作者尤雨溪：Vue 2.0，渐进式前端解决方案")

**Vue 的核心库只关注视图层，通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件**

在 HTML 中，DOM 就是视图，我们把 HTML 中的 DOM 与其他的部分独立开来划分出一个层次，这个层次就叫做视图层。如果页面元素很多，数据和视图像传统开发一样全部混合在 HTML 中话就很难维护，因此我们要把视图层抽取出来并且单独去关注它。Vue 只关注视图层，是一个构建数据的视图集合。

Vue 支持数据的双向绑定。即数据变化驱动视图更新，视图更新也会驱动数据变化。而我们只需要通过简单的 API 即可实现这种绑定关系。

Vue 允许你将一个网页分割成多个可复用的组件，每个组件都包含属于自己的 HTML、CSS、JS 以用来渲染网页中相应的地方，然后将这些组件自由组合成完整的网页。

**Vue 具有易用、灵活、高效的特点**

- 易用：在有 HTML、CSS、JavaScript 的基础上，可以快速上手
- 灵活：不断繁荣的生态系统，可以在一个库和一套完整框架之间自如伸缩
- 高效：20kB min+gzip 运行大小，超快虚拟 DOM，最省心的优化

**一个例子**

我们来看一个使用 Vue 写出来的小例子：一个输入框，一个文本，文本能够根据输入框内容的变化而变化：

HTML代码：

```html
<div id="app-6">
  <p>{{ message }}</p>
     <!-- Vue 提供了 v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定 -->
  <input v-model="message">
</div>
```

JS 代码：

```javascript
var app6 = new Vue({
  el: '#app-6',
  data: {
    message: 'Hello Vue!'
  }
})
```

***

### BootStrap

内容整理：[zhangferry](https://zhangferry.com)

目前 Web 应用广泛使用在 PC、Pad、移动端等多个平台，但各个端的布局样式相差较大，如果能使用统一的方式描述布局将是非常有必要的，而这就是 BootStrap 的主要功能之一。

BootStrap 最初由 Twitter 开发，后在Github [开源](https://github.com/twbs/bootstrap)。它除了解决不同端统一布局的问题，还封装了很多可重用的组件，例如下拉菜单，弹框等，可以直接调用。另外它还提供一套优雅的 HTML + CSS 规范，统一了代码风格。

前端框架很多，但即使再多也都是围绕 HTML + CSS + JavaScript 展开的。前一篇讲的 React、Vue 都是工作在 JavaScript 这一层的，BootStrap 则主要工作在 HTML、CSS 这一层。

这个网站整理了很多基于 BootStrap 建立的站点：https://www.youzhan.org/

### 什么是 Webpack

内容整理：[师大小海腾](https://juejin.cn/user/782508012091645)

近年来 Web 应用变得更加复杂与庞大，它们拥有着复杂的 JavaScript 代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出很多好的实践方法：

* 模块化，让我们可以把复杂的程序细化为小的文件；
* 类似于 TypeScript 这种在 JavaScript 基础上拓展的开发语言：使我们能够实现目前版本的 JavaScript 不能直接使用的特性，并且之后还能能转换为 JavaScript 文件使浏览器可以识别；
* scss，less 等 CSS 预处理器；

这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别，而手动处理又是非常繁琐的，这就为 Webpack 这一类的工具的出现提供了需求。

其官网的首页图很形象的画出了 Webpack 是什么，如下：

![](https://cdn.zhangferry.com/Images/20210612002026.png)

其是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 Webpack 处理应用程序时，它会在内部构建一个 [依赖图(dependency graph)](https://webpack.docschina.org/concepts/dependency-graph/)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。

参考：[gwuhaolin/dive-into-webpack](https://github.com/gwuhaolin/dive-into-webpack "gwuhaolin/dive-into-webpack")，[什么是webpack打包工具以及其优点用法](https://blog.csdn.net/weixin_42941619/article/details/87706623 "什么是webpack打包工具以及其优点用法")

### 什么是 Flutter

![](https://cdn.zhangferry.com/Images/20210613093819.png)

内容整理：[我是熊大](https://juejin.cn/user/1151943916921885/posts)

Flutter 是目前开发者首选的跨平台开发框架。Flutter 2.2在 Google I/O 2021 大会上正式发布，从移动设备扩展到 web、桌面设备以及嵌入式设备，真正实现了全端覆盖。

Flutter的核心原则是一切皆为 widget，与其他将视图、控制器、布局和其他属性分离的框架不同，Flutter具有一致的统一对象模型：widget。

> 当前iOS的界面元素由 UIView + UIViewController + AutoLayout 组合而成，到了 SwiftUI 则统一用 View 描述，类似 Flutter 的 widget。

其使用声明式语法，比如实现一个简单 widget padding 的功能：

```dart
@override
Widget build(BuildContext context) {
  return Scaffold(
    appBar: AppBar(
      title: Text("Sample App"),
    ),
    body: Center(
      child: CupertinoButton(
        onPressed: () {
          setState(() { _pressedCount += 1; });
        },
        child: Text('Hello'),
        padding: EdgeInsets.only(left: 10.0, right: 10.0),
      ),
    ),
  );
}
```

Flutter 拥有更优的性能，主要原因就是它用于一套自己独有的渲染引擎，其整理架构如下：

![](https://cdn.zhangferry.com/Images/20210613103605.png)

Flutter 仍有一些缺点，即导致包体变大，iOS 引入后，包体积增加 10MB 左右。

推荐文章：[Flutter实用教程](https://flutter.cn/docs/cookbook "Flutter实用教程")
